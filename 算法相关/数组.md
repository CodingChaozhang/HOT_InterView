##  大数据处理

### 0.具体思路：



[大数据处理 - 分治/hash/排序]()

- 就是先映射，而后统计，最后排序:
- `分而治之/hash映射`: 针对数据太大，内存受限，只能是: 把大文件化成(取模映射)小文件，即16字方针: 大而化小，各个击破，缩小规模，逐个解决
- `hash_map统计`: 当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。
- `堆/快速排序`: 统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP。

[大数据处理 - Bitmap & Bloom Filter]()

- 布隆过滤器有着广泛的应用，对于大量数据的“存不存在”的问题在空间上有明显优势，但是在判断存不存在是有一定的错误率(false positive)，也就是说，有可能把不属于这个集合的元素误认为属于这个集合(False Positive)，但不会把属于这个集合的元素误认为不属于这个集合(False Negative)

[大数据处理 - 双层桶划分]()

- 其实本质上还是分而治之的思想，重在“分”的技巧上！`适用范围`: 第k大，中位数，不重复或重复的数字；`基本原理及要点`: 因为元素范围很大，不能利用直接寻址表，所以通过多次划分，逐步确定范围，然后最后在一个可以接受的范围内进行。

[大数据处理 - Trie树/数据库/倒排索引]()

- `适用范围`: 数据量大，重复多，但是数据种类小可以放入内存；`基本原理及要点`: 实现方式，节点孩子的表示方式；`扩展`: 压缩实现

[大数据处理 - 外排序]()

- `适用范围`: 大数据的排序，去重；`基本原理及要点`: 外排序的归并方法，置换选择败者树原理，最优归并树

[大数据处理 - Map & Reduce]()

- MapReduce是一种计算模型，简单的说就是将大批量的工作(数据)分解(MAP)执行，然后再将结果合并成最终结果(REDUCE)。这样做的好处是可以在任务被分解后，可以通过大量机器进行并行计算，减少整个操作的时间。但如果你要我再通俗点介绍，那么，说白了，Mapreduce的原理就是一个归并排序

### 1.大数据处理-分治/hash/排序

#### a.思路简介

> 分而治之/hash映射 +hash统计+堆/快速/归并排序。即先映射，而后统计，最后排序。

`分而治之/hash映射`: 针对数据太大，内存受限，只能是: 把大文件化成(取模映射)小文件，即16字方针: 大而化小，各个击破，缩小规模，逐个解决

`hash_map统计`: 当大文件转化了小文件，那么我们便可以采用常规的hash_map(ip，value)来进行频率统计。

`堆/快速排序`: 统计完了之后，便进行排序(可采取堆排序)，得到次数最多的IP

#### b.案例分析

**(1) 海量日志文件，提取出某日访问百度次数最多的那个IP**

分析:  “首先是这一天，并且是访问百度的日志中的IP取出来，逐个写入到一个大文件中。注意到IP是32位的，最多有个2^32个IP。同样可以采用映射的方法，比如%1000，把整个大文件映射为1000个小文件，再找出每个小文中出现频率最大的IP(可以采用hash_map对那1000个文件中的所有IP进行频率统计，然后依次找出各个文件中频率最大的那个IP)及相应的频率。然后再在这1000个最大的IP中，找出那个频率最大的IP，即为所求。”

关于本题，还有几个问题，如下:

- Hash取模是一种等价映射，不会存在同一个元素分散到不同小文件中的情况，即这里采用的是mod1000算法，那么相同的IP在hash取模后，只可能落在同一个文件中，不可能被分散的。因为如果两个IP相等，那么经过Hash(IP)之后的哈希值是相同的，将此哈希值取模(如模1000)，必定仍然相等。
- 那到底什么是hash映射呢? 简单来说，就是为了便于计算机在有限的内存中处理big数据，从而通过一种映射散列的方式让数据均匀分布在对应的内存位置(如大数据通过取余的方式映射成小树存放在内存中，或大文件映射成多个小文件)，而这个映射散列方式便是我们通常所说的hash函数，设计的好的hash函数能让数据均匀分布而减少冲突。尽管数据映射到了另外一些不同的位置，但数据还是原来的数据，只是代替和表示这些原始数据的形式发生了变化而已。



**案例2：寻找热门查询，300万个查询字符串中统计最热门的10个查询**

原题: 搜索引擎会通过日志文件把用户每次检索使用的所有检索串都记录下来，每个查询串的长度为1-255字节。假设目前有一千万个记录(这些查询串的重复度比较高，虽然总数是1千万，但如果除去重复后，不超过3百万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门)，请你统计最热门的10个查询串，要求使用的内存不能超过1G。

解答: 由上面第1题，我们知道，数据大则划为小的，如如一亿个Ip求Top 10，可先%1000将ip分到1000个小文件中去，并保证一种ip只出现在一个文件中，再对每个小文件中的ip进行hashmap计数统计并按数量排序，最后归并或者最小堆依次处理每个小文件的top10以得到最后的结。

但如果数据规模比较小，能一次性装入内存呢?比如这第2题，虽然有一千万个Query，但是由于重复度比较高，因此**事实上只有300万的Query，每个Query255Byte**，因此我们可以考虑把他们都放进内存中去(300万个字符串假设没有重复，都是最大长度，那么最多占用内存3M*1K/4=0.75G。所以可以将所有字符串都存放在内存中进行处理)，而现在只是需要一个合适的数据结构，在这里，**HashTable绝对是我们优先的选择。**

所以我们放弃分而治之/hash映射的步骤，直接上hash统计，然后排序。So，针对此类典型的TOP K问题，采取的对策往往是: hashmap + 堆。如下所示:

- `hash_map统计`: 先对这批海量数据预处理。具体方法是: 维护一个Key为Query字串，Value为该Query出现次数的HashTable，即hash_map(Query，Value)，每次读取一个Query，如果该字串不在Table中，那么加入该字串，并且将Value值设为1；如果该字串在Table中，那么将该字串的计数加一即可。**最终我们在O(N)的时间复杂度内用Hash表完成了统计**； 堆排序: 第二步、**借助堆这个数据结构，找出Top K，时间复杂度为N‘logK。即借助堆结构**，我们可以在log量级的时间内查找和调整/移动。因此，维护一个K(该题目中是10)大小的小根堆，然后遍历300万的Query，分别和根元素进行对比。所以，我们最终的时间复杂度是: O(N) + N' * O(logK)，(N为1000万，N’为300万)。

别忘了这篇文章中所述的堆排序思路: “维护k个元素的最小堆，即用容量为k的最小堆存储最先遍历到的k个数，并假设它们即是最大的k个数，建堆费时O(k)，并调整堆(费时O(logk))后，有k1>k2>...kmin(kmin设为小顶堆中最小元素)。继续遍历数列，每次遍历一个元素x，与堆顶元素比较，若x>kmin，则更新堆(x入堆，用时logk)，否则不更新堆。这样下来，总费时O(k*logk+(n-k)*logk)=O(n*logk)。此方法得益于在堆中，查找等各项操作时间复杂度均为logk。”--第三章续、Top K算法问题的实现。   当然，你也可以采用trie树，关键字域存该查询串出现的次数，没有出现为0。最后用10个元素的最小推来对出现频率进行排序。



**案例3：**有一个1G大小的一个文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M。返回频数最高的100个词。

`分而治之/hash映射`: 顺序读文件中，对于每个词x，取hash(x)%5000，然后按照该值存到5000个小文件(记为x0,x1,...x4999)中。这样每个文件大概是200k左右。如果其中的有的文件超过了1M大小，还可以按照类似的方法继续往下分，直到分解得到的小文件的大小都不超过1M。

`hash_map统计`: 对每个小文件，采用trie树/hash_map等统计每个文件中出现的词以及相应的频率。

`堆/归并排序`: 取出出现频率最大的100个词(可以用含100个结点的最小堆)后，再把100个词及相应的频率存入文件，这样又得到了5000个文件。最后就是把这5000个文件进行归并(类似于归并排序)的过程了。







## topK问题解决方案

针对top k类问题，通常比较好的方案是【**分治**+**trie树/hash**+**小顶堆**】，即先将数据集按照hash方法分解成多个小数据集，然后使用trie树或者hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。

结合限制条件考虑：

1 单机+单核+足够大内存

设每个查询词平均占8Byte，则10亿个查询词所需的内存大约是10^9*8=8G内存。如果你有这么大的内存，直接在内存中对查询词进行排序，顺序遍历找出10个出现频率最大的10个即可。这种方法简单快速，更加实用。当然，也可以先用HashMap求出每个词出现的频率，然后求出出现频率最大的10个词。

2 单机+多核+足够大内存

这时可以直接在内存中实用hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑是同1类似，最后一个线程将结果归并。

该方法存在一个瓶颈会明显影响效率，即数据倾斜，每个线程的处理速度可能不同，快的线程需要等待慢的线程，最终的处理速度取决于慢的线程。解决方法是，将数据划分成c*n个partition（c>1），每个线程处理完当前partition后主动取下一个partition继续处理，直到所有数据处理完毕，最后由一个线程进行归并。

3 单机+单核+受限内存

这种情况下，需要将原数据文件切割成一个一个小文件，如，采用hash(x)%M，将原文件中的数据切割成M小文件，如果小文件仍大于内存大小，继续采用hash的方法对数据文件进行切割，直到每个小文件小于内存大小，这样，每个文件可放到内存中处理。采用1的方法依次处理每个小文件。

4 多机+受限内存

这种情况下，为了合理利用多台机器的资源，可将数据分发到多台机器上，每台机器采用3中的策略解决本地的数据。可采用hash+socket方法进行数据分发。

从实际应用的角度考虑，1~4的方案并不可行，因为在大规模数据处理环境下，作业效率并不是首要考虑的问题，算法的扩展性和容错性才是首要考虑的。算法应该具有良好的扩展性，以便数据量进一步加大（随着业务的发展，数据量加大是必然的）时，在不修改算法框架的前提下，可达到近似的线性比；算法应该具有容错性，即当前某个文件处理失败后，能自动将其交给另外一个线程继续处理，而不是从头开始处理。

Top k问题很适合采用MapReduce框架解决，用户只需编写一个map函数和两个reduce 函数，然后提交到Hadoop（采用mapchain和reducechain）上即可解决该问题。对于map函数，采用hash算法，将hash值相同的数据交给同一个reduce task；对于第一个reduce函数，采用HashMap统计出每个词出现的频率，对于第二个reduce 函数，统计所有reduce task输出数据中的top k即可。





## 网络编程

### 多线程下的通讯问题

```java
package com.lcz.autumn;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.UnknownHostException;

public class MultiThreadSocket extends Thread{
	
	private Socket socket;
	
	public MultiThreadSocket() {
		
	}
	
	public MultiThreadSocket(Socket socket) {
		this.socket = socket;
	}
	
	/**
	 * 服务端
	 */
	public static void server() {
		//创建套接字
		try {
			ServerSocket ss = new ServerSocket(8000);
			//等待用户请求
			while(true) {
				Socket sk = ss.accept();
				//开启线程
				new MultiThreadSocket(sk).start();
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void client(String s) {
		try {
			Socket s1 = new Socket("127.0.0.1",8000);
			//获取到输出流
			OutputStream  os = s1.getOutputStream();
			//发送
			os.write((s+" hello world!").getBytes());
			//
			InputStream is = s1.getInputStream();
			byte[] buffer = new byte[1024];
			int length = is.read(buffer);
			String messgage = new String(buffer,0,length);
			System.out.println("server:"+messgage);
			//关闭
			os.close();
			is.close();
			s1.close();
			
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	/**
	 * 重写其run方法
	 */
	@Override
	public void run() {
		//读取数据
		try {
			InputStream is = socket.getInputStream();
			//读取
			byte[] buffer = new byte[1024];
			int length = is.read(buffer);
			//输出
			String message = new String(buffer,0,length);
			System.out.println("client:"+message);
			//收到消息之后在发送给对方
			//输出流
			OutputStream os = socket.getOutputStream();
			os.write(message.getBytes());
			
			//关闭
			is.close();
			os.close();
			socket.close();
			
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	
	
}

```



```java
package com.lcz.autumn;

public class TestServer {
	public static void main(String[] args) {
		MultiThreadSocket.server();
	}
}

```





```java
package com.lcz.autumn;

public class TestClient {
	public static void main(String[] args) {
		for(int i=0;i<10;i++) {
			MultiThreadSocket m = new MultiThreadSocket();
			m.client(i+"");
		}
	}
}

```



### TCP中的Socket和UDPSocket

#### TCP Socket编程

![image-20210820214243833](E:/笔记/面试高频/imgs/734.png)

**线程工具类**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;

public class ServerThread implements Runnable{

    Socket socket = null;
    public ServerThread(Socket socket){
        this.socket = socket;
    }
    @Override
    public void run() {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;
        OutputStream os = null;
        PrintWriter pw = null;
        //与客户端建立通信，获取输入流，读取客户端提供的信息
        try {
            is = socket.getInputStream();
            isr = new InputStreamReader(is,"UTF-8");
            br = new BufferedReader(isr);
            String data = null;
            while((data = br.readLine())!=null){
                System.out.println("我是服务器，客户端提交的信息为："+data);
                socket.shutdownInput();//关闭输入流

                //获取输出流，响应客户端的请求
                os = socket.getOutputStream();
                pw = new PrintWriter(os);
                pw.write("服务器端响应成功");
                pw.flush();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally{
            //关闭资源和相关socket
            try{
                if(pw!=null){
                    pw.close();
                }
                if(os!=null){
                    os.close();
                }
                if(is!=null){
                    is.close();
                }
                if(isr!=null){
                    isr.close();
                }
                if(br!=null){
                    br.close();
                }
                if(socket!=null){
                    socket.close();
                }
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }
}
```

**服务端**

```java
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args){
        //创建一个服务器端的Socket，即ServerSocket，绑定需要监听的端口
        try {
            ServerSocket serverSocket = new ServerSocket(8888);
            Socket socket = null;
            //记录连接过服务器端客户端数量
            int count = 0;
            System.out.println("服务期即将启动,等待客户端的连接");
            while(true){//循环监听新的客户端的连接
                //调用accept（）方法监听，等待客户端的连接以获取Socket实例
                socket = serverSocket.accept();
                //创建新线程
                Thread thread = new Thread(new ServerThread(socket));
                thread.start();
                count++;
                System.out.println("服务器端被连接过的次数："+count);
                
                InetAddress address = socket.getInetAddress();
                System.out.println("当前客户端IP为："+address.getHostAddress());
            }
            //服务器端的连接不用关闭。
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
```

**客户端**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;


public class Client1 {
    public static void main(String[] args) {
        try{
            Socket socket = new Socket("localhost",8888);
            OutputStream os = socket.getOutputStream();
            PrintWriter pw = new PrintWriter(os);
            pw.write("用户名:jinxueling;密码：123");
            pw.flush();
            socket.shutdownOutput();
            
            InputStream is = socket.getInputStream();
            InputStreamReader isr = new InputStreamReader(is,"UTF-8");
            BufferedReader br = new BufferedReader(isr);
            String data = null;
            while((data = br.readLine())!=null){
                System.out.println("我是客户端，服务器端响应的数据为："+data);
            }
              socket.close();
        }catch (UnknownHostException e) {
            e.printStackTrace();
        }catch(IOException e){
            e.printStackTrace();
        } 
    }
}
```



#### UDPSocket

![image-20210820215044060](E:/笔记/面试高频/imgs/735.png)

　　**线程工具类**

```java
package UDPSocket;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPThread implements Runnable{
    
    DatagramSocket socket = null;
    DatagramPacket packet = null;
    public UDPThread(DatagramSocket socket,DatagramPacket packet){
        this.socket = socket;
        this.packet = packet;
    }
    @Override
    public void run() {
        String info = null;
        InetAddress address = null;
        int port = 8800;
        byte[] data2 = null;
        DatagramPacket packet2 = null;
        try{
            //打印当前请求socket客户端的请求数据和信息。
            info = new String(packet.getData(),0,packet.getLength());
            System.out.println("我是服务器，客户端说："+info);
            //封装数据包，响应给当前socket实例的客户端
            address = packet.getAddress();
            port = packet.getPort();
            data2 = "我在响应你".getBytes();
            packet2 = new DatagramPacket(data2, data2.length,address,port);
            socket.send(packet2);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

**服务端**

```java
package UDPSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

public class UDPServer {
    public static void main(String[] args) throws IOException {
        try {
            //创建指定端口的DatagramSocket
            DatagramSocket socket = new DatagramSocket(8800);
            //声明数据报
            DatagramPacket packet = null;
            //声明字节数组
            byte[] data = null;
            //服务器响应的连接计数
            int count = 0;
            System.out.println("服务器启动，等待发送数据");
            //等待客户端连接
            while(true){
                //初始化字节数组容量，指定接收的数据包的大小
                data = new byte[1024];
                //初始化数据包
                packet = new DatagramPacket(data,data.length);
                //等待接收来自服务端的数据包
                socket.receive(packet);
                //到达这一步，socket.receive方法停止阻塞了，说明有客户端在请求了
                //给该客户端创建一个独立的线程，并根据接收到的包，给予响应。
                Thread thread = new Thread(new UDPThread(socket,packet));
                thread.start();
                count++;
                System.out.println("服务器端被连接过的次数："+count);
                //打印当前的客户端socket的ip
                InetAddress address = packet.getAddress();
                System.out.println("当前客户端的IP为："+address.getHostAddress());
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }
}
```

　　**客户端**

```java
package UDPSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPClient {
    public static void main(String[] args) throws IOException {
        //定义服务器的地址，端口号，数据
        InetAddress address = InetAddress.getByName("localhost");
        int port = 8800;
        byte[] data = "用户名：admin；密码：123".getBytes();
        //创建数据报
        DatagramPacket packet = new DatagramPacket(data,data.length,address,port);
        //创建DatagramSocket，实现数据发送和接收
        DatagramSocket socket = new DatagramSocket();
        //向服务器发送数据报
        socket.send(packet);
        
        //接收服务器 响应数据
        byte[] data2 = new byte[1024];
        DatagramPacket packet2 = new DatagramPacket(data2,data2.length);
        socket.receive(packet2);
        String info = new String(data2,0,packet2.getLength());
        System.out.println("我是客户端，服务器说："+info);
        socket.close();
    }
}
```

#### .**为什么服务端需要产生两个socket(listen_socket_fd和connect_socket_fd)**

　　答：监听socket是服务器作为客户端连接请求的一个对端，只需创建一次即可，它存在于服务器的整个生命周期，可为成千上万的客户端服务，而一旦一个客户端和服务器连接成功，完成了TCP三次握手，操作系统内核就为这个客户端生成一个已连接套接字（connect_socket_fd），让应用服务器使用这个connect_socket_fd和客户端进行通信，如果应用服务器完成了对这个客户端的服务，那么关闭的就是已连接套接字，这样就完成了TCP连接的释放。请注意，这个时候释放的只是这一个客户端连接，其它被服务的客户端连接可能还存在。最重要的是，监听套接字一直都处于“监听”状态，等待新的客户请求到达并服务。若只使用一个listen_socket_fd完成从创建监听到被请求连接，处理请求，关闭socket的整个过程，那么这个socket就会一直被占用，而不能被其它的客户端请求，造成服务端性能低下。使用两个socket，按职责分工，listen_socket_fd专门负责响应客户端的请求，每个新的connect_socket_fd专门负责该次连接的数据交互，分层协作，提高服务端的性能。

#### 1.端口号的作用

端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程。

#### 1.端口号的应用场景

在TCP/IP协议中，用“源IP地址”，“目的IP地址”，“源端口号”，“目的端口号”,协议号（IP协议的协议号为4，TCP的协议号为6）这样的一个五元组来标识一个通信，通信的双方在发送消息时，消息的头部会带着这样的五元组。

#### 2.一个进程是否可以bind多个端口号？可以

因为一个进程可以打开多个文件描述符，而每个文件描述符都对应一个端口号，所以一个进程可以绑定多个端口号。

Linux内核会给每一个socket分配一个唯一的文件描述符，进程通过该文件描述符来区分对应的套接字。

#### 3.**一个端口号是否可以被多个进程绑定？**

同种协议通常不可以，但有一种情况可以。

ps：如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的。

#### 4.一台服务器上最多能连接的连接数

>  经常听到有同学说一台机器最多能创建65535个TCP连接，这其实是错误的理解，为什么会有这个错误的理解呢？

**port range**

我们都知道linux下本地随机端口范围由参数控制

```text
# cat /proc/sys/net/ipv4/ip_local_port_range 
10000   65535
```

port range的上限是65535，所以也经常看到这个**误解**：一台机器上最多能创建65535个TCP连接

**到底一台机器上最多能创建多少个TCP连接**

先说**结论**：在内存、文件句柄足够的话可以创建的连接是没有限制的（每个TCP连接至少要消耗一个文件句柄）。

那么/proc/sys/net/ipv4/ip_local_port_range指定的端口范围到底是什么意思呢？

核心规则：**一个TCP连接只要保证四元组(src-ip src-port dest-ip dest-port)唯一就可以了，而不是要求src port唯一**

后面所讲都遵循这个规则，所以在心里反复默念：**四元组唯一** 五个大字，就能分析出来到底能创建多少TCP连接了。

比如如下这个机器上的TCP连接实际状态：

比如如下这个机器上的TCP连接实际状态：

```text
# netstat -ant |grep 18089
tcp        0      0 192.168.1.79:18089      192.168.1.79:22         ESTABLISHED
tcp        0      0 192.168.1.79:18089      192.168.1.79:18080      ESTABLISHED
tcp        0      0 192.168.0.79:18089      192.168.0.79:22         TIME_WAIT 
tcp        0      0 192.168.1.79:22         192.168.1.79:18089      ESTABLISHED
tcp        0      0 192.168.1.79:18080      192.168.1.79:18089      ESTABLISHED
```

从前三行可以清楚地看到18089被用了三次，第一第二行src-ip、dest-ip也是重复的，但是dest port不一样，第三行的src-port还是18089，但是src-ip变了。他们的四元组均不相同。

所以一台机器能创建的TCP连接是没有限制的，而ip_local_port_range是指没有bind的时候OS随机分配端口的范围，但是分配到的端口要同时满足五元组唯一，这样 ip_local_port_range 限制的是连同一个目标（dest-ip和dest-port一样）的port的数量（请忽略本地多网卡的情况，因为dest-ip为以后route只会选用一个本地ip）。

我们在创建连接前，经常会先调bind，bind后可以调listen当做服务端监听，也可以直接调connect当做client来连服务端。

bind(ip,port=0) 的时候是让系统绑定到某个网卡和自动分配的端口，此时系统没有办法确定接下来这个socket是要去connect还是listen. **如果是listen的话，那么肯定是不能出现端口冲突的，如果是connect的话，只要满足4元组唯一即可。**在这种情况下，系统只能尽可能满足更强的要求，就是先要求端口不能冲突，即使之后去connect的时候四元组是唯一的。

**但如果我只是个client端，只需要连接server建立连接，也就不需要bind，直接调connect就可以了，这个时候只要保证四元组唯一就行。**

**bind()的时候内核是还不知道四元组的，只知道src_ip、src_port，所以这个时候单网卡下src_port是没法重复的，但是connect()的时候已经知道了四元组的全部信息，所以只要保证四元组唯一就可以了**，那么这里的src_port完全是可以重复使用的。

**是不是加上了 SO_REUSEADDR、SO_REUSEPORT 就能重用端口了呢？**

#### 5.如果是listen的话，那么肯定是不能出现端口冲突的，如果是connect的话，只要满足4元组唯一即可。

#### 6.结论

- 在内存、文件句柄足够的话一台服务器上可以创建的TCP连接数量是没有限制的
- SO_REUSEADDR 主要用于快速重用 TIME_WAIT状态的TCP端口，避免服务重启就会抛出Address Already in use的错误
- SO_REUSEPORT主要用来解决惊群、性能等问题
- local port的选择是递增搜索的，搜索起始port随时间增加也变大

#### 7.惊群现象

> 惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。

#### 8.TIME_WAIT状态产生的原因

**1）为实现TCP全双工连接的可靠释放**

由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。

**2）为使旧的数据包在网络因过期而消失**

为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。

#### 9.TIME_WAIT状态如何避免

首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，**如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态**。



#### 10.TIME_WAIT状态的危害

- 大量 time_wait 状态存在，会导致新建 TCP 连接会出错，address already in use : connect 异常

## 多线程

### 高频【代码题】三个线程循环打印自然数-线程题

-**一、多个线程顺序循环打印递增的自然数，例如 3 个线程：t-0，t-1，t-2，程序输出如下：**
**t-0 0**
**t-1 1**
**t-2 2**
**t-0 3**
**t-1 4**
**t-2 5**

```java
package com.lcz.thread;

import java.util.concurrent.Semaphore;

// 类
class Num{
	// 自然数
	int i = 0;
	int n;


	// 初始化
	public  Num(int n) {
		this.n = n;
	}
	// 依次打印
	Semaphore s0 = new Semaphore(1);
	Semaphore s1 = new Semaphore(0);
	Semaphore s2 = new Semaphore(0);
	// 第一个线程打印的方法
	public void print0() throws InterruptedException {
		for(int i=0;i<n;i+=3) {
			s0.acquire();
			System.out.println(Thread.currentThread().getName() + " "+ i);
			s1.release();
		}
	}
	
	// 第二个线程打印方法
	public void print_2() throws InterruptedException {
		for(int i=1;i<n;i+=3) {
			s1.acquire();
			System.out.println(Thread.currentThread().getName()+ " " + i);
			s2.release();
		}

	}
	
	// 第三个线程打印方法
	public void print_3() throws InterruptedException {
		for(int i=2;i<n;i+=3) {
			s2.acquire();
			System.out.println(Thread.currentThread().getName()+ " " + i);
			s0.release();
		}

	}
}
public class Test25 {
	public static void main(String[] args) {
		Num num = new Num(10);
		// 线程
		Thread t0 = new Thread(()->{
			try {
				num.print0();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t0");
		
		Thread t1 = new Thread(()->{
			try {
				num.print_2();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t1");
		
		Thread t2 = new Thread(()->{
			try {
				num.print_3();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t2");
		
		t0.start();
		t1.start();
		t2.start();
	}
}

```



```java
import java.util.*;

//阻塞队列
class BlockingQueue{
 Queue<Integer> list;
 int size;
 public BlockingQueue(int n){
     list = new LinkedList<>();
     size = n;
 }
 //生产
 public void put(int data) throws InterruptedException{
     synchronized(list){
         //队列长度大于10阻塞
         while(list.size()>size){
        	 System.out.println("队列已经满了，当前数据阻塞中..."+data);
             list.wait();
         }
         list.offer(data);
         list.notifyAll();
     }
 }
 //消费
 public int poll() throws InterruptedException{
     synchronized(list){
         //空的情况下阻塞
         while(list.size()==0){
        	 System.out.println("队列为空，当前取操作被阻塞了...");
             list.wait();
         }
         int res = list.poll();
         list.notifyAll();
         return res;
     }
 }


}

public class Main {
 
 
 public static void main(String[] args) {
     //Scanner in = new Scanner(System.in);
     //int a = in.nextInt();
     //System.out.println(a);
     //模拟两个线程 一个放入一个取
     BlockingQueue queue = new BlockingQueue(10);
     Thread t1 = new Thread( ()->{
         try {
        	 for(int i=0;i<100;i++) {
        		 System.out.println(Thread.currentThread().getName()+" put "+ i);
        		 queue.put(i);
        	 }
         } catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
     },"producer");
     
     Thread t2 = new Thread(  ()->{
    	 try {
        	 for(int i=0;i<100;i++) {
        		 System.out.println(Thread.currentThread().getName()+" get "+queue.poll());
        	 }
         } catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
    	 
     },"consumer");
     t1.start();
     t2.start();
     
 }
}
```

### [Leetcode1188 设计阻塞队列]

实现一个拥有如下方法的线程安全有限阻塞队列：

```
BoundedBlockingQueue(int capacity) 构造方法初始化队列，其中capacity代表队列长度上限。
void enqueue(int element) 在队首增加一个element. 如果队列满，调用线程被阻塞直到队列非满。
int dequeue() 返回队尾元素并从队列中将其删除. 如果队列为空，调用线程被阻塞直到队列非空。
int size() 返回当前队列元素个数。

```

你的实现将会被多线程同时访问进行测试。每一个线程要么是一个只调用enqueue方法的生产者线程，要么是一个只调用dequeue方法的消费者线程。size方法将会在每一个测试用例之后进行调用。

请不要使用内置的有限阻塞队列实现，否则面试将不会通过。

示例1：

输入:
1
1
["BoundedBlockingQueue","enqueue","dequeue","dequeue","enqueue","enqueue","enqueue","enqueue","dequeue"]
[[2],[1],[],[],[0],[2],[3],[4],[]]

输出:
[1,0,2,2]

解释:
生产者线程数目 = 1
消费者线程数目 = 1

BoundedBlockingQueue queue = new BoundedBlockingQueue(2);   // 使用capacity = 2初始化队列。

queue.enqueue(1);   // 生产者线程将1插入队列。
queue.dequeue();    // 消费者线程调用dequeue并返回1。
queue.dequeue();    // 由于队列为空，消费者线程被阻塞。
queue.enqueue(0);   // 生产者线程将0插入队列。消费者线程被解除阻塞同时将0弹出队列并返回。
queue.enqueue(2);   // 生产者线程将2插入队列。
queue.enqueue(3);   // 生产者线程将3插入队列。
queue.enqueue(4);   // 生产者线程由于队列长度已达到上限2而被阻塞。
queue.dequeue();    // 消费者线程将2从队列弹出并返回。生产者线程解除阻塞同时将4插入队列。
queue.size();       // 队列中还有2个元素。size()方法在每组测试用例最后调用。

解题思路：我们可以实时监控Queue的元素个数，在执行插入操作时，如果Queue中元素个数已经达到上限，我们需要阻塞当前线程，直到队列中元素个数小于上限。同理，执行删除操作时，我们也要实时监控元素个数是否为0，如果队列为空，我们需要阻塞当前线程。

```java
class BoundedBlockingQueue {
	// 队列
    Queue<Integer> queue = new LinkedList<>();
    int size;
    public BoundedBlockingQueue(int capacity){
        // 队列上限
        size = capacity;
    }
    
    // 入队列
    public void enqueue(int element) throws InterruptedException{
        // 保证Queue不会同时被多个线程操作
        synchronized(queue){
            // 如果到达存储上限，阻塞当前线程
            while(queue.size()==size){
                queue.wait();
            }
            // 将元素添加
            queue.offer(element);
            // 通知所有线程队列已经被更新
            queue.notifyAll();
        }
    }
    
    // 出队列
    public int dequeue() throws InterruptedException{
        // 保证Queue不会同时被多个线程操作
        synchronized(queue){
            //  如果队列为空，阻塞当前线程
            while(queue.size()==0){
                queue.wait();
            }
            // 删除队列一个元素
            int num = queue.poll();
            //  通知所有线程队列已经被更新
            queue.notifyAll();
            return num;
        }
    }
}

```

> 如果用信号量来解题的话

```java
class BoundedBlockingQueue {
    // 信号量
    Semaphore se;
    Semaphore sd;
	// 队列
    Queue<Integer> queue = new LinkedList<>();
    int size;
    public BoundedBlockingQueue(int capacity){
        // 队列上限
        size = capacity;
        se   = new Semaphore(size);
        sd   = new Semaphore(0);
    }
    
    // 入队列
    public void enqueue(int element) throws InterruptedException{
        se.acquire();
        queue.offer(element);
        sd.release();
    }
    
    // 出队列
    public int dequeue() throws InterruptedException{
       sd.acquire();
       int num = q.poll();
        se.release();
        return num;
    }
}

```

### 代码题：实现一个阻塞队列（生产者和消费者的模式）

阻塞队列：poll出队 put入队；要求put和poll都是线程安全的，并且队列满的时候put操作阻塞，队列空的时候poll阻塞

```java
class BlockingQueue{
	// 阻塞队列
	Queue<Integer> list;
	int size;
	public BlockingQueue(int n) {
		list = new LinkedList<>();
		size = n;
	}
	// 入队
	public void put(int data) throws InterruptedException {
		// 防止多个
		synchronized (list) {
			// 判断
			while(list.size()==size) {
				list.wait();
			}
			// 放入元素
			list.offer(data);
			// 通知其他
			list.notifyAll();
		}
	}
	// 出队
	public int poll() throws InterruptedException {
		synchronized (list) {
			// 判断
			if(list.size()==0) {
				list.wait();
			}
			int res = list.poll();
			//通知其他
			list.notifyAll();
			return res;
		}
	}
}
```



### 高频【代码题】三个线程循环打印自然数-线程题

-**一、多个线程顺序循环打印递增的自然数，例如 3 个线程：t-0，t-1，t-2，程序输出如下：**
**t-0 0**
**t-1 1**
**t-2 2**
**t-0 3**
**t-1 4**
**t-2 5**

```java
package com.lcz.thread;

import java.util.concurrent.Semaphore;

// 类
class Num{
	// 自然数
	int i = 0;
	int n;


	// 初始化
	public  Num(int n) {
		this.n = n;
	}
	// 依次打印
	Semaphore s0 = new Semaphore(1);
	Semaphore s1 = new Semaphore(0);
	Semaphore s2 = new Semaphore(0);
	// 第一个线程打印的方法
	public void print0() throws InterruptedException {
		for(int i=0;i<n;i+=3) {
			s0.acquire();
			System.out.println(Thread.currentThread().getName() + " "+ i);
			s1.release();
		}
	}
	
	// 第二个线程打印方法
	public void print_2() throws InterruptedException {
		for(int i=1;i<n;i+=3) {
			s1.acquire();
			System.out.println(Thread.currentThread().getName()+ " " + i);
			s2.release();
		}

	}
	
	// 第三个线程打印方法
	public void print_3() throws InterruptedException {
		for(int i=2;i<n;i+=3) {
			s2.acquire();
			System.out.println(Thread.currentThread().getName()+ " " + i);
			s0.release();
		}

	}
}
public class Test25 {
	public static void main(String[] args) {
		Num num = new Num(10);
		// 线程
		Thread t0 = new Thread(()->{
			try {
				num.print0();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t0");
		
		Thread t1 = new Thread(()->{
			try {
				num.print_2();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t1");
		
		Thread t2 = new Thread(()->{
			try {
				num.print_3();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		},"t2");
		
		t0.start();
		t1.start();
		t2.start();
	}
}

```

多线程按序打印
时间限制： 3000MS
内存限制： 1048576KB
题目描述：
随着中国经济的增强，无数的企业正在“出海”，作为中国文化的视频传媒佼佼者，爱奇艺也在“出海”的队伍里扬帆起航，但在出海的过程中遇到了一个语言的问题，为了让更多国外用户能体验我们丰富多彩的中国文化，需要将中文的字幕翻译成各国语言，为此，我们的小明同学实现了一个万能翻译的系统，然而由于我们需要翻译的字幕太多，无法第一时间翻译完让用户观看到，聪明的你能帮帮我们的小明同学吗？

要求：

1. 请使用多线程重写translatedAll方法来提升翻译速度

2. 请注意翻译后的line的前后顺序要和输入的List<line>的顺序保持一致，因为字幕的顺序是不能乱的



输入描述
字幕文本，每行字幕以逗号分隔

输出描述
翻译好的字幕文本，每行字幕以逗号分隔

样例输入
aaa,bbb,ccc
样例输出
AAA,BBB,CCC

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.concurrent.*;
import java.util.stream.Collectors;


public class Main {


    public static void main(String[] args) throws InterruptedException {
        Solution s = new Solution();
        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(10, 10,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<Runnable>(10000));
        final Scanner reader = new Scanner(System.in);
        final String next = reader.next();
        List<Line> lines = Arrays.stream(next.split(",")).map(str -> new StringLine(str))
                .collect(Collectors.toList());
        List<Line> result = s.translateAll(lines, "", threadPoolExecutor);
        String resultString = result.stream().map(l -> l.toString()).collect(Collectors.joining(","));
        System.out.println(resultString);
        reader.close();
        threadPoolExecutor.shutdown();
    }

    public interface Line {
        /**
         * translate the line to the specific language
         * @param language - the language to translate
         * @return the line of translated by the {@code language} */
        Line translate(String language);
    }

    public static class Solution {
        /**
         * translate the all lines to the specific language
         * @param lines the text lines of episode
         * @param language the language to translate
         * @return the lines of translated by the {@code language} */
        public List<Line> translateAll(List<Line> lines, String language, Executor executor) throws InterruptedException {
            Job<Line> job = new Job<>();
            for (Line line : lines) {
                Callable<Line> callable = () -> line.translate(language);
                job.newTask(callable);
            }
            job.execute(executor);
            return job.get();
        }
    }

    public static class Job<V> {
    	//任务
    	List<FutureTask<V>> list = new ArrayList<>();
        public void newTask(Callable<V> runnable) {
        //待实现
        	FutureTask<V> futureTask = new FutureTask<>(runnable);
        	list.add(futureTask);
        }


        public void execute(Executor executor) {
        //待实现
        	for(FutureTask<V> futureTask:list) {
        		executor.execute(futureTask);
        	}
        }

        public List<V> get() throws InterruptedException {
        //待实现
        	List<V> res = new ArrayList<>();
        	for(FutureTask<V> futureTask:list) {
        		try {
					res.add(futureTask.get());
				} catch (ExecutionException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
        	}
        	return res;
        }

    }

    /**
     * translate the string line to upper case
     */
    public static class StringLine implements Line {
        private String text;

        public StringLine(String text) {
            this.text = text;
        }

        @Override
        public Line translate(String language) {
            return new StringLine(text.toUpperCase());
        }


        @Override
        public String toString() {
            return text;
        }
    }
}

```

### 死锁例子

```java
package com.lcz.interview;

// 类
class Task{
	Object o1 = new Object();
	Object o2 = new Object();
	// 方法一
	public void f1() {
		synchronized (o1) {
			System.out.println(Thread.currentThread().getName() + "获取o1资源");
			//休眠
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			// 获取资源2
			synchronized (o2) {
				System.out.println(Thread.currentThread().getName()+"获取o2资源");
			}
		}
	}
	
	public void f2() {
		synchronized (o2) {
			System.out.println(Thread.currentThread().getName() + "获取o2资源");
			//休眠
			try {
				Thread.sleep(500);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			// 获取资源2
			synchronized (o1) {
				System.out.println(Thread.currentThread().getName()+"获取o1资源");
			}
		}
	}
}
public class Test5 {
	public static void main(String[] args) {
		Task task = new Task();
		Thread t1 = new Thread(()->{
			task.f1();
		},"t1");
		Thread t2 = new Thread(()->{
			task.f2();
		},"t2") ;
		// 启动
		t1.start();
		t2.start();
		
	}
}

```

## 多线程其余例子

#### 

**实现用synchronized和wait和notify。对象被synchronized关键字修饰，多个线程获取锁，获取到锁的看条件是否满足，满足就执行，之后wait。不满足就唤醒别的线程notify或者notifyAll()。**

##### 8.1-8.2 多线程下的交替打印的例子汇总版本（交替实现的话 synchronized wait notify必定是两个方法，传递一个值）

###### (1) 多线程下交替打印1-100的线程（三个线程）

###### 使用synchronized、notify和wait来完成三个线程的交替打印

```java
package com.lcz.thread;
// 一个资源交替打印1-100里面
import java.util.*;
//多个线程一个资源
class MyThread{
	// 要打印的资源
	int num = 1;
	// 控制资源的顺序
	int flag = 1;
	
	// 要被调用的算法
	public void increase_1() {
		while(num<99) {
			synchronized (this) {
				while(flag!=1) {
					try {
						wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				// 打印
				System.out.println(Thread.currentThread().getName()+":"+(num++));
				flag = 2;
				// 唤醒
				notifyAll();
			}
		}
	}
	
	
	public void increase_2() {
		while(num<99) {
			synchronized (this) {
				while(flag!=2) {
					try {
						wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				// 打印
				System.out.println(Thread.currentThread().getName()+":"+(num++));
				flag = 3;
				// 唤醒
				notifyAll();
			}
		}
	}
	
	
	public void increase_3() {
		while(num<100) {
			synchronized (this) {
				while(flag!=3) {
					try {
						wait();
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
				}
				// 打印
				System.out.println(Thread.currentThread().getName()+":"+(num++));
				flag = 1;
				// 唤醒
				notifyAll();
			}
		}
	}
}
public class Test7 {
	
	public static void main(String[] args) {
		// 对象
		MyThread myThread = new MyThread();
		// 多线程
		Thread t1 = new Thread(()->{
			myThread.increase_1();
		});
		Thread t2 = new Thread(()->{
			myThread.increase_2();
		});
		Thread t3 = new Thread(()->{
			myThread.increase_3();
		});

		t1.start();
		t2.start();
		t3.start();
	}
}

```

###### 使用reentrantlock和condition来完成三个线程的交替打印

```java
package com.lcz.thread;
// 一个资源交替打印1-100里面
import java.util.*;
import java.util.concurrent.locks.Condition;
//多个线程一个资源
import java.util.concurrent.locks.ReentrantLock;
class MyThread_2{
	int n = 1;
	int flag = 1;
	// 加锁用
	ReentrantLock lock = new ReentrantLock();
	Condition condition = lock.newCondition();
	
	public void increase_1() {
		while(n<99) {
			try {
				lock.lock();
				while(flag!=1) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+n++);
				condition.signal();
				flag = 2;
			} catch (Exception e) {
				// TODO: handle exception
			}finally {
				lock.unlock();
			}
		}
	}
	
	public void increase_2() {
		while(n<99) {
			try {
				lock.lock();
				while(flag!=2) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+n++);
				condition.signal();
				flag = 3;
			} catch (Exception e) {
				// TODO: handle exception
			}finally {
				lock.unlock();
			}
		}
	}
	
	public void increase_3() {
		while(n<100) {
			try {
				lock.lock();
				while(flag!=3) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+n++);
				condition.signal();
				flag = 1;
			} catch (Exception e) {
				// TODO: handle exception
			}finally {
				lock.unlock();
			}
		}
	}
}
public class Test8 {
	
	public static void main(String[] args) {
		// 对象
		MyThread_2 myThread = new MyThread_2();
		// 多线程
		Thread t1 = new Thread(()->{
			myThread.increase_1();
		});
		Thread t2 = new Thread(()->{
			myThread.increase_2();
		});
		
		Thread t3 = new Thread(()->{
			myThread.increase_3();
		});
		t1.start();
		t2.start();
		t3.start();
	}
}

```

###### (2)面试真题-三个线程分别负责打印A，B和C，循环100次

###### ReentrantLock和Condition来完成这项工作

```java
package com.lcz.thread;
// 三个线程
// 匿名内部类

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

class MyThread_3{
	// 标识哪个线程
	int flag = 1;

	// 用reentrantlock和condition
	ReentrantLock lock = new ReentrantLock();
	Condition condition = lock.newCondition();
	
	// 三个方法
	public void increase_1() {
		for(int i=0;i<5;i++) {
			try {
				lock.lock();
				while(flag!=1) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+"A");
				condition.signal();
				flag = 2;
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		}
	}
	
	public void increase_2() {
		for(int i=0;i<5;i++) {
			try {
				lock.lock();
				while(flag!=2) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+"B");
				condition.signal();
				flag = 3;
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		}
	}
	
	public void increase_3() {
		for(int i=0;i<5;i++) {
			try {
				lock.lock();
				while(flag!=3) {
					condition.await();
				}
				System.out.println(Thread.currentThread().getName()+":"+"C");
				condition.signal();
				flag = 1;
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		}
	}
		
}
public class Test9 {
	public static void main(String[] args) {
		MyThread_3 myThread = new MyThread_3();
		
		// 开始
		Thread t1 = new Thread(()->{
			myThread.increase_1();
		},"t1");
		
		Thread t2 = new Thread(()->{
			myThread.increase_2();
		},"t2");
		
		Thread t3 = new Thread(()->{
			myThread.increase_3();
		},"t3");
		
		t1.start();
		t2.start();
		t3.start();
		
	}
}

```

###### LockSupport来解决该问题（交替几个线程几个方法，匿名内部类方法 park阻塞 unpark解开）

```java
package com.lcz.thread;

import java.util.concurrent.locks.LockSupport;

public class Test10 {
	
	static Thread t1 = null,t2=null,t3=null;
	public static void main(String[] args) {
		// 打印次数
		int num = 10;
		
		t1 = new Thread(()->{
			for(int i=0;i<num;i++) {
				//阻塞
				LockSupport.park();
				System.out.println(Thread.currentThread().getName()+":"+"A");
				LockSupport.unpark(t2);
			}
		},"t1");
		
		t2 = new Thread(()->{
			for(int i=0;i<num;i++) {
				//阻塞
				LockSupport.park();
				// 判断
				System.out.println(Thread.currentThread().getName()+":"+"B");
				LockSupport.unpark(t3);
			}
		},"t2");
		
		
		t3 = new Thread(()->{
			for(int i=0;i<num;i++) {
				//阻塞
				LockSupport.park();
				// 判断
				System.out.println(Thread.currentThread().getName()+":"+"C");
				LockSupport.unpark(t1);
			}
		},"t3");
		
		t1.start();
		t2.start();
		t3.start();
		// 开启A
		LockSupport.unpark(t1);
		
	}
}

```

###### (3)面试真题-三个线程批次打印“我爱中国” 

###### LockSupport来实现

```java
package com.lcz.thread;

import java.util.concurrent.locks.LockSupport;

// LockSupport来做
public class Test11 {
	// 打印我爱中国
	static String str = "我爱中国！";
	// 到达这个数组下标索引
	static int index = 0;
	// 几个线程
	static Thread t1 = null,t2=null,t3=null;
	
	public static void main(String[] args) {
		char[] ch = str.toCharArray();
		
		t1 = new Thread(()->{
			// 打印5次
			while(index<str.length()) {
				LockSupport.park();
				if(index<str.length()) {
					System.out.print(Thread.currentThread().getName()+":"+str.charAt(index++));
				}
				LockSupport.unpark(t2);
			}
		},"t1");
		
		t2 = new Thread(()->{
			// 打印5次
			while(index<str.length()) {
				LockSupport.park();
				if(index<str.length()) {
					System.out.print(Thread.currentThread().getName()+":"+str.charAt(index++));
				}
				LockSupport.unpark(t3);
			}
			
		},"t2");
		
		
		t3 = new Thread(()->{
			// 打印5次
			while(index<str.length()) {
				LockSupport.park();
				if(index<str.length()) {
					System.out.print(Thread.currentThread().getName()+":"+str.charAt(index++));
				}
				LockSupport.unpark(t1);
			}
			
		},"t3");
		
		t1.start();
		t2.start();
		t3.start();
		
		LockSupport.unpark(t1);
		
	}
}

```

###### (4) 面试题-三个线程打印三个数组批次打印

###### LockSupport来打印

```java
package com.lcz.thread;

import java.util.concurrent.locks.LockSupport;

public class Test13 {
	// 三个线程
	static Thread t1 = null,t2 = null,t3=null;
	public static void main(String[] args) {
		
		char[] a1 = "123".toCharArray();
		char[] a2 = "abc".toCharArray();
		char[] a3 = "ABC".toCharArray();
		// 开始
		t1 = new Thread(()->{
			for(char c:a1) {
				LockSupport.park();
				System.out.println(Thread.currentThread().getName()+":"+c);
				LockSupport.unpark(t2);
			}			
		},"t1");
		
		
		t2 = new Thread(()->{
			for(char c:a2) {
				LockSupport.park();
				System.out.println(Thread.currentThread().getName()+":"+c);
				LockSupport.unpark(t3);
			}			
		},"t2");
		
		
		t3 = new Thread(()->{
			for(char c:a3) {
				LockSupport.park();
				System.out.println(Thread.currentThread().getName()+":"+c);
				LockSupport.unpark(t1);
			}			
		},"t3");
		
		
		t1.start();
		t2.start();
		t3.start();
		
		LockSupport.unpark(t1);
	}
}

```

###### reetrantlock+condition来打拼

```java
package com.lcz.thread;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.LockSupport;
import java.util.concurrent.locks.ReentrantLock;

public class Test13 {
	// 三个线程
	static Thread t1 = null,t2 = null,t3=null;
	public static void main(String[] args) {
		
		char[] a1 = "123".toCharArray();
		char[] a2 = "abc".toCharArray();
		char[] a3 = "ABC".toCharArray();
		
		ReentrantLock lock = new ReentrantLock();
		Condition condition = lock.newCondition();
		
		// 开始
		t1 = new Thread(()->{
			try {
				lock.lock();
				for(char c:a1) {
					System.out.println(Thread.currentThread().getName()+":"+c);
					condition.signal();
					condition.await();
				}	
				condition.signal();
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		},"t1");
		
		
		t2 = new Thread(()->{
			try {
				lock.lock();
				for(char c:a2) {
					System.out.println(Thread.currentThread().getName()+":"+c);
					condition.signal();
					condition.await();
				}	
				condition.signal();
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		},"t2");
		
		
		t3 = new Thread(()->{
			try {
				lock.lock();
				for(char c:a3) {
					System.out.println(Thread.currentThread().getName()+":"+c);
					condition.signal();
					condition.await();
				}	
				condition.signal();
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				lock.unlock();
			}
		},"t3");
		
		
		t1.start();
		t2.start();
		t3.start();
		
	}
}

```

###### 乐观锁来实现（Enum来实现）

```java
package com.lcz.thread;
// 枚举类
enum MyThreadRun{
	t1,t2,t3
}
public class Test14 {
	static volatile MyThreadRun r = MyThreadRun.t1;
	public static void main(String[] args) {
		char[] a1 = "123".toCharArray();
		char[] a2 = "abc".toCharArray();
		char[] a3 = "ABC".toCharArray();
		
		Thread t1 = new Thread(()->{
			//打印
			for(char c:a1) {
				while(r!=MyThreadRun.t1) {
					
				}
				System.out.print(Thread.currentThread().getName()+":"+c);
				r = MyThreadRun.t2;
			}
		},"t1");
		
		Thread t2 = new Thread(()->{
			//打印
			for(char c:a2) {
				while(r!=MyThreadRun.t2) {
					
				}
				System.out.print(Thread.currentThread().getName()+":"+c);
				r = MyThreadRun.t3;
			}
		},"t2");
		
		
		Thread t3 = new Thread(()->{
			//打印
			for(char c:a3) {
				while(r!=MyThreadRun.t3) {
					
				}
				System.out.print(Thread.currentThread().getName()+":"+c);
				r = MyThreadRun.t1;
			}
		},"t3");
		
		
		t1.start();
		t2.start();
		t3.start();
		
	}
}

```



> 总结：
>
> 多线程之间的交互：首先需要有个flag来指导次序；其次用synchronized显式锁或者reentrantlock隐式锁；然后用wait/notify或者condition.notify和signal函数；
>
> 或者直接用LOCKSUPPORT的park和unpark的方法；
>
> 或者用乐观锁的实现方式。

## 读取文件-多线程下载

### [代码题]-Java给一个文件，输出其中每个单词输出的频次（TreeMap）

```java
package com.lcz.thread;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * java给定一个文件，输出其中每个单词输出的频次
 * 统计一个英文文档中各个单词出现的频率（由大到小排序），单词之间用”逗号，句号，空格隔开”,将结果输出至控制台。
 * @author LvChaoZhang
 *思路：
1、利用输入流实现对文件内容的输入；
2、将文件内容存入StringBuffer中；
3、利用String的split()方法将字符串分隔，并将其存入数组中；
4、遍历数组将其存入Map<String, Integer>中。其中，key中存放单词，value中存放key中单词出现的次数。
5、利用Collections的sort()方法对TreeMap的value进行排序(很多时候TreeMap是根据key的值来进行排序的，但是有时我们需要根据TreeMap的value来进行排序。对value排序我们就需要借助于Collections的sort(List<T> list, Comparator<? super T> c)方法，该方法根据指定比较器产生的顺序对指定列表进行排序。TreeMap默认是升序的，如果我们需要改变排序方式，则需要使用比较器：Comparator。Comparator可以对集合对象或者数组进行排序的比较器接口，实现该接口的public compare(T o1,T o2)方法即可实现排序，该方法主要是根据第一个参数o1,小于、等于或者大于o2分别返回负整数、0或者正整数。但是有一个前提条件，那就是所有的元素都必须能够根据所提供的比较器来进行比较。)

 */
public class Test24 {
	public static void main(String[] args) {
		// 文件
		File file = new File("D:\\dict.txt");
		// 读取文件
		try {
			BufferedReader br = new BufferedReader(new FileReader(file));
			// StringBuilder来存储
			StringBuilder sb = new StringBuilder();
			//按行读取
			String s;
			while((s=br.readLine())!=null) {
				sb.append(s);
			}
			// 开始处理 不区分大小写
			String str = sb.toString().toLowerCase();
			// 对字符进行分割
			String[] dict = str.split("[,.\\s+]");
			// hashmap统计频率
			Map<String,Integer> myTreeMap = new TreeMap<>();
			// 开始存放
			for(int i=0;i<dict.length;i++) {
				// 开始存放
				myTreeMap.put(dict[i], myTreeMap.getOrDefault(dict[i], 0)+1);
			}
			
			// 遍历输出结果
            System.out.println("直接遍历Map输出（无序）：");
			for(Map.Entry<String, Integer> entry:myTreeMap.entrySet()) {
				// 输出结果
				System.out.println(entry.getKey()+":"+entry.getValue());
			}
			// 对出现频率进行从排序输出
            System.out.println("对频率从大到小排序，然后输出：");
			// 框map.entrySet转为list
			List<Map.Entry<String,Integer>> list = new ArrayList<Map.Entry<String, Integer>>(myTreeMap.entrySet()); 
			// 排序
			Collections.sort(list,(entry1,entry2)->(entry2.getValue()-entry1.getValue()));
			for(Map.Entry<String, Integer> map : list) {
                System.out.println(map.getKey() + ":" + map.getValue());
            }
			

			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

```

### 【代码题】- 文件的拷贝（多线程）

**（1）单线程的文件拷贝**

FileInputStream;

BufferedInputStream;

FileReader;

BufferedReader;

FileChannel(NIO的方式)

```java
package com.lcz.test;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.WritableByteChannel;

public class FileCopy {
	public static void transfer(File source,File target) {
		FileInputStream in = null;
		FileOutputStream out = null;
		if(!source.exists() || !source.isFile()) {
			throw new IllegalArgumentException("file not exists!");
		}
		if(target.exists()) {
			target.delete();
		}
		try {
			target.createNewFile();
			in = new FileInputStream(source);
			out = new FileOutputStream(target);
			FileChannel inChannel = in.getChannel();
			WritableByteChannel outChannel = out.getChannel();
			inChannel.transferTo(0, inChannel.size(), outChannel);
			inChannel.close();
			outChannel.close();
			in.close();
			out.close();
		}catch(FileNotFoundException e) {
			e.printStackTrace();
		}catch(IOException e) {
			e.printStackTrace();
		}
		
	}
	public static void main(String[] args) throws IOException {
		/**
		 * FileChannel方法
		 */
		long start = System.currentTimeMillis();
		String source = "D:\\\\software\\\\eclipse\\\\eclipse-java-2019-03-R-win32-x86_64\\\\workplace\\\\InterView_Autumn\\\\src\\\\com\\\\lcz\\\\test\\\\2018.rar";
		String target = "D:\\\\software\\\\eclipse\\\\eclipse-java-2019-03-R-win32-x86_64\\\\workplace\\\\InterView_Autumn\\\\src\\\\com\\\\lcz\\\\test\\\\2019.rar";
		transfer(new File(source), new File(target));
		
		long end = System.currentTimeMillis();
		System.out.println("用时："+(end-start)+"毫秒");
	}
}

```

**多线程的方式**

```java
package com.lcz.test;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.nio.channels.FileLock;
import java.nio.channels.WritableByteChannel;
class CopyFileThread extends Thread{
	private String srcPath;//源文件地址
	private String dstPath;//目标源文件地址
	private long start,end;//起始位置，结束位置
	public CopyFileThread(String srcPath,String dstPath,long start,long end) {
		this.srcPath = srcPath;
		this.dstPath = dstPath;
		this.start = start;
		this.end = end;
	}
	@Override
	public void run() {
		try {
			long beginTime = System.currentTimeMillis();
			System.out.println("开始时间: " + beginTime);
			//创建只读的随机访问文件
			RandomAccessFile in = new RandomAccessFile(srcPath, "r");
			//创建可读可写的随机访问文件
			RandomAccessFile out = new RandomAccessFile(dstPath, "rw");
			// 将输入跳转到指定位置
			in.seek(start);
			out.seek(start);
			//文件输入通道
			FileChannel inChannel = in.getChannel();
			FileChannel outChannel = out.getChannel();
			//锁住需要操作的区域
			FileLock lock = outChannel.lock(start,(end-start),false);
			// 将字节从此通道传输到给定的可写入字节的输出通道
			inChannel.transferTo(start, (end-start), outChannel);
			//释放锁
			lock.release();
			out.close();
			in.close();
			long endTime = System.currentTimeMillis();
			System.out.println(Thread.currentThread().getName()+"结束时间："+endTime+"-"+"共用时"+(endTime-beginTime));
		}catch(Exception e) {
			e.printStackTrace();
		}
	}
}
public class FileCopy2 {
	
	
	
	public static void main(String[] args) throws IOException {
		/**
		 * FileChannel方法
		 */
		long start = System.currentTimeMillis();
		String srcPath = "D:\\\\software\\\\eclipse\\\\eclipse-java-2019-03-R-win32-x86_64\\\\workplace\\\\InterView_Autumn\\\\src\\\\com\\\\lcz\\\\test\\\\2018.rar";
		String dstPath = "D:\\\\software\\\\eclipse\\\\eclipse-java-2019-03-R-win32-x86_64\\\\workplace\\\\InterView_Autumn\\\\src\\\\com\\\\lcz\\\\test\\\\2019.rar";
		File source = new File(srcPath);
		long len = source.length();//文件总长度
		//分块数也是线程数0
		int blockCount = 8;
		long oneNum = len/blockCount;
		for(int i=0;i<blockCount-1;i++) {
			new CopyFileThread(srcPath, dstPath, oneNum*i, oneNum*(i+1)).start();
		}
		//文件长度不能整除的部分放到最后一段处理
		new CopyFileThread(srcPath, dstPath, oneNum*(blockCount-1), len).start();

		long end = System.currentTimeMillis();
		System.out.println("用时："+(end-start)+"毫秒");
	}
}

```

### 3.统计不同号码个数

已知有一些文件，文件内包含一些电话号码，每个号码为8位数字，统计全部文件不同号码的个数。

备注：文件很多，总量很大，不足以一次全部读入到内存进行计算。

```java
package com.lcz.tencent_01;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class FileTest {
	// 获取数据
	public static int getData() throws IOException {
		// 使用arrayList来存储每行读取到的字符串
		int[] arr = new int[1000000000];
		// 读取一个目录下的文件
		File file = new File("D:\\000\\Leetcode刷题\\leetcode\\src\\com\\lcz\\tencent_01\\data");
		// 获取该目录下的所有文件
		File[] fileArray = file.listFiles();
		for(int i=0;i<fileArray.length;i++) {
			File filename = fileArray[i];
			// 读取该文件
			BufferedReader br = new BufferedReader(new FileReader(filename));
			// 按行获取字符串
			String str;
			while((str=br.readLine())!=null) {
				int number = Integer.valueOf(str);
				arr[number] = 1;
			}
		}
		// 最后对其进行统计
		int count = 0;
		for(int i=10000000;i<=99999999;i++) {
			if(arr[i]==1) {
				count++;
			}
		}
		return count;
	}
	
	public static void main(String[] args) {
		try {
			int number = getData();
			System.out.println(number);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

```

## 有序数组的合并

### A,B 两个排序数组，原地合并数组（有序数组合并）

- AB两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组，原地合并数组。（A当中穿插一些无效数字怎么处理？）

思路：因为要原地合并数组，如果从前往后遍历，数组原来的值会被覆盖，所以只能从后往前遍历，将值从后往前存入。存入时比较当前两个指针指向的数字大小，选较大的存入，然后往前移动指针。   

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int i = m - 1,j = n - 1,k = m + n - 1;
        while(j >= 0){
            if(i < 0 || B[j] >= A[i]){
                A[k--] = B[j--];
            }else {
                A[k--] = A[i--];
            }
        }
    }
}
```

### [Leetcode26 删除有序中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 新数组中的索引是从0开始的
        int left = 0;
        // 旧数组中的索引是从1开始的
        int right = 1;
        // 就数组遍历
        while(right<nums.length){
            // 相等
            if(nums[right]==nums[left]){
                right++;
            }else{
                // 不相等了
                nums[++left] = nums[right++];
            }
        }
        // 返回长度
        return left+1;
    }
    
    
}
```

### Leetcode80 删除有序数组中的重复项II

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

说明：

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

```java
class Solution {
    public int removeDuplicates(int[] nums) {
            int low = 0;
	    	int fast = 1;
	    	int fre = 0;
	    	while(fast<nums.length) {
	    		// 老数组
	    		if(nums[fast]==nums[low]) {
	    			fre++;
	    		}else {
	    			fre = 0;
	    		}
	    		
	    		// 新数组
	    		if(fre<2) {
	    			low++;
	    			nums[low] = nums[fast];
	    		}
	    		
	    		// 接着走
	    		fast++;
	    	}
	    	return low+1;
    }
}
```





### 桶排序-利用桶排序排序后最大差值问题

**利用桶排序排序后最大差值问题**

> 题目：给定个数组，求如果排序之后，相邻两数的最大差值,要求时间复杂度O(N),且要求不能用非基于比较的排序。

给出三个桶，放最大值 最小值 是否有值 平均分配桶

```java
package com.lcz.leetcode;
import java.util.*;

public class MaxGap {
	// 求最大差值 用桶排序
	public static int maxGap(int[] nums) {
		if(nums==null || nums.length<2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for(int i=0;i<len;i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if(min==max) {
			return 0;
		}
		// 放入桶中
		boolean[] hasNum = new boolean[len+1];
		int[] maxs = new int[len+1];
		int[] mins = new int[len+1];
		int bid = 0;
		for(int i=0;i<len;i++) {
			bid = bucket(nums[i], len, min, max);
			mins[bid] = hasNum[bid]?Math.min(mins[bid], nums[i]):nums[i];
			maxs[bid] = hasNum[bid]?Math.max(maxs[bid], nums[i]):nums[i];
			hasNum[bid] =  true;
		}
		// 得到结果
		int res = 0;
		int lastMax = maxs[0];
		for(int i=1;i<=len;i++) {
			if(hasNum[i]) {
				res = Math.max(res, mins[i]-lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}
	
	// 确定哪个桶
	public static int bucket(long num,long len,long min,long max) {
		return (int)((num-min)*len / (max-min));
	}
	
	
	// 标准方法
	public static int comparator(int[] nums) {
		if(nums==null||nums.length<2) {
			return 0;
		}
		// 对其排序
		Arrays.sort(nums);
		// 求最大差值
		int gap = Integer.MIN_VALUE;
		for(int i=1;i<nums.length;i++) {
			gap = Math.max(nums[i]-nums[i-1], gap);
		}
		return gap;
	}
	// 主函数
	public static void main(String[] args) {
		int[] arr = new int[] {1,3,2,6,5,7,8,9,0};
//		System.out.println(comparator(arr));
		System.out.println(maxGap(arr));
	}
}

```

### 

## 设计模式

### 1.创建型-写一个单例模式(高频)

**饿汉式**

```java
public class Singleton {
	// 初始化方法
	private Singleton() {
		
	}
	private static Singleton singleton = new Singleton();
	
	public static Singleton get() {
		return singleton;
	}
}
```

**懒汉式**

```java
public class Singleton {
	// 初始化方法
	private Singleton() {
		
	}
	private static Singleton singleton = null;
	
	public static Singleton get() {
		if(singleton==null) {
			singleton = new Singleton();
		}
		return singleton;
	}
}
```

**双重校验锁**

```java
public class Singleton {
	// 初始化方法
	private Singleton() {
		
	}
	private static volatile Singleton singleton = null;
	
	public static Singleton get() {
		if(singleton==null) {
			synchronized (Singleton.class) {
				if(singleton==null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}
}

```

**a.饿汉式**

```java
package singleton;

/**
 * 描述：     饿汉式（静态常量）（可用）
 */
public class Singleton1 {
    private final static Singleton1 INSTANCE = new Singleton1();
    private Singleton1() {

    }
    public static Singleton1 getInstance() {
        return INSTANCE;
    }

}

```



**b.懒汉式**

```java
package singleton;

/**
 * 描述：     懒汉式（线程不安全）
 */
public class Singleton3 {

    private static Singleton3 instance;

    private Singleton3() {

    }

    public static Singleton3 getInstance() {
        if (instance == null) {
            instance = new Singleton3();
        }
        return instance;
    }
}

```



**双重校验锁**（面试）

```java
package singleton;

/**
 * 描述：     双重检查（推荐面试使用）
 */
public class Singleton6 {

    private volatile static Singleton6 instance;

    private Singleton6() {

    }

    public static Singleton6 getInstance() {
        if (instance == null) {
            synchronized (Singleton6.class) {
                if (instance == null) {
                    instance = new Singleton6();
                }
            }
        }
        return instance;
    }
}

```

- 双重锁才线程安全；
- 如果单重锁，就可能有两次实例创建；
- volatile来修饰，保证可见性以及防止重排序，主要是new 这个步骤是三个步骤；



**d.静态内部类(可用)**

```java
package singleton;

/**
 * 描述：     静态内部类方式，可用
 */
public class Singleton7 {

    private Singleton7() {
    }

    private static class SingletonInstance {

        private static final Singleton7 INSTANCE = new Singleton7();
    }

    public static Singleton7 getInstance() {
        return SingletonInstance.INSTANCE;
    }
}

```



**e.枚举类（生产实践）**

```java
package singleton;

/**
 * 描述：     枚举单例
 */
public enum Singleton8 {
    INSTANCE;

    public void whatever() {

    }
}
// 调用
Singleton8.INSTANCE;

```



**不同 写法对比**

饿汉：简单，但是没有懒加载；

懒汉：有线程安全问题；

静态内部类：可用

双重校验：面试

枚举类：最好



**用哪种单例的实现方案最好**

枚举类最好。

Joshua Block大神在《Effective Java》中明确表达过观点：使用枚举类实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成功实现Singleton的最佳方法。

- 写法简单；
- 枚举类，线程安全有保证（反编译可以看到其final，各个实例static）；
- 避免反序列化破坏单例；

**单例模式项目中的使用**

用过synchronized关键字，是在单例模式中使用的，就是后台训练的那个模型，因为我们有重新训练的模型，每个用户都可以发起后台训练，但是同一时间一个模型没训练完成，别的不可以进行训练的操作。

### 2.行为型-Java实现发布者-订阅者模式(接口实现)

- 发布者接口
  - 存储订阅者
  - 删除订阅者
  - 发布消息
    - 调用订阅者中的事件处理
- 订阅者接口
  - 事件

**订阅者接口**

```java
package com.lcz.design_mode;
// 订阅者接口
public interface ISubsriber {
	// 订阅者得到这个消息各自的处理
	void todoTomorrow(String msg);
}

```

**发布者接口**

```java
package com.lcz.design_mode;
// 发布者接口
public interface IWeather {
	// 添加订阅者
	void addSubscriber(ISubsriber subsriber);
	// 删除订阅者
	void delSubscriber(ISubsriber subsriber);
	// 发布消息的接口
	void publishInfo(String msg);
}

```

**发布者的实现**

```java
package com.lcz.design_mode;

import java.util.ArrayList;
import java.util.List;

import com.sun.istack.internal.logging.Logger;

// 实现发布者
public class WeatherServer implements IWeather {
	// 日志记录
	private static final Logger logger = Logger.getLogger(WeatherServer.class);
	// 保存发布者
	private List<ISubsriber> subsribers = new ArrayList<ISubsriber>();
	// 保存所有的订阅者
	@Override
	public void addSubscriber(ISubsriber subsriber) {
		// TODO Auto-generated method stub
		subsribers.add(subsriber);
		logger.info("a new subscriber is joining");
	}

	// 用来删除发布者
	@Override
	public void delSubscriber(ISubsriber subsriber) {
		// TODO Auto-generated method stub
		subsribers.remove(subsriber);
		logger.info("a subscriber is leaving");
	}
	
	// 用来发布消息
	@Override
	public void publishInfo(String msg) {
		// TODO Auto-generated method stub
		for(ISubsriber subsriber:subsribers) {
			subsriber.todoTomorrow(msg);
		}
		logger.info(String.format("public a msg: %s", msg));
	}

}

```

**订阅者的实现**

```java
package com.lcz.design_mode;

import com.sun.istack.internal.logging.Logger;

public class Worker implements ISubsriber{
	// 日志
	private static final Logger logger = Logger.getLogger(Worker.class);
	@Override
	public void todoTomorrow(String msg) {
		// TODO Auto-generated method stub
		if("rain".equals(msg)) {
			logger.info("worker: a satified day");
		}else if("sunny".equals(msg)) {
			logger.info("worker: a terrible day");
		}else {
			logger.info("worker: spam messages");
		}
		
	}

}

```

**测试**

```java
package com.lcz.design_mode;

public class Test {
	public static void main(String[] args) {
		// 创建订阅者
		Worker worker = new Worker();
		
		WeatherServer weatherServer = new WeatherServer();
		
		weatherServer.addSubscriber(worker);
		weatherServer.publishInfo("rain");
	}
}

```

**那么观察者模式和发布订阅者模式的最大区别是什么呢？**

观察者模式和发布订阅模式最大的区别就是**发布订阅模式有个事件调度中心。**

![image-20210506151534964](E:/笔记/面试高频/imgs/160.png)

从图中可以看出，观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。

### 3.观察者模式



### 3.工厂模式





## 设计类-循环队列-约瑟夫-栈结构设计

### 0.设计一个循环队列(重点数组题)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。


示例：

MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4

> 通过数组设置一个循环队列，设置一个最大容量，设置此时的size，设置一个headIndex，剩下的通过%就可以计算而来。

```java
class MyCircularQueue {
    int[] arr;
    int headIndex;
    int count;
    int capactity;
    public MyCircularQueue(int k) {
        arr = new int[k];
        headIndex = 0;
        count = 0;
        capactity = k;
    }
    // 入队列
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        int index = (headIndex+count)%capactity;
        arr[index] = value;
        // 增加元素
        count++;
        return true;
    }
    // 出队列
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        // 就移动headIndex即可 
        headIndex = headIndex + 1;
        count--;
        return true;
    }
    // 从队首获取元素
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        int index = headIndex;
        return arr[index];
    }
    // 从队尾获取元素
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        // 获取元素
        int  index = (headIndex+count-1)%capactity;
        return arr[index];
    }
    
    public boolean isEmpty() {
        return count==0;
    }
    
    public boolean isFull() {
        return count==capactity;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```

### 1.实现一个计数器

实现一种计数器，记录最近 N个数字，
包含push、getAverage方法（输出当前计数器内平均值），o1复杂度。
实现另一种计数器，可以对最近N个数字做排序。

```java
package com.lcz.tencent;
/**
 * 实现一种计数器，记录最近 N个数字，
 * 包含push、getAverage方法（输出当前计数器内平均值），o1复杂度。
 
   实现另一种计数器，可以对最近N个数字做排序。
 * @author LvChaoZhang
 *
 */
public class Digit {
	int[] s_data;
	double s_avg;
	int n;
	int size;
	// 开始的下标索引
	int head = 0;
	public Digit() {
		
	}
	
	public Digit(int n) {
		this.n = n;
		this.size = 0;
		s_data = new int[n];
		s_avg = 0;
	}
	
	// 插入方法
	public void push(int x) {
		if(size==n) {
			int temp = s_data[head];
			s_data[head]=x;
			head++;
			// 更新
			s_avg = ((s_avg*size-temp)+x)/size;
			// 如果head到最后了
			if(head==size) {
				head = 0;
			}
			
		}else {
			// 容器未满的情况
			s_data[size] = x;
			size++;
			if(size==1) {
				// 之前没有
				s_avg = x;
			}else {
				s_avg = (s_avg*(size-1) + x)/(size);
			}
		}
	}
	
	// 获取当前计数器内平均值
	public double getAverage() {
		return s_avg;
	}
	
	// 打印方法
	public void print() {
		for(int i=0;i<size;i++) {
			System.out.print(s_data[i] + " ");
		}
		System.out.print("平均数为："+s_avg);
		System.out.println();
	}
}


```



```java
package com.lcz.tencent;

public class Other_Digit extends Digit{
	public Other_Digit(int n) {
		super(n);
	}
	// 对N个数字进行排序
	public void sort() {
		// 插入排序 
		for(int i=1;i<size;i++) {
			for(int j=i-1;j>=0&&s_data[j]>s_data[j+1];j--) {
				// 交换
				swap(s_data,j,j+1);
			}
		}
	}
	
	public void swap(int[] nums,int i,int j) {
		int temp = nums[i];
		nums[i]  = nums[j];
		nums[j]  = temp;
	}
}


```

```java
package com.lcz.tencent;

public class Test {
	public static void main(String[] args) {
		// 3 2 1
		Digit digit = new Digit(3);
		digit.push(3);
		digit.push(2);
		digit.push(1);
		// 打印一下
		digit.print();
		System.out.println(digit.s_avg);

		
		// 再往里面放一个4
		digit.push(4);
		digit.push(5);
		digit.push(6);
		digit.print();


		
		// 排序
		Other_Digit digit_2 = new Other_Digit(3);
		digit_2.push(3);
		digit_2.push(2);
		digit_2.push(1);
		digit_2.sort();
		digit_2.print();
	}
}


```

### 2.圆桌报数

已知n个人(以编号1,2,3,...n分别表示)，围坐在一张圆桌周围，从编号1的开始报数，数到k的那个人出列，它的下一个又从出列的后面第一个人开始报数，数到k的那个人出列，依次重复下去，直到圆桌的人全部出列，求出列顺序。

输入：n和k

输出：出列顺序

~~~java
### 2.约瑟夫环的书写

约瑟夫环是给定 n个人，从1开始数，数到m时，m将被去掉，下一个数是重新从1开始数，直到剩下一个即可。

```java
public class Code_01 {
	// 约瑟夫环 传入n和m
	public static int ysf_func(int n,int m) {
		// 用List来存储
		LinkedList<Integer> list= new LinkedList<>();
		for(int i=0;i<n;i++) {
			// 添加人的编码1-n
			list.add(i+1);
		}
		// 第一个索引是
		int index = 0;
		while(list.size()>1) {
			// 开始数数
			for(int i=1;i<m;i++) {
				index = (index+1)%list.size();
			}
			list.remove(index);
		}
		// 最后剩了一个
		return list.get(0);
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			int n = sc.nextInt();
			int m = sc.nextInt();
			// 开始处理
			System.out.println(ysf_func(n, m));
		}
	}
}
~~~

### 4.设计简单的栈数据结构

请编写一个类来实现栈这样一种数据结构，实现如下能力：

- 压入数据；
- 弹出数据；
- 获取数据结构的长度

```java
package com.lcz.tencent_01;

public class MyStack {
	static final int default_capacity = 16;
	int[] data;
	int head;
	int size;
	
	/**
	 * 初始化
	 */
	public MyStack() {
		data = new int[default_capacity];
		head = 0;
		size = 0;
	}
	public MyStack(int n) {
		data = new int[n];
		head = 0;
		size = 0;
	}
	/**
	 * 入栈
	 * @param x
	 */
	public void push(int x) {
		// 判断是否栈满了
		if(isFull()) {
			//待处理
			resize();
		}
		data[head+size] = x;
		size++;
	}
	/**
	 * 出栈
	 * @return
	 */
	public int pop() {
		if(isEmpty()) {
			return -1;
		}
		int x = data[head+size-1];
		size--;
		return x;
	}
	/**
	 * 是否为空
	 * @return
	 */
	public boolean isEmpty() {
		return size==0;
	}
	/**
	 * 是否满了
	 */
	public boolean isFull() {
		return size==data.length;
	}
	/**
	 * 栈满了进行扩容
	 */
	public void resize() {
		// 扩容两倍
		int size = data.length>>1;
		int[] new_data = new int[size];
		// 开始复制
		for(int i=0;i<data.length;i++) {
			new_data[i] = data[i];
		}
		// 重新赋值
		data = new_data;
	}
}

```





## 限流算法

### 【限流算法之令牌桶算法 实现】

实现关键点：

初始化固定数量的令牌放入令牌桶中初始化和开启一个定时的任务，定时往令牌桶添加令牌提供一个获取令牌的方法，获取一个令牌，令牌桶中减一，如果令牌桶中为空，返回失败还是说干就干，以下就是简单的实现TokenLimiter，

![img](E:/笔记/面试高频/imgs/721.png)







## 二叉树

### [Leetcoee652寻找重复的子树](https://leetcode-cn.com/problems/find-duplicate-subtrees/)

给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意一棵的根结点即可。

两棵树重复是指它们具有相同的结构以及相同的结点值。

示例 1：

        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
下面是两个重复的子树：

      2
     /
    4
和

    4
因此，你需要以列表的形式返回上述重复子树的根结点。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    Map<String,Integer> count = new HashMap<>();
    List<TreeNode> res = new ArrayList<>();
    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        dfs(root);
        return res;
    }

    public String dfs(TreeNode node){
        if(node==null){
            return "#";
        }
        String serial = node.val + ","+dfs(node.left)+","+dfs(node.right);
        count.put(serial,count.getOrDefault(serial,0)+1);
        if(count.get(serial)==2){
            res.add(node);
        }
        return serial;
    }


}
```

### [Leetcode1530 好叶子节点对的数量](https://leetcode-cn.com/problems/number-of-good-leaf-nodes-pairs/)

给你二叉树的根节点 root 和一个整数 distance 。

如果二叉树中两个 叶 节点之间的 最短路径长度 小于或者等于 distance ，那它们就可以构成一组 好叶子节点对 。

返回树中 好叶子节点对的数量 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/26/e1.jpg)

输入：root = [1,2,3,null,4], distance = 3
输出：1
解释：树的叶节点是 3 和 4 ，它们之间的最短路径的长度是 3 。这是唯一的好叶子节点对。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public int countPairs(TreeNode root, int distance) {
        if (root == null) return 0;
        List<Integer> lefts = new LinkedList<>();
        countDepth(root.left, 0, lefts);
        List<Integer> rights = new LinkedList<>();
        countDepth(root.right, 0, rights);
        
        int res = 0;
        for (Integer l : lefts)
            for (Integer r : rights)
                if (l + r + 2 <= distance)
                    res++;
        
        res += countPairs(root.left, distance);
        res += countPairs(root.right, distance);
        return res;
    }
    
    void countDepth(TreeNode node, int depth, List<Integer> list) {
        if (node == null) return;
        if (node.left == null && node.right == null) {
            list.add(depth);
            return;
        }
        countDepth(node.left, depth + 1, list);
        countDepth(node.right, depth + 1, list);
    }
}
```

### 剑指Offer-二叉树的下一个节点

给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。

注意，树中的结点不仅包含左右子结点，而且包含指向**父结点的指针**。

![image-20210715234411956](E:/笔记/面试高频/imgs/474.png)

节点(设为x)中序遍历的下一个节点有以下可能：

- 若x有右子树。则x的下一个节点为x右子树最左侧节点。如，2的下一个节点为8。
- 若x没有右子树，又分为2种情况。
  - 若x是父节点的左孩子。则x的父节点就是x的下一个节点。如，7的下一个节点是4。
  - 若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，则该节点的父节点就是x的下一个节点。如，9的下一个节点是1。

```java
/*
struct TreeLinkNode {
    int val;
    struct TreeLinkNode *left;
    struct TreeLinkNode *right;
    struct TreeLinkNode *next; //父节点
    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {
        
    }
};
*/
class Solution {
public:
    TreeLinkNode* GetNext(TreeLinkNode* pNode)
    {
        if(pNode->right) { //如果有右子树，则找右子树的最左节点
            TreeLinkNode *p = pNode->right;
            while(p->left) p = p->left;
            return p;
        }
        TreeLinkNode *p = pNode;
        while(p->next) { //没右子树，则找第一个当前节点是父节点左孩子的节点
            if(p->next->left == p) return p->next;
            p = p->next;
        }
        return nullptr; //退到了根节点仍没找到，则返回null
    }
};
```

### 17.树的直径

**描述**

给定一棵树，求出这棵树的直径，即树上最远两点的距离。

包含n个结点，n-1条边的连通图称为树。

示例1的树如下图所示。其中4到5之间的路径最长，是树的直径，距离为5+2+4=11

![](https://uploadfiles.nowcoder.com/images/20201202/999991351_1606896095422/54D43FCA3EABC9D96189FA8EA98A510C)

**示例1**

输入：

```
6,[[0,1],[1,5],[1,2],[2,3],[2,4]],[3,4,2,1,5]
```

复制

返回值：

```
11
```

```java
import java.util.*;

/*
 * public class Interval {
 *   int start;
 *   int end;
 * }
 */

public class Solution {
    /**
     * 树的直径
     * @param n int整型 树的节点个数
     * @param Tree_edge Interval类一维数组 树的边
     * @param Edge_value int整型一维数组 边的权值
     * @return int整型
     */
    int res = 0;
    public int solve (int n, Interval[] Tree_edge, int[] Edge_value) {
        // write code here
        ArrayList<int[]>[] map = new ArrayList[n];
        for(int i = 0; i<n; i++){
            map[i] = new ArrayList();
        }
        for(int i = 0; i<Tree_edge.length; i++){
            map[Tree_edge[i].start].add(new int[]{Tree_edge[i].end,Edge_value[i]});
            map[Tree_edge[i].end].add(new int[]{Tree_edge[i].start,Edge_value[i]});
        }
        dfs(map, 0, new boolean[n]);
        return res;
    }
    private int dfs(ArrayList<int[]>[] map, int index, boolean[] visit){
        visit[index] = true;
        ArrayList<int[]> list = map[index];
        int weight1 = 0, weight2 = 0;
        for(int[] i : list){
            int child = i[0];
            int weight = i[1];
            if(visit[child]) continue;
            int num = weight + dfs(map, child, visit);
            
            if(num>weight1){
                weight2 = weight1;
                weight1 = num;
            } else if(num>weight2){
                weight2 = num;
            }
            if(weight1+weight2>res) res = weight1+weight2;
        }
        return weight1;
    }
}
```

### [NC60 判断一棵二叉树是否为搜索二叉树和完美二叉树](https://www.nowcoder.com/practice/f31fc6d3caf24e7f8b4deb5cd9b5fa97?tpId=188&&tqId=38598&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一棵二叉树，已知其中的节点没有重复值，请判断该二叉树是否为搜索二叉树和完全二叉树。

**示例1**

输入：

```
{2,1,3}
```

复制

返回值：

```
[true,true]
```

复制

**备注：**

```
n \leq 500000n≤500000
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 the root
     * @return bool布尔型一维数组
     */
    public boolean[] judgeIt (TreeNode root) {
        // write code here
        // 判断是否是二叉搜索树
        boolean flag1 = isBinarySearchTree(root);
        boolean flag2 = isCompleteTree(root);
        return new boolean[]{flag1,flag2};
    }
    /**
    判断是否是二叉搜索树
    */
    long pre = Long.MIN_VALUE;
    public boolean isBinarySearchTree(TreeNode root){
        if(root==null){
            return true;
        }
        //左根右
        boolean left = isBinarySearchTree(root.left);
        if(pre!=Long.MIN_VALUE&&pre>=root.val){
            return false;
        }
        pre = root.val;
        boolean right = isBinarySearchTree(root.right);
        return left&&right;
    }
    /**
    判断是否为完全二叉树
    */
    public boolean isCompleteTree(TreeNode root){
        if(root==null){
            return true;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean flag = false;
        while(!queue.isEmpty()){
            root = queue.poll();
            if(flag&&!isLeaf(root)){
                return false;
            }
            
            if(root.left!=null){
                queue.offer(root.left);
            }else if(root.right!=null){
                return false;
            }
            
            if(root.right!=null){
                queue.offer(root.right);
            }else{
                flag = true;
            }
        }
        return true;
    }
    /**
    判断是否为叶子结点
    */
    public boolean isLeaf(TreeNode root){
        return root.left==null&&root.right==null;
    }    
}
```

### Leetcode1008 前序遍历构造二叉树

返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。

(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）

题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。

 

示例：

输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]


![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/03/08/1266.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
     public TreeNode bstFromPreorder(int[] preorder) {
        TreeNode root = null;
        for (int i = 0; i < preorder.length; i++) {
            root=add(root, preorder[i]);
        }
        return root;
    }

    public TreeNode add(TreeNode root, int num) {
        if (root == null) {
            return new TreeNode(num);
        }
        if (root.val > num) {
            root.left=add(root.left, num);
        } else {
            root.right = add(root.right, num);
        }
        return root;
    }
}
```

### Leetcode1325 删除给定值的叶子结点

给你一棵以 root 为根的二叉树和一个整数 target ，请你删除所有值为 target 的 叶子节点 。

注意，一旦删除值为 target 的叶子节点，它的父节点就可能变成叶子节点；如果新叶子节点的值恰好也是 target ，那么这个节点也应该被删除。

也就是说，你需要重复此过程直到不能继续删除。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/16/sample_1_1684.png)

输入：root = [1,2,3,2,null,2,4], target = 2
输出：[1,null,3,null,4]
解释：
上面左边的图中，绿色节点为叶子节点，且它们的值与 target 相同（同为 2 ），它们会被删除，得到中间的图。
有一个新的节点变成了叶子节点且它的值与 target 相同，所以将再次进行删除，从而得到最右边的图。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode removeLeafNodes(TreeNode root, int target) {
        if (root == null) return null;
        
        root.left = removeLeafNodes(root.left, target);
        root.right = removeLeafNodes(root.right, target);
        
        if (root.val == target && root.left == null && root.right == null) return null;
        return root;
    }
}
```

### Leetcode894 所有可能的满二叉树

满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。

返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。

答案中每个树的每个结点都必须有 node.val=0。

你可以按任何顺序返回树的最终列表。

 

示例：

输入：7
输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]
解释：


![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/08/24/fivetrees.png)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<TreeNode> allPossibleFBT(int N) {
        List<TreeNode> ans = new ArrayList<>();
        if (N % 2 == 0) {
            return ans;
        }
        if (N == 1) {
            TreeNode head = new TreeNode(0);
            ans.add(head);
            return ans;
        }
        for (int i = 1; i < N; i += 2) {
            List<TreeNode> left = allPossibleFBT(i);
            List<TreeNode> right = allPossibleFBT(N - 1 - i);
            for (TreeNode l : left) {
                for (TreeNode r : right) {
                    TreeNode head = new TreeNode(0);
                    head.left = l;
                    head.right = r;
                    ans.add(head);
                }
            }
        }
        return ans;
    }
}
```

### Leetcode865 具有所有最深节点的最小子树

给定一个根为 root 的二叉树，每个节点的深度是 该节点到根的最短距离 。

如果一个节点在 整个树 的任意节点之间具有最大的深度，则该节点是 最深的 。

一个节点的 子树 是该节点加上它的所有后代的集合。

返回能满足 以该节点为根的子树中包含所有最深的节点 这一条件的具有最大深度的节点。

 

注意：本题与力扣 1123 重复：https://leetcode-cn.com/problems/lowest-common-ancestor-of-deepest-leaves/

 

示例 1：

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png)

输入：root = [3,5,1,6,2,0,8,null,null,7,4]
输出：[2,7,4]
解释：
我们返回值为 2 的节点，在图中用黄色标记。
在图中用蓝色标记的是树的最深的节点。
注意，节点 5、3 和 2 包含树中最深的节点，但节点 2 的子树最小，因此我们返回它。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
       if(root==null){
    	   return null;
       }else {
    	   int ldep=maxDepth(root.left),rdep=maxDepth(root.right);
    	   if(ldep==rdep){
    		   return root;
           }else if(ldep>rdep){
    		   return subtreeWithAllDeepest(root.left);
           }else{
    		   return subtreeWithAllDeepest(root.right);
           }
       }
    }
    
    
    int maxDepth(TreeNode root) {
    	if(root==null)
    		return 0;
    	else
    		return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
```

### Leetcode951 翻转等价二叉树

我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。

只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。

编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。

 

示例：

![Flipped Trees Diagram](https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png)

输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]
输出：true
解释：我们翻转值为 1，3 以及 5 的三个节点。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) return true;
        if (root1 == null || root2 == null) return false;
        if (root1.val == root2.val) {
            return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right)) || (flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));
        }
        return false;
    }
}
```

### Leetcode1339 分裂二叉树的最大乘积

给你一棵二叉树，它的根为 root 。请你删除 1 条边，使二叉树分裂成两棵子树，且它们子树和的乘积尽可能大。

由于答案可能会很大，请你将结果对 10^9 + 7 取模后再返回。

 

示例 1：



输入：root = [1,2,3,4,5,6]
输出：110
解释：删除红色的边，得到 2 棵子树，和分别为 11 和 10 。它们的乘积是 110 （11*10）

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    
    int MOD = (int)1e9 + 7;
    long ans =0, sum = 0;
    public int maxProduct(TreeNode root) {
        sum = sumTree(root);
        nodeStack(root);
        return (int)(ans % MOD);
    }

    public long nodeStack(TreeNode root) {
        if (root == null) return 0;
        long split = root.val + nodeStack(root.left) + nodeStack(root.right);
        ans = Math.max(ans, (sum - split) * split);
        return split;
    }

    private long sumTree(TreeNode node) {
        if (node == null) return 0;
        return node.val + sumTree(node.left) + sumTree(node.right);
    }


}
```

### Leetcode987 二叉树的垂序遍历

给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。

对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。

二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。

返回二叉树的 垂序遍历 序列。

 ![img](https://assets.leetcode.com/uploads/2021/01/29/vtree1.jpg)

示例 1：


输入：root = [3,9,20,null,null,15,7]
输出：[[9],[3,15],[20],[7]]
解释：
列 -1 ：只有结点 9 在此列中。
列  0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列  1 ：只有结点 20 在此列中。
列  2 ：只有结点 7 在此列中。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<List<Integer>> verticalTraversal(TreeNode root) {
        List<int[]> nodes = new ArrayList<int[]>();
        dfs(root, 0, 0, nodes);
        Collections.sort(nodes, new Comparator<int[]>() {
            public int compare(int[] tuple1, int[] tuple2) {
                if (tuple1[0] != tuple2[0]) {
                    return tuple1[0] - tuple2[0];
                } else if (tuple1[1] != tuple2[1]) {
                    return tuple1[1] - tuple2[1];
                } else {
                    return tuple1[2] - tuple2[2];
                }
            }
        });
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        int size = 0;
        int lastcol = Integer.MIN_VALUE;
        for (int[] tuple : nodes) {
            int col = tuple[0], row = tuple[1], value = tuple[2];
            if (col != lastcol) {
                lastcol = col;
                ans.add(new ArrayList<Integer>());
                size++;
            }
            ans.get(size - 1).add(value);
        }
        return ans;
    }

    public void dfs(TreeNode node, int row, int col, List<int[]> nodes) {
        if (node == null) {
            return;
        }
        nodes.add(new int[]{col, row, node.val});
        dfs(node.left, row + 1, col - 1, nodes);
        dfs(node.right, row + 1, col + 1, nodes);
    }
}

```

### Leetcode1026 节点与其祖先的最大差值

给定二叉树的根节点 root，找出存在于 不同 节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。

（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/09/tmp-tree.jpg)

输入：root = [8,3,10,1,6,null,14,null,null,4,7,13]
输出：7
解释： 
我们有大量的节点与其祖先的差值，其中一些如下：
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxAncestorDiff(TreeNode root) {
        int left = maxAncestorDiff(root.left, root.val, root.val);
        int right = maxAncestorDiff(root.right, root.val, root.val);
        return left > right ? left : right;
    }
    
    public int maxAncestorDiff(TreeNode root, int max, int min){
        if(root == null){
            return 0;
        }
        if(root.val > max){
            max = root.val;
        }
        else if(root.val < min){
            min = root.val;
        }
        if(root.left == null && root.right == null){
            return max - min;
        }
        int left = maxAncestorDiff(root.left, max, min);
        int right = maxAncestorDiff(root.right, max, min);
        return left > right ? left : right;
    }
}
```

## 中文数字 阿拉伯数字

中文数字格式：一万三千五百四十一     

​      阿拉伯数字格式：13541     

​      中文数字中要分     单位     和     数字     分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。

```java
public class Solution{
   static char[] cnArr = {'零','一', '二', '三', '四', '五', '六', '七', '八', '九'};
   static char[] chArr = {'十', '百', '千', '万', '亿'};
public static int chineseNumToArabicNum(String chineseNum) {
    int result = 0;
    int temp = 1;//存放一个单位的数字如：十万
    int count = 0;//判断是否有表示单位的文字
    for (int i = 0; i < chineseNum.length(); i++) {
        boolean b = true;//判断是否是单位
        char c = chineseNum.charAt(i);
        for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
            if (c == cnArr[j]) {
                if (count != 0) {//添加下一个单位之前，先把上一个单位值添加到结果中
                    result += temp;
                    temp = 1;
                    count = 0;
                }
                // 下标+1，就是对应的值
                temp = j;
                b = false;
                break;
            }
        }
        if (b) {//单位{'十','百','千','万','亿'}
            for (int j = 0; j < chArr.length; j++) {
                if (c == chArr[j]) {
                    switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                    }
                    count++;
                }
            }
        }
        if (i == chineseNum.length() - 1) {//遍历到最后一个字符
            result += temp;
        }
    }
    return result;
}
}
```

```java
package cn.utstarcom.idpvoice.util;
 
/**
 * 工具类，用于将汉语的数字转换为阿拉伯数字
 * @author utsc1243
 * @date 2019年6月12日
 */
public class ChineseNumToArabicNumUtil {
	static char[] cnArr = new char [] {'一','二','三','四','五','六','七','八','九'};
	static char[] chArr = new char [] {'十','百','千','万','亿'};
	static String allChineseNum = "零一二三四五六七八九十百千万亿";
	
	/**
	 * 将汉字中的数字转换为阿拉伯数字
	 * @param chineseNum
	 * @return
	 */
	public static int chineseNumToArabicNum(String chineseNum) {
        int result = 0;
        int temp = 1;//存放一个单位的数字如：十万
        int count = 0;//判断是否有chArr
        for (int i = 0; i < chineseNum.length(); i++) {
            boolean b = true;//判断是否是chArr
            char c = chineseNum.charAt(i);
            for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
                if (c == cnArr[j]) {
                    if(0 != count){//添加下一个单位之前，先把上一个单位值添加到结果中
                        result += temp;
                        temp = 1;
                        count = 0;
                    }
                    // 下标+1，就是对应的值
                    temp = j + 1;
                    b = false;
                    break;
                }
            }
            if(b){//单位{'十','百','千','万','亿'}
                for (int j = 0; j < chArr.length; j++) {
                    if (c == chArr[j]) {
                        switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                        }
                        count++;
                    }
                }
            }
            if (i == chineseNum.length() - 1) {//遍历到最后一个字符
                result += temp;
            }
        }
        return result;
	}
	
	/**
	 * 将数字转换为中文数字， 这里只写到了万
	 * @param intInput
	 * @return
	 */
	public static String arabicNumToChineseNum(int intInput) {
		String si = String.valueOf(intInput);
		String sd = "";
		if (si.length() == 1) {
			if (intInput == 0) {
				return sd;
			}
			sd += cnArr[intInput - 1];
			return sd;
		} else if (si.length() == 2) {
			if (si.substring(0, 1).equals("1")) {
				sd += "十";
				if (intInput % 10 == 0) {
					return sd;
				}
			}
			else
				sd += (cnArr[intInput / 10 - 1] + "十");
			sd += arabicNumToChineseNum(intInput % 10);
		} else if (si.length() == 3) {
			sd += (cnArr[intInput / 100 - 1] + "百");
			if (String.valueOf(intInput % 100).length() < 2) {
				if (intInput % 100 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 100);
		} else if (si.length() == 4) {
			sd += (cnArr[intInput / 1000 - 1] + "千");
			if (String.valueOf(intInput % 1000).length() < 3) {
				if (intInput % 1000 == 0) {
					return sd;
				}			
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 1000);
		} else if (si.length() == 5) {
			sd += (cnArr[intInput / 10000 - 1] + "万");
			if (String.valueOf(intInput % 10000).length() < 4) {
				if (intInput % 10000 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 10000);
		}
 
		return sd;
	}
 
	/**
	 * 判断传入的字符串是否全是汉字数字
	 * @param chineseStr
	 * @return
	 */
	public static boolean isChineseNum(String chineseStr) {
		char [] ch = chineseStr.toCharArray();
		for (char c : ch) {
			if (!allChineseNum.contains(String.valueOf(c))) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 判断数字字符串是否是整数字符串
	 * @param str
	 * @return
	 */
	public static boolean isNum(String str) {
		String reg = "[0-9]+";
		return str.matches(reg);
	}
	
	public static void main(String[] args) {
		System.out.println(arabicNumToChineseNum(39999));
	}
}
```

## IP地址 阿拉伯数字

**8.IP地址与int整数的转换**

ip地址与整数的转换。

例如，ip地址为10.0.3.193，把每段拆分成一个二进制形式组合起来为00001010 00000000 00000011 11000001，然后把这个二进制数转变成十进制整数就是167773121。

**题目分析：**

**IP地址转为整数**

借助位运算实现。如IP10.0.3.193，将10左移24位，0左移16位，3左移8位，193左移0位。4个seg`或运算`，即为结果。

```java
String ip = "10.0.3.193";
String[] arr = ip.split("\\.");
int arr0 = Integer.valueOf(arr[0])<<24;
int arr1 = Integer.valueOf(arr[1])<<16;
int arr2 = Integer.valueOf(arr[2])<<8;
int arr3 = Integer.valueOf(arr[3]);
System.out.println(arr0 | arr1 | arr2 | arr3);
```

**如何将整数转成IP**

将整数和255做`与运算`，结果为IP的第4段。整数右移8位，和255做`与运算`的结果就是IP的第3段...最后再将每轮与运算的结果拼接起来便是最终的IP地址。

```java
package com.lcz.test;

import java.util.Collections;
import java.util.*;

public class Test10 {
	public static void main(String[] args) {
		int n = 167773121;
		List<String> list = new ArrayList<>();
		list.add(Integer.toString(n&255));
		list.add(Integer.toString(n>>8&255));
		list.add(Integer.toString(n>>16&255));
		list.add(Integer.toString(n>>24&255));
		Collections.reverse(list);
		String res = "";
		for(int i=0;i<list.size();i++) {
			if(i==list.size()-1) {
				res += list.get(i);
			}else {
				res += list.get(i)+".";
			}
		}
		System.out.println(res);
	}
}

```





## 链表

### 21.两个链表 可能相交，找出相交的结点

1.若两个单[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)一个为有环,一个无环. 那么肯定不能相交.

2.若二者都没有环, 问题就转化为 两个无环单[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表) 是否相交,是否能找到第一个相交的节点，方法就是 快慢指针 。

3.若二者都有环,那么问题变成了两个有环单[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)是否相交.

第一,先找到二者是否相交.

第二,若相交则需要遍历一遍找到相交点.

**无环的情况下**

```java
//无环的情况
public class ListNode {
    int val;
    ListNode next;
    ListNode(int val){
        this.val = val;
        next = null;
    }
}

public class Solution {
    public ListNode getListNode(ListNode headA,ListNode headB) {
        if(headA == null || headB == null){
            return null;
        }
        ListNode pA = headA,pB = headB;
        while(pA != pB){
            if(pA == null){
                pA = headB;
            }else{
                pA = pA.next;
            }
            if(pB == null){
                pB = headA;
            }else{
                pB = pB.next;
            }
        }
        return pA;
    }
}
简化版：
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) return null;
        ListNode pA = headA, pB = headB;
        //如果不相交，pA=pB=null
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        return pA;
    }
}
```

**两个有环的情况**

两个有环[链表]()相交分为两种情况，一种是两个[链表]()在进入环之前相交，另一种是两个[链表]()在环内相交，如果不是在同一个节点进入，就是两个入口在两个节点。

-  第一种情况：可以将环在环的入口处断开，这样就与无环[链表]()相交一样，可以根据无环[链表]()的方法判断； 
-  第二种情况：两者相交于环内，而且入环口不同。pA的入口节点（标记位loopA），pB的入环口标记为loopB,当他们都遍历一圈停在自己的入口节点时，pA往后遍历，pB不动，pA回到loopA之前，一定会碰到pB,如果碰不到，说明两者不在一个环里。 
-  如果两种都不是，则是没有相交。

```java
pulic class ListNode{
    int val;
    ListNode next = null;
    ListNode(int val){
        this.val = val;
    }
}
public class Solution {
    public ListNode EntryNodeOfLoop(ListNode pHead){
        ListNode fast = pHead;
        ListNode slow = pHead;
        if(fast == null || fast.next == null){
            return null;
        }
        while(fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow){
                break;
            }
        }
        slow = pHead;
        while(fast != slow){
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}
```

### 

### 1.奇偶链表排序问题

题目描述：一个链表，奇数位升序偶数位降序，让链表变成升序的。

比如：1 8 3 6 5 4 7 2 9，最后输出1 2 3 4 5 6 7 8 9。

分析：

这道题可以分成三步：

首先根据奇**数位和偶数位拆分成两个链表。**

然后对**偶数链表进行反转。**

最后**将两个有序链表进行合并。**

```java
package com.lcz.test;
// 奇偶链表排序
class ListNode{
	int val;
	ListNode next;
	public ListNode() {
		
	}
	public ListNode(int val) {
		this.val = val;
	}
	public ListNode(int val,ListNode next) {
		this.val = val;
		this.next = next;
	}
}
public class Test6 {
	public static ListNode init() {
		ListNode node1 = new ListNode(1);
		ListNode node2 = new ListNode(8);
		ListNode node3 = new ListNode(3);
		ListNode node4 = new ListNode(6);
		ListNode node5 = new ListNode(5);
		ListNode node6 = new ListNode(4);
		ListNode node7 = new ListNode(7);
		ListNode node8 = new ListNode(2);
		ListNode node9 = new ListNode(9);
		
		node1.next = node2;
		node2.next = node3;
		node3.next = node4;
		node4.next = node5;
		node5.next = node6;
		node6.next = node7;
		node7.next = node8;
		node8.next = node9;
		
		return node1;
	}
	public static ListNode[] splitListNode(ListNode head) {
		ListNode oddDummy = new ListNode(-1);
		ListNode oddHead  = oddDummy;
		ListNode evenDummy = new ListNode(-1);
		ListNode evenHead = evenDummy;
		boolean oddFlag = true;
		while(head!=null) {
			if(oddFlag) {
				oddHead.next = head;
				oddHead = oddHead.next;
			}else {
				evenHead.next = head;
				evenHead = evenHead.next;
			}
			head = head.next;
			oddFlag = !oddFlag;
		}
		oddHead.next = null;
		evenHead.next = null;
		return new ListNode[] {oddDummy.next,evenDummy.next};
	}
	public static ListNode reverse(ListNode head) {
		ListNode pre = null;
		ListNode next = null;
		while(head!=null) {
			next = head.next;
			head.next = pre;
			pre = head;
			head = next;
		}
		return pre;
	}
	public static ListNode merge(ListNode l1,ListNode l2) {
		ListNode dummy = new ListNode(-1);
		ListNode l = dummy;
		while(l1!=null&&l2!=null) {
			if(l1.val>l2.val) {
				l.next = l2;
				l2 = l2.next;
			}else {
				l.next = l1;
				l1 = l1.next;
			}
			l = l.next;
		}
		if(l1!=null) {
			l.next = l1;
		}
		if(l2!=null) {
			l.next = l2;
		}
		return dummy.next;
	}
	public static void printListNode(ListNode head) {
		while(head!=null) {
			System.out.print(head.val + " ");
			head = head.next;
		}
	}
	
	public static void main(String[] args) {
		ListNode head = init();
		// 1.分割两个链表
		ListNode[] lists = splitListNode(head);
		// 2.反转第二个偶数链表
		ListNode oddHead = lists[0];
		ListNode evenHead = lists[1];
		evenHead = reverse(evenHead);
		// 3.合并两个链表
		head = merge(oddHead,evenHead);
		//输出结果
		printListNode(head);
	}
}

```

### [NC132 环形链表的约瑟夫问题](https://www.nowcoder.com/practice/41c399fdb6004b31a6cbb047c641ed8a?tpId=188&&tqId=38612&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

编号为 11 到 n*n* 的 n*n* 个人围成一圈。从编号为 11 的人开始报数，报到 m*m* 的人离开。

下一个人继续从 11 开始报数。

n-1*n*−1 轮结束以后，只剩下一个人，问最后留下的这个人编号是多少？

**示例1**

输入：

```
5,2     
```

复制

返回值：

```
3    
```

复制

说明：

```
开始5个人 1，2，3，4，5 ，从1开始报数，1->1，2->2编号为2的人离开
1，3，4，5，从3开始报数，3->1，4->2编号为4的人离开
1，3，5，从5开始报数，5->1，1->2编号为1的人离开
3，5，从3开始报数，3->1，5->2编号为5的人离开
最后留下人的编号是3     
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param n int整型 
     * @param m int整型 
     * @return int整型
     */
    public int ysf (int n, int m) {
        // write code here
        LinkedList<Integer> list=new LinkedList<>();
        if(m<1 || n<1){
            return -1;
        }
        for(int i=0;i<n;i++){
            list.add(i);
        }
        int bt=0;
        while(list.size()>1){
            bt=(bt+m-1)%list.size();
            list.remove(bt);
        }
        return list.get(0)+1;
    }
}
```



## HashMap

### HashMap遍历的问题

- KeySet：通过keySet()方法获取一个KeySet集合，这个类里封装的是map的key。
- Values：通过values()方法获取Values集合，这个类里封装的是map的值。
- EntrySet()：通过entrySet()获取EnterSet集合，这个类里封装的是map的键值对。

```java
public static void main(String[] args) {
		HashMap<Integer,Integer> dict = new HashMap<>();
		dict.put(1, 1);
		dict.put(2, 2);
		dict.put(3,3);
		//遍历的方式一
		for(Map.Entry<Integer, Integer> map:dict.entrySet()) {
			int key = map.getKey();
			int value = map.getValue();
			System.out.println("key:"+key+"value:"+value);
		}
		//遍历的方式二
		Iterator it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map = (Entry<Integer, Integer>) it.next();
			System.out.println("key:"+map.getKey());
			System.out.println("value:"+map.getValue());
		}
	}
```

**数组的遍历**

```java
//对数组的遍历
		List<Integer> list = new ArrayList<>();
		list.add(4);
		list.add(5);
		Iterator it_list = list.iterator();
		while(it_list.hasNext()) {
			Integer key = (Integer) it_list.next();
			System.out.println("key:"+key);
 		}
```

### HashMap,ArrayList删除的问题

**错误的删除**

```java
//对数组的遍历
		List<Integer> list = new ArrayList<>();
		list.add(3);
		list.add(4);
		list.add(4);
		list.add(5);
		Iterator it_list = list.iterator();
		while(it_list.hasNext()) {
			Integer key = (Integer) it_list.next();
			if(key==4) {
				list.remove(key);
			}
 		}
```

Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)
	at java.util.ArrayList$Itr.next(ArrayList.java:859)
	at com.lcz.security.Test11.main(Test11.java:32)



**正确的删除**

```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(4);
list.add(4);
list.add(5);
Iterator it_list = list.iterator();
while(it_list.hasNext()) {
    Integer key = (Integer) it_list.next();
    if(key==4) {
        it_list.remove();
    }
}
```



**错误做法**

```java
		//遍历的方式二
		Iterator it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map = (Entry<Integer, Integer>) it.next();
			if(map.getValue()==3) {
				dict.remove(map.getKey());
			}
		}
```

Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at com.lcz.security.Test11.main(Test11.java:20)

**正确做法**

```java
HashMap<Integer,Integer> dict = new HashMap<>();
		dict.put(1, 1);
		dict.put(2, 3);
		dict.put(3, 3);

		//遍历的方式二
		Iterator<Map.Entry<Integer, Integer>> it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map =  it.next();
			if(map.getValue()==3) {
				it.remove();
			}
		}
```



更加简洁的做法

```java
Map<String, Integer> map = new HashMap<>();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
map.put("d", 4);
map.entrySet().removeIf(entry -> entry.getValue() % 2 == 0);
```

### 

## 数组应用(日志、bitmap，Java8 stream，IP地址转换)

### Java8新特性Stream之list转map及问题解决

List集合转Map，用到的是Stream中Collectors的toMap方法：Collectors.toMap
具体用法实例如下：

```
//声明一个List集合
List<Person> list = new ArrayList();  
        list.add(new Person("1001", "小A"));  
        list.add(new Person("1002", "小B"));  
        list.add(new Person("1003", "小C"));
        System.out.println(list);
//将list转换map
Map<String, String> map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName));
        System.out.println(map);
```

注意：用Collectors的toMap方法转换List，一般会遇到两个问题。一个是转换map，key重复问题；另一个是空指针异常，即转为map的value是null。

问题解决！！！
一、第一种问题报的错误如下：Duplicate key

原因是声明List集合时，有的值重复，如图：

解决方法：(分三种，具体哪种看业务需求)
1.重复时用后面的value 覆盖前面的value

```java
Map<String, String> map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(key1 , key2)-> key2 ));
        System.out.println(map); 
输出结果：
```

输出结果：

2.重复时将前面的value 和后面的value拼接起来；

```java
Map<String, String> map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(key1 , key2)-> key1+","+key2 ));
        System.out.println(map);
```

输出结果：

输出结果：

3.重复时将重复key的数据组成集合

```java
Map<String, List<String>> map = list.stream().collect(Collectors.toMap(Person::getId,
	    		p ->  {
	    		 	List<String> getNameList = new ArrayList<>();
	    		 		getNameList.add(p.getName());
	    		 		return getNameList;
	    		 	},
    		     	(List<String> value1, List<String> value2) -> {
    		     		value1.addAll(value2);
    		     		return value1;
    		     	}
	    		 ));
       
```


输出结果：

二、第二种问题报的错误如下：NullPointerException

原因是声明List集合时有的值为空(如图)，但是HashMap中k,v是可以存null值的。

解决方法：在转换流中加上判空，即便value为空,依旧输出。(与上面方法三相同)

```java
Map<String, List<String>> map = list.stream().collect(Collectors.toMap(Person::getId,
	    		p ->  {
	    		 	List<String> getNameList = new ArrayList<>();
	    		 		getNameList.add(p.getName());
	    		 		return getNameList;
	    		 	},
    		     	(List<String> value1, List<String> value2) -> {
    		     		value1.addAll(value2);
    		     		return value1;
    		     	}
	    		 ))
         System.out.println(map);
```

### 8.IP地址与int整数的转换

ip地址与整数的转换。

例如，ip地址为10.0.3.193，把每段拆分成一个二进制形式组合起来为00001010 00000000 00000011 11000001，然后把这个二进制数转变成十进制整数就是167773121。

**题目分析：**

**IP地址转为整数**

借助位运算实现。如IP10.0.3.193，将10左移24位，0左移16位，3左移8位，193左移0位。4个seg`或运算`，即为结果。

```java
String ip = "10.0.3.193";
String[] arr = ip.split("\\.");
int arr0 = Integer.valueOf(arr[0])<<24;
int arr1 = Integer.valueOf(arr[1])<<16;
int arr2 = Integer.valueOf(arr[2])<<8;
int arr3 = Integer.valueOf(arr[3]);
System.out.println(arr0 | arr1 | arr2 | arr3);
```

**如何将整数转成IP**

将整数和255做`与运算`，结果为IP的第4段。整数右移8位，和255做`与运算`的结果就是IP的第3段...最后再将每轮与运算的结果拼接起来便是最终的IP地址。

```java
package com.lcz.test;

import java.util.Collections;
import java.util.*;

public class Test10 {
	public static void main(String[] args) {
		int n = 167773121;
		List<String> list = new ArrayList<>();
		list.add(Integer.toString(n&255));
		list.add(Integer.toString(n>>8&255));
		list.add(Integer.toString(n>>16&255));
		list.add(Integer.toString(n>>24&255));
		Collections.reverse(list);
		String res = "";
		for(int i=0;i<list.size();i++) {
			if(i==list.size()-1) {
				res += list.get(i);
			}else {
				res += list.get(i)+".";
			}
		}
		System.out.println(res);
	}
}

```

### 基于用户登录日志计算任一时间在线人数

给定一些用户登录的日志，计算任意时间的在线人数。其中用户登录日志包括如下信息：

```java
type LoginLog struct {
    userId     int
    loginTime  int
    logoutTime int
}
```

根据题目，一天24小时，我们有一堆的用户登录日志。简单的做法是我们遍历获取日志，然后对于用户在线的这段时间，对每一个时间点对在线人数加一。则程序如下：

```Go
func calOnlineUserCount(logList []*LoginLog) map[int]int {
    var timeToOnlineUserCountMap = make(map[int]int)
    for _, log := range logList {
        for i := log.loginTime; i <= log.logoutTime; i++ {
            timeToOnlineUserCountMap[i]++
        }
    }
    return timeToOnlineUserCountMap 
}
```

可以知道，这种方法的时间复杂度为O(kn)。在面试的时候面试官会希望给出O(n)事件复杂度的解法。



简单考虑一下，如果我们知道k时间的在线人数，我们很容易知道k+1时间的在线认识：

**k+1时刻的在线人数** = **k时刻在线人数** + **k+1时刻上线人数 - k+1时刻下线人数**

```js
func calOnlineUserCount(logList []*LoginLog) map[int]int {
	var timeToOnlineUserCountMap = make(map[int]int)
	var timeToLoginUserCountMap = make(map[int]int)
	var timeToLogoutUserCountMap = make(map[int]int)
	for _, log := range logList {
		timeToLoginUserCountMap[log.loginTime]++
		timeToLogoutUserCountMap[log.logoutTime]++
	}
	var startTime int // 根据统计时间
	var endTime int // 根据统计时间
	for i := startTime; i <= endTime; i++ {
		timeToOnlineUserCountMap[i] = max(timeToOnlineUserCountMap[i-1] +  timeToLoginUserCountMap[i] - timeToLogoutUserCountMap[i], 0)
	}
	return timeToOnlineUserCountMap
}
```

### 代码题：Java实现bitmap，判断元素是否存在？

```java
class BitSet{
	// 常数表示存多大的数
	static final int N = 10000000;
	// 数组存储
	int[] bitMap;
	// 初始化
	public BitSet() {
		bitMap = new int[N/32+1];
	}
	//添加一个数字
	public void add(int value) {
		int index = value/32; // 位于数组bitmap中的index位置
		int offset = value%32-1; //这个int中的bit位置，offset是1移动多少位置
		// 放入
		bitMap[index] = bitMap[index] | 1<<offset;
	}
	// 判断一个数字是否存在
	public boolean isExist(int value) {
		int index = value/32;
		int offset = value%32-1;;
		boolean flag = ((bitMap[index]>>offset)&0x01)==0x01?true:false;
		return flag;
	}
	
	// 如何根据bitMap恢复原始数据
	public void reverseDigit() {
		for(int i=0;i<bitMap.length;i++) {
			int temp = bitMap[i];
			for(int j=0;j<32;j++) {
				boolean flag = ((temp>>j)&0x01)==0x01?true:false;
				if(flag) {
					int data = i*32+j+1;
				}
			}
		}
	}
}
```









## 数组（股票买卖，区间和*区间最小值，除自身之外，不相邻数组、扑克牌汉诺塔，删除注释，爬楼梯）

### 【在数组中，数字减去它右边的数字得到一个数对之差。股票买卖】

```
//求所有数对之差的最大值。例如在数组{ 2, 4, 1, 16, 7, 5, 11, 9 }中
//数对之差的最大值是11，是16减去5的结果。


#include<iostream>
using namespace std;
int main()
{
int num[] = { 2, 4, 1, 16, 7, 11,5,  9 };
int n = 7,max = 0;
for (int i = 0; i < n;++i)
{
for (int j = i + 1; j < n;++j)
{
if (num[i] - num[j] > max)
{
max = num[i] - num[j];
}
}
}
return 0;
}

```



题目：在数组中，数字减去它右边的数字得到一个数对之差。求所有数对之差的最大值。例如在数组{2, 4, 1, 16, 7, 5, 11, 9}中，数对之差的最大值是11，是16减去5的结果。

动态规划

变量：i为数组索引，max为i之前的最大值（不包括i），maxdiff为i之前的数减去i得到的最大差。

解释：

当i时，maxdiff=max-data[i]，即i之前的最大数减去data[i]。

当i+1时，i+1之前的最大值为max或data[i]，找到最大值后减去data[i+1]得到减i+1的最大差。

```java
当1时，max=data[0]，maxdiff=max-data[1]。

int MaxDiff_Solution3(int numbers[], unsigned length)
{
    if(numbers == NULL && length < 2)
        return 0;

    int max = numbers[0];
    int maxDiff =  max - numbers[1];
     
    for(int i = 2; i < length; ++i)
    {
        if(numbers[i - 1] > max)
            max = numbers[i - 1];
     
        int currentDiff = max - numbers[i];
        if(currentDiff > maxDiff)
            maxDiff = currentDiff;
    }
     
    return maxDiff;

}
```



### 13.区间和*区间最小值的最大值是多少

挑选一个区间，区间值为区间和乘以区间内最小的数的值，求区间值最大的区间（2021.1 字节跳动-国际化-前端）
无序数组，求一个值最大的区间，区间计算方案为：区间和 * 区间最小值（2020.09 字节跳动-电商-后端）
[3,1,6,4,5,2]，对于任意子序列可以计算一个X值，X=sum(subArray) * min(subArray)，求最大X（2020.07 字节跳动-商业化-前端）

**题目分析：**

给定一个数组，要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和。

数组中的元素都是非负数。

输入两行，第一行n表示数组长度，第二行为数组序列。输出最大值。

输入
3
6 2 1
输出
36
解释：满足条件区间是[6] = 6 * 6 = 36;

**题目分析**

**方法一：暴力。**题目是找max(区间和 * 区间最小值)，而满足的区间最小值一定是数组的某个元素。因此可以枚举数组，枚举时每个元素（设为x）作为区间最小值，在x左右两侧找到第一个比x小的元素，分别记录左右边界的下标为l,r，寻找边界时计算当前区间的和。那么以x为区间最小值的最大计算区间一定是[l+1,r-1]区间和*x。整个算法的时间复杂度是O(N²)。

**方法二：单调栈。**方法一中找每个元素左右边界的复杂度是O(N)，通过单调栈的数据结构可以将其优化为O(1),因此优化后整个算法的时间复杂度可以达到O(N)。

```java
//单调栈，时间复杂度O(N)
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int N = 500000+10;
int a[N];
int dp[N];
stack<int> s;
int main()
{
    int n,res=0;
    cin >> n;
    for(int i = 0; i < n; i ++) cin >> a[i];
    //前缀和便于快速求区间和，例如求[l,r]区间和=dp[r+1]-dp[l]。l和r的取值范围是[0,n)
    for(int i = 1; i <= n; i ++) dp[i] = dp[i-1] + a[i-1]; 
    for(int i = 0; i < n; i ++) {
        while(!s.empty() && a[i] <= a[s.top()]) {
            int peak = a[s.top()];
            s.pop();
            int l = s.empty()? -1 : s.top();
            int r = i; 
            //l和r是边界，因此区间是[l+1,r-1]，其区间和dp[r+1]-dp[l]
            int dist = dp[r] - dp[l+1];
            res = max(res,peak*dist);
        }
        s.push(i);
    }
    while(!s.empty())
    {
        int peak = a[s.top()];
        s.pop();
        int l = s.empty()? -1 : s.top();
        int r = n; 
        
        int dist = dp[r] - dp[l+1];
        res = max(res,peak*dist);
    }
    cout << res << endl; 
}

```

### Leetcode238 除自身以外数组的乘积

给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

 

示例:

输入: [1,2,3,4]
输出: [24,12,8,6]


提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。

说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。

进阶：
你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）

```java
class Solution {
	    public int[] productExceptSelf(int[] nums) {
	    	//结果数组
	    	int[] res = new int[nums.length];
	    	// 左边开始
	    	// 第一个数无左边
	    	res[0] = 1;
	    	for(int i=1;i<nums.length;i++) {
	    		res[i] = res[i-1]*nums[i-1];
	    	}
	    	// 右边开始
	    	// 对于索引i 左边值为res[i] 右边值为R
	    	int R =1;
	    	for(int i=nums.length-1;i>=0;i--) {
	    		res[i] = res[i]*R;
	    		// 更新R
	    		R = R * nums[i];
	    	}
	    	return res;
	    }
	}
```



```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int length = nums.length;
        int[] answer = new int[length];

        // answer[i] 表示索引 i 左侧所有元素的乘积
        // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1
        answer[0] = 1;
        for (int i = 1; i < length; i++) {
            answer[i] = nums[i - 1] * answer[i - 1];
        }

        // R 为右侧所有元素的乘积
        // 刚开始右边没有元素，所以 R = 1
        int R = 1;
        for (int i = length - 1; i >= 0; i--) {
            // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R
            answer[i] = answer[i] * R;
            // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
            R *= nums[i];
        }
        return answer;
    }
}


```

### Leetcode 不相邻的最大和-打家劫舍198

假设你是一个专业的窃贼，准备沿着一条街打劫房屋。每个房子都存放着特定金额的钱。你面临的唯一约束条件是：相邻的房子装着相互联系的防盗系统，且 当相邻的两个房子同一天被打劫时，该系统会自动报警。给定一个非负整数列表，表示每个房子中存放的钱， 算一算，如果今晚去打劫，你最多可以得到多少钱 在不触动报警装置的情况下。

**例如：**

数组arr为[1, 3, 5, 4, 9]，那么结果为 1 + 5 + 9 = 15，再例如数组arr为[5, 1, 3, 11, 7]，那么结果为5 + 11 = 16，从这两个例子可以看出，单纯的计算奇数位的和或者偶数位的和得到的结果未必是最大的。

**解题思路**：

定义一个数组p，p[i] 代表从第0到第i个房屋，打劫第i个房屋为止所获得金钱总额，也就是说第i个房屋要打劫，而p[i]肯定等于arr[i] + p[i-2]或者arr[i] + p[i-3]的最大值，因为相邻的房屋不能打劫，所以p[i-1]不能算。最后我们只要计算p[arr.length-1]和p[arr.length-2]哪个大就行了。p[arr.length-3]肯定不是最大的，因为p[arr.length-3] + arr[arr.length-1]肯定比p[arr.length-3]大



### 爬楼梯

**描述**

大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。

n\leq 39*n*≤39

**示例1**

输入：

```
4
```

返回值：

```
3
```

**递归的思路**

```java
int Fibonacci(int n) {
    if (n==0 || n==1) return n;
    return Fibonacci(n-1) + Fibonacci(n-2);
}

```

**时间复杂度**：O(2^n)
**空间复杂度**：递归栈的空间



**记忆化递归**

```java
int Fib(int n, vector<int>& dp) {
    if (n==0 || n==1) return n;
    if (dp[n] != -1) return dp[n];
    return dp[n] = Fib(n-1) + Fib(n-2);
}
int Fibonacci(int n) {
    vector<int> dp(45, -1); // 因为答案都是>=0 的， 所以初始为-1，表示没计算过
    return Fib(n, dp);
}
```

**时间复杂度**：O（n）， 没有重复的计算
**空间复杂度**：O（n）和递归栈的空间



**动归规划**

```java
int Fibonacci(int n) {
    vector<int> dp(n+1, 0);
        dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
}
```

**时间复杂度**：O(n)
**空间复杂度**：O(n)



```java
int Fibonacci(int n) {
     if (n == 0 || n == 1) return n;
        int a = 0, b = 1, c;
        for (int i=2; i<=n; ++i) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
}

```

**时间复杂度**：O（n）
**空间复杂度**：O（1）



### 10.扑克牌顺子

**描述**

现在有2副扑克牌，从扑克牌中随机五张扑克牌，我们需要来判断一下是不是顺子。
有如下规则：
\1. A为1，J为11，Q为12，K为13，A不能视为14
\2. 大、小王为 0，0可以看作任意牌
\3. 如果给出的五张牌能组成顺子（即这五张牌是连续的）就输出true，否则就输出false。
例如：给出数据[6,0,2,0,4]
中间的两个0一个看作3，一个看作5 。即：[6,3,2,5,4]
这样这五张牌在[2,6]区间连续，输出true
数据保证每组5个数字，每组最多含有4个零，数组的数取值为 [0, 13]

**示例1**

输入：

```
[6,0,2,0,4]
```

返回值：

```
true
```

**示例2**

输入：

```
[0,3,2,6,4]
```

复制

返回值：

```
true
```

```java
import java.util.*;

public class Solution {
    public boolean IsContinuous(int [] nums) {
        //1.先排序
        Arrays.sort(nums);
        int joker = 0;
        for(int i=0;i<4;i++){
            if(nums[i]==0){
                joker++;
            }else if(nums[i]==nums[i+1]){
                return false;
            }
        }
        return nums[4]-nums[joker]<5;
    }
}
```

### Leetcode846 一手顺子

爱丽丝有一手（hand）由整数数组给定的牌。 

现在她想把牌重新排列成组，使得每个组的大小都是 W，且由 W 张连续的牌组成。

如果她可以完成分组就返回 true，否则返回 false。

 

注意：此题目与 1296 重复：https://leetcode-cn.com/problems/divide-array-in-sets-of-k-consecutive-numbers/

 

示例 1：

输入：hand = [1,2,3,6,2,3,4,7,8], W = 3
输出：true
解释：爱丽丝的手牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。
示例 2：

输入：hand = [1,2,3,4,5], W = 4
输出：false
解释：爱丽丝的手牌无法被重新排列成几个大小为 4 的组。

```java
class Solution {
    public boolean isNStraightHand(int[] hand, int W) {
        if (hand.length % W != 0) return false;

        TreeMap<Integer, Integer> map = new TreeMap<>();
        for (int num : hand) map.put(num, map.getOrDefault(num, 0) + 1); // 从小到大每个数字出现次数

        while(map.size() > 0) {
            int first = map.firstKey();
            // 遍历first -> first + w个数，将出现次数减1，若为0，则删除
            for (int i = first; i < first + W; i++) {
                if (!map.containsKey(i)) return false;
                map.put(i, map.get(i) - 1);
                if (map.get(i) == 0) map.remove(i);
            }
        }

        return true;
    }
}

```



### [NC67 汉诺塔问题](https://www.nowcoder.com/practice/7d6cab7d435048c4b05251bf44e9f185?tpId=117&&tqId=37787&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

我们有由底至上为从大到小放置的 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个圆盘，和三个柱子（分别为左/中/右），开始时所有圆盘都放在左边的柱子上，按照汉诺塔游戏的要求我们要把所有的圆盘都移到右边的柱子上，要求一次只能移动一个圆盘，而且大的圆盘不可以放到小的上面。


请实现一个函数打印最优移动轨迹。

给定一个 **`int n`** ，表示有 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个圆盘。请返回一个 **`string`** 数组，其中的元素依次为每次移动的描述。描述格式为： **`move from [left/mid/right] to [left/mid/right]`**。

数据范围 1\le n \le 181≤*n*≤18

**示例1**

输入：

```
2
```

复制

返回值：

```
["move from left to mid","move from left to right","move from mid to right"]
```

```java
import java.util.*;
public class Solution{
    ArrayList<String> ans = new ArrayList<>();
    public ArrayList<String> getSolution(int n) {
        Hanoi(n,"left","mid","right");
        return ans;
    }
    
    //把n个盘子从Left 借助 Mid，移动到Right柱子上
    public void Hanoi(int n, String Left, String Mid, String Right){
        if(n==0){return;}
        //把n-1个盘子从Left 借助 Right，移动到Mid柱子上
        Hanoi(n-1,Left,Right,Mid);
        //把剩下最大的那一个盘子从Left移动到 Right柱子上
        String t = "move from "+Left+" to "+Right;
        ans.add(t);
        //把n-1个盘子从Mid 借助 Left，移动到,Right柱子上
        Hanoi(n-1,Mid,Left,Right);
    }
    
}
```

### 

### Leetcode722 删除注释

给一个 C++ 程序，删除程序中的注释。这个程序source是一个数组，其中source[i]表示第i行源码。 这表示每行源码由\n分隔。

在 C++ 中有两种注释风格，行内注释和块注释。

字符串// 表示行注释，表示//和其右侧的其余字符应该被忽略。

字符串/* 表示一个块注释，它表示直到*/的下一个（非重叠）出现的所有字符都应该被忽略。（阅读顺序为从左到右）非重叠是指，字符串/*/并没有结束块注释，因为注释的结尾与开头相重叠。

第一个有效注释优先于其他注释：如果字符串//出现在块注释中会被忽略。 同样，如果字符串/*出现在行或块注释中也会被忽略。

如果一行在删除注释之后变为空字符串，那么不要输出该行。即，答案列表中的每个字符串都是非空的。

样例中没有控制字符，单引号或双引号字符。比如，source = "string s = "/* Not a comment. */";" 不会出现在测试样例里。（此外，没有其他内容（如定义或宏）会干扰注释。）

我们保证每一个块注释最终都会被闭合， 所以在行或块注释之外的/*总是开始新的注释。

最后，隐式换行符可以通过块注释删除。 有关详细信息，请参阅下面的示例。

从源代码中删除注释后，需要以相同的格式返回源代码。

示例 1:

输入: 
source = ["/*Test program */", "int main()", "{ ", "  // variable declaration ", "int a, b, c;", "/* This is a test", "   multiline  ", "   comment for ", "   testing */", "a = b + c;", "}"]

示例代码可以编排成这样:
/*Test program */
int main()
{ 
  // variable declaration 
int a, b, c;
/* This is a test
   multiline  
   comment for 
   testing */
a = b + c;
}

输出: ["int main()","{ ","  ","int a, b, c;","a = b + c;","}"]

编排后:
int main()
{ 

int a, b, c;
a = b + c;
}

解释: 
第 1 行和第 6-9 行的字符串 /* 表示块注释。第 4 行的字符串 // 表示行注释。

```java
class Solution {
    public List<String> removeComments(String[] source) {
        boolean inBlock = false;
        StringBuilder newline = new StringBuilder();
        List<String> ans = new ArrayList();
        for (String line: source) {
            int i = 0;
            char[] chars = line.toCharArray();
            if (!inBlock) newline = new StringBuilder();
            while (i < line.length()) {
                if (!inBlock && i+1 < line.length() && chars[i] == '/' && chars[i+1] == '*') {
                    inBlock = true;
                    i++;
                } else if (inBlock && i+1 < line.length() && chars[i] == '*' && chars[i+1] == '/') {
                    inBlock = false;
                    i++;
                } else if (!inBlock && i+1 < line.length() && chars[i] == '/' && chars[i+1] == '/') {
                    break;
                } else if (!inBlock) {
                    newline.append(chars[i]);
                }
                i++;
            }
            if (!inBlock && newline.length() > 0) {
                ans.add(new String(newline));
            }
        }
        return ans;
    }
}
```

### Leetcode616 给字符串添加粗标签

给你一个字符串 s 和一个字符串列表 words ，你需要将在字符串列表中出现过的 s 的子串添加加粗闭合标签 <b> 和 </b> 。

如果两个子串有重叠部分，你需要把它们一起用一对闭合标签包围起来。同理，如果两个子字符串连续被加粗，那么你也需要把它们合起来用一对加粗标签包围。

返回添加加粗标签后的字符串 s 。

 

示例 1：

输入： s = "abcxyz123", words = ["abc","123"]
输出："<b>abc</b>xyz<b>123</b>"
示例 2：

输入：s = "aaabbcc", words = ["aaa","aab","bc"]
输出："<b>aaabbc</b>c"

```java
class Solution {
    public String addBoldTag(String s, String[] dict) {
        PriorityQueue<int[]> intervals = new PriorityQueue<>((a, b) -> a[0] - b[0]);

        for (String str : dict) {
            int offset = s.indexOf(str, 0);
            while (offset != -1) {
                intervals.offer(new int[]{ offset, offset + str.length() });
                offset = s.indexOf(str, offset + 1);
            }
        }

        StringBuilder sb = new StringBuilder();
        int[] last = intervals.isEmpty() ? null : intervals.poll();
        int start = 0;
        while(last != null) {
            int[] cur = intervals.isEmpty() ? null : intervals.poll();
            if (cur != null && last[1] >= cur[0]) {
                last[1] = Math.max(cur[1], last[1]);
            } else {
                sb.append(s.substring(start, last[0]));
                sb.append("<b>").append(s.substring(last[0], last[1])).append("</b>");
                start = last[1];
                last = cur;
            }
        }
        sb.append(s.substring(start));
        return sb.toString();
    }
}
```

### Leetcode187 重复的DNA序列

所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。

编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

 

示例 1：

输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
输出：["AAAAACCCCC","CCCCCAAAAA"]
示例 2：

输入：s = "AAAAAAAAAAAAA"
输出：["AAAAAAAAAA"]

```java
class Solution {
  public List<String> findRepeatedDnaSequences(String s) {
    int L = 10, n = s.length();
    HashSet<String> seen = new HashSet(), output = new HashSet();

    // iterate over all sequences of length L
    for (int start = 0; start < n - L + 1; ++start) {
      String tmp = s.substring(start, start + L);
      if (seen.contains(tmp)) output.add(tmp);
      seen.add(tmp);
    }
    return new ArrayList<String>(output);
  }
}


```





## 货币兑换

### [NC126 换钱的最少货币数](https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=188&&tqId=38635&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。

如果无解，请返回-1.

【要求】

时间复杂度O(n \times aim)*O*(*n*×*a**i**m*)，空间复杂度On。

**示例1**

输入：

```
[5,2,3],20
```

复制

返回值：

```
4
```

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] coins, int amount) {
        // write code here
         int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

### 19.换钱的最少货币数

**描述**

给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。

如果无解，请返回-1.

【要求】

时间复杂度O(n \times aim)*O*(*n*×*a**i**m*)，空间复杂度On。

**示例1**

输入：

```
[5,2,3],20
```

复制

返回值：

```
4
```

复制

**示例2**

输入：

```
[5,2,3],0
```

复制

返回值：

```
0
```

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] arr, int aim) {
        // 二维数组 dp[m][n], m 表示货币种类, n表示剩余找零
        int[][] dp = new int[arr.length][aim + 1];
        // 初始化第一种面值，若能被剩余找零整除，就在数组中填该货币使用的张数。
        for (int i = 1; i < aim + 1; ++i) {
            if (i % arr[0] == 0) {
                dp[0][i] = i / arr[0];
            }
        }
        for (int m = 1; m < arr.length; ++m) {
            for (int n = 1; n < aim + 1; ++n) {
                // 若当前面值大于剩余找零，则只能不使用此种货币
                if (arr[m] > n) {
                    dp[m][n] = dp[m - 1][n];
                } else if (arr[m] == n) {
                    dp[m][n] = 1;
                } else if (dp[m][n - arr[m]] != 0 &&  dp[m - 1][n] != 0) {
                    // 若使用一张当前货币和不使用当前货币都有值，取最小那个
                    dp[m][n] = min(dp[m][n - arr[m]] + 1, dp[m - 1][n]);
                } else {
                    // 若其中一个为 0，取不为 0 的那一个
                    dp[m][n] = dp[m][n - arr[m]] != 0 ? dp[m][n - arr[m]] + 1 : dp[m - 1][n];
                }
 
            }
        }
        return dp[arr.length-1][aim] == 0 ? -1 : dp[arr.length-1][aim];
    }
    
    private int min (int a, int b) {
        return a < b ? a : b;
    }
}
```

### 面试题08.11 硬币

硬币。给定数量不限的硬币，币值为25分、10分、5分和1分，编写代码计算n分有几种表示法。(结果可能会很大，你需要将结果模上1000000007)

示例1:

 输入: n = 5
 输出：2
 解释: 有两种方式可以凑成总金额:
5=5
5=1+1+1+1+1
示例2:

 输入: n = 10
 输出：4
 解释: 有四种方式可以凑成总金额:
10=10
10=5+5
10=5+1+1+1+1+1
10=1+1+1+1+1+1+1+1+1+1

```
class Solution {
    static final int MOD = 1000000007;
    int[] coins = {25, 10, 5, 1};

    public int waysToChange(int n) {
        int[] f = new int[n + 1];
        f[0] = 1;
        for (int c = 0; c < 4; ++c) {
            int coin = coins[c];
            for (int i = coin; i <= n; ++i) {
                f[i] = (f[i] + f[i - coin]) % MOD;
            }
        }
        return f[n];
    }
}

```

### Leetcode983 最低票价

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。

火车票有三种不同的销售方式：

一张为期一天的通行证售价为 costs[0] 美元；
一张为期七天的通行证售价为 costs[1] 美元；
一张为期三十天的通行证售价为 costs[2] 美元。
通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。

返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。

 

示例 1：

输入：days = [1,4,6,7,8,20], costs = [2,7,15]
输出：11
解释： 
例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：
在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。
在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。
在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。
你总共花了 $11，并完成了你计划的每一天旅行。

```java
class Solution {
    public int mincostTickets(int[] days, int[] costs) {
        // 将从新年到某一天的花过的所有钱数全部记录起来。
        int[] lastAllDaysCost = new int[366];
        //  days的下标，确保遍历365天时，以便于知道下次旅游的日期。
        int dayIdx = 0;
        // 日，月，年的花费。
        int ticketDay = costs[0];
        int ticketWeek = costs[1];
        int ticketMonth = costs[2];
        // 因为是第一天，所以过去的总花费为0
        lastAllDaysCost[0] = 0;
        // lastAllCost[i] 是截至到今年的第 i 天的总花费.
        
        // 模拟新年的第一天跑到旅行的最后一天。
        for (int today = 1; today <= 365; today++) {
            if(dayIdx >= days.length){
                break;
            }
            // 判断今天是否属于旅行日。
            if (days[dayIdx] != today) {
                // 如果这一天不旅行那么直接把上一天的过去总花费拿过来直接使用。
                lastAllDaysCost[today] = lastAllDaysCost[today - 1];
                continue;
            }
            // 开始等待下一个待旅行的日子到来。
            dayIdx++;
            // 如果一月前，买了月票，会不会更便宜？
            // 如果一周前，买了周票，会不会更便宜？
            // 如果都不会的话，那我暂时先买日票试试呗。
            lastAllDaysCost[today] = Math.min(
                    Math.min(
                            lastAllDaysCost[Math.max(0, today - 1)] + ticketDay
                            , lastAllDaysCost[Math.max(0, today - 7)] + ticketWeek)
                    , lastAllDaysCost[Math.max(0, today - 30)] + ticketMonth);
        }
        return lastAllDaysCost[days[days.length - 1]];
    }
}

```







## 旋转图像打印

### [Leetcode54 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)

给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。

 

示例 1：


输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]

![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)

```java
class Solution {
    // 结果存储
    List<Integer> res  = new ArrayList<>();
    public List<Integer> spiralOrder(int[][] matrix) {
        // 开始坐标 结束坐标
        int rows = matrix.length;
        int cols = matrix[0].length;
        
        int start_row = 0;
        int start_col = 0;
        int end_row = rows-1;
        int end_col = cols-1;

        // while循环
        while(start_row<=end_row&&start_col<=end_col){
            process(matrix,start_row++,start_col++,end_row--,end_col--);
        } 
        return res;
    }

    // 处理
    public void process(int[][] matrix,int start_row,int start_col,int end_row,int end_col){
        // 最上边的处理
        for(int i=start_col;i<=end_col;i++){
            res.add(matrix[start_row][i]);
        }
        if(start_row==end_row){
            return;
        }
        // 最右边的处理
        for(int i=start_row+1;i<=end_row;i++){
            res.add(matrix[i][end_col]);
        }
        
        if(start_col==end_col){
            return;
        }
        // 最下边的处理
        for(int i=end_col-1;i>=start_col;i--){
            res.add(matrix[end_row][i]);
        }

        // 最左边的处理
        for(int i=end_row-1;i>start_row;i--){
            res.add(matrix[i][start_col]);
        }

    }
}
```

### [Leetcode59 螺旋矩阵II](https://leetcode-cn.com/problems/spiral-matrix-ii/)

给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)


输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
示例 2：

```java
class Solution {
		// 全局变量记录
		int index = 1;
	    public int[][] generateMatrix(int n) {
	    	// 第一步生成矩阵
	    	int[][] arr = new int[n][n];
	    	// 第二步螺旋
	    	int start_x = 0;
	    	int start_y = 0;
	    	int end_x = n-1;
	    	int end_y = n-1;
	    	while(start_x<=end_x) {
	    		process(arr,start_x++,start_y++,end_x--,end_y--);
	    	}
	    	return arr;
	    }
	    // 开始处理
	    public void process(int[][] arr,int start_x,int start_y,int end_x,int end_y) {
	    	// 开始列遍历
	    	for(int i=start_y;i<=end_y;i++) {
	    		arr[start_x][i] = index++;
	    	}
	    	// 开始行遍历
	    	for(int i=start_x+1;i<=end_x;i++) {
	    		arr[i][end_y] = index++;
	    	}
	    	//判断一下
	    	if(start_x==end_x||start_y==end_y) {
	    		return;
	    	}
	    	// 返回列
	    	for(int i=end_y-1;i>=start_y;i--) {
	    		arr[end_x][i] = index++;
	    	}
	    	// 返回行
	    	for(int i=end_x-1;i>start_x;i--) {
	    		arr[i][start_y] = index++;
	    	}
	    	
	    }
	}
```



### [Leetcode048旋转图像](https://leetcode-cn.com/problems/rotate-image/)

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]

```java
class Solution {
	    public void rotate(int[][] matrix) {
	    	// 左上角和右下角
	    	int row_left = 0;
	    	int col_left = 0;
	    	int row_right = matrix.length-1;
	    	int col_right = matrix[0].length-1;
	    	while(row_left<row_right) {
	    		swap(matrix,row_left++,col_left++,row_right--,col_right--);
	    	}
	    }
	    
	    // 交换
	    public void swap(int[][] matrix,int row_left,int col_left,int row_right,int col_right) {
	    	int temp;
	    	int times = row_right-row_left;
	    	for(int i=0;i<times;i++) {
	    		temp 						   = matrix[row_left][col_left+i];
	    		matrix[row_left][col_left+i]   = matrix[row_right-i][col_left];
	    		matrix[row_right-i][col_left]  = matrix[row_right][col_right-i];
	    		matrix[row_right][col_right-i] = matrix[row_left+i][col_right];
	    		matrix[row_left+i][col_right]   = temp;
	    	}
	    }
	}
```

### [Leetcode74 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：

每行中的整数从左到右按升序排列。
每行的第一个整数大于前一行的最后一个整数。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/05/mat.jpg)


输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length == 0)
            return false;
        int row = 0, col = matrix[0].length-1;
        while(row < matrix.length && col >= 0){
            if(matrix[row][col] < target)
                row++;
            else if(matrix[row][col] > target)
                col--;
            else
                return true;
        }
        return false;
    }
}
```

### Leetcode240 搜索二维矩阵II

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

每行的元素从左到右升序排列。
每列的元素从上到下升序排列。

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)

输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
输出：true

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        int m  = matrix.length-1;
        int n = matrix[0].length;
        int row_start = 0;
        int col_start = n-1;
        while(row_start<=m&&col_start>=0){
            if(matrix[row_start][col_start]==target){
                return true;
            }else if(matrix[row_start][col_start]>target){
                col_start--;
            }else if(matrix[row_start][col_start]<target){
                row_start++;
            }
        }
        return false;
    }
}
```

### [剑指Offer29 顺时针打印矩阵](https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。

 

示例 1：

输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
示例 2：

输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    public int[] spiralOrder(int[][] matrix) {
        int rows = matrix.length;
        if(rows==0){
            return new int[]{};
        }
        int cols = matrix[0].length;
        

        int start_row = 0;
        int start_col = 0;
        int end_row = rows-1;
        int end_col = cols-1;
        // 开始
        while(start_row<=end_row&&start_col<=end_col){
            // 调用函数
            print(matrix,start_row++,start_col++,end_row--,end_col--);
        }
        // 转为array数组
        int[] res = new int[rows*cols];
        for(int i=0;i<res.length;i++){
            res[i] = list.get(i);
        }
        return res;
    }

    // 打印
    public void print(int[][] matrix,int start_row,int start_col,int end_row,int end_col){
        // 打印
        for(int i=start_col;i<=end_col;i++){
            list.add(matrix[start_row][i]);
        }
  
        for(int i=start_row+1;i<=end_row;i++){
            list.add(matrix[i][end_col]);
        }

        for(int i=end_col-1;i>=start_col;i--){
            list.add(matrix[end_row][i]);
        }

        for(int i=end_row-1;i>start_row;i--){
            list.add(matrix[i][start_col]);
        }

    }
}
```

### [Leetcode498对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

 

示例:

输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/diagonal_traverse.png)

```java
class Solution {
    // 记录
    List<Integer> list = new ArrayList<>();
    public int[] findDiagonalOrder(int[][] matrix) {
        // 记录左上角和右下角即可
        int endR = matrix.length-1;
        int endC = matrix[0].length-1;
        // 当前开始和结束的四个坐标值
        int tR = 0;
        int tC = 0;
        int dR = 0;
        int dC = 0;
        // 用一个flag来标识
        boolean flag = false;
        // 开始的点走到了最后的一行
        while(tR!=endR+1){
            // 打印
            print(matrix,tR,tC,dR,dC,flag);
            // 开始移动
            // 移动注意先移动左
            tR = tC==endC?tR+1:tR;
            tC = tC==endC?tC:tC+1;
            // 下方移动的时候先移动 要不然报错！！
            dC = dR==endR?dC+1:dC;
            dR = dR==endR?dR:dR+1;
            flag = !flag;
        }
        int len = (endR+1)*(endC+1);
        int[] res = new int[len];
        for(int i=0;i<len;i++){
            res[i] = list.get(i);
        }
        return res;

    }

    public void print(int[][] matrix,int tR,int tC,int dR,int dC,boolean flag){
        if(flag){
            while(tR!=dR+1){
                list.add(matrix[tR][tC]);
                tR++;
                tC--;
            }
        }else{
            while(dR!=tR-1){
                list.add(matrix[dR][dC]);
                dR--;
                dC++;
            }
        }

    }
}
```

### [Leetcode1424 对角线遍历II](https://leetcode-cn.com/problems/diagonal-traverse-ii/)

给你一个列表 nums ，里面每一个元素都是一个整数列表。请你依照下面各图的规则，按顺序返回 nums 中对角线上的整数。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_1_1784.png)

输入：nums = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,4,2,7,5,3,8,6,9]

示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/23/sample_2_1784.png)

输入：nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]
输出：[1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]

```java
class Solution {
    public int[] findDiagonalOrder(List<List<Integer>> nums) {
        int length = 0;
        //根据对角线i+j唯一且相同，LinkedHashMap保持插入排序。效率是最优的
        Map<Integer,List<Integer>> map =new LinkedHashMap<>();
        for(int i = 0;i < nums.size();i++) {
            length += nums.get(i).size(); 
            for(int j = 0;j < nums.get(i).size();j++) {
                List<Integer> orDefault = map.getOrDefault(i + j, new ArrayList<>());
                orDefault.add(nums.get(i).get(j));
                map.putIfAbsent(i+j,orDefault);
            }
        }
        int[] result = new int[length];
        int index = 0;
        //遍历map，得到结果。
        for(int key : map.keySet()) { 
            List<Integer> list = map.get(key);
            for(int j = list.size() - 1;j >= 0;j--) { 
                result[index] = list.get(j);
                index++;
            }
        }
        return result;
    }
}


```

### [Leetcode119杨辉三角II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

示例 1:

输入: rowIndex = 3
输出: [1,3,3,1]

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
// 全部的
	    	List<List<Integer>> res_all = new ArrayList<>();
	    	for(int i=0;i<=rowIndex;i++) {
	    		// 每一行的List
	    		List<Integer> res = new ArrayList<>();
	    		//每一行的值
	    		for(int j=0;j<=i;j++) {
	    			// 头是1 尾巴是1
	    			if(j==0 || j==i) {
	    				res.add(1);
	    			}else {
	    				//值(i,j)= (i-1,j)+(i-1,j-1)
	    				int lastValue_1 = res_all.get(i-1).get(j);
	    				int ladtValue_2 = res_all.get(i-1).get(j-1);
	    				res.add(lastValue_1+ladtValue_2);
	    			}
	    		}
	    		// 添加
	    		res_all.add(res);
	    	}
	    	// 返回
	    	return res_all.get(rowIndex);
    }
}
```

### Leetcode378 有序矩阵中第K小的元素

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

 

示例 1：

输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
示例 2：

输入：matrix = [[-5]], k = 1
输出：-5

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int row = matrix.length;
        int col = matrix[0].length;
        int left = matrix[0][0];
        int right = matrix[row-1][col-1];
        while(left<right){
            int mid = left+((right-left)>>1);
            //找出二维矩阵中<=mid的元素个数总个数
            int count = findNotBiggerThanMid(matrix,mid,row,col);
            if(count<k){
                //第k小的数在右半部分
                left = mid+1;
            }else{
                right = mid;
            }
        }
        return left;
    }
    public int findNotBiggerThanMid(int[][] matrix,int mid,int row,int col){
        //以列为单位，找到每一列最后一个<=mid的数即知道每一列有多少个数<=mid
        int i = row-1;
        int j = 0;
        int count = 0;
        while(i>=0&&j<col){
            if(matrix[i][j]<=mid){
                //第j列有i+1个元素<=mid
                count += i+1;
                j++;
            }else{
                //第j列目前的数大于mid，需要继续在当前列往上找
                i--;
            }
        }
        return count;
    }

}
```

### Leetcode006 Z字形变换

将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);


示例 1：

输入：s = "PAYPALISHIRING", numRows = 3
输出："PAHNAPLSIIGYIR"

```java
class Solution {
    public String convert(String s, int numRows) {
        if(numRows==1){
            return s;
        }
        // 将其转换为数组
        char[] arr = s.toCharArray();
        // 结果数组
        StringBuilder res = new StringBuilder();
        // 按行来求值
        for(int i=0;i<numRows;i++){
            // 对字符串求值
            for(int j=0;j<arr.length;j++){
                // 如果字符串中的索引符合当前行号
                if(j%(2*numRows-2)==i || j%(2*numRows-2)==2*numRows-2-i){
                    res.append(arr[j]);
                }
            }
        }
        return res.toString();
    }
}
```

### Leetcode73 矩阵置零

给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。

进阶：

一个直观的解决方案是使用  O(mn) 的额外空间，但这并不是一个好的解决方案。
一个简单的改进方案是使用 O(m + n) 的额外空间，但这仍然不是最好的解决方案。
你能想出一个仅使用常量空间的解决方案吗？


示例 1：


输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]
输出：[[1,0,1],[0,0,0],[1,0,1]]

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        boolean rowFlag = false;
        //判断首行
        for (int i = 0; i < matrix[0].length; i++) {
            if (matrix[0][i] == 0) {
                rowFlag = true;
                break;
            }
        }

        boolean colFlag = false;
        for (int i = 0; i < matrix.length; i++) {
            if (matrix[i][0] == 0) {
                colFlag = true;
                break;
            }
        }

        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0){
                    matrix[i][0] = 0;
                    matrix[0][j] = 0;
                }
            }
        }

        for (int i = 1; i < matrix[0].length; i++) {
            if (matrix[0][i] == 0) {
                for (int j = 0; j < matrix.length; j++) {
                    matrix[j][i] = 0;
                }
            }
        }

        for (int i = 1; i < matrix.length; i++) {
            if (matrix[i][0] == 0) {
                for (int j = 0; j < matrix[0].length; j++) {
                    matrix[i][j] = 0;
                }
            }
        }
        if (rowFlag){
            for (int i = 0; i < matrix[0].length; i++) {
                matrix[0][i] = 0;
            }
        }
        if (colFlag){
            for (int i = 0; i < matrix.length; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}
```

### 面试题10.09 排序矩阵查找

给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length<1) return false;
        int x = matrix.length-1;
        int y = 0;
        int length =matrix[0].length;
        while(x>=0&& y<length){
            //存在返回true
            if(matrix[x][y] == target) return true;
            //小于目标值右移
            else if(matrix[x][y] < target) y++;
            //大于目标值上移
            else if(matrix[x][y] > target) x--;
        }
        return false;
    }
}


```



## 反转字符串

### - - - 翻转 反转字符串单词

### [Leetcode557 反转字符串中的单词III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```java
class Solution {
    //反转字符串中的单词II
    public String reverseWords(String s) {
        //先分割
        String[] strs = s.split("\\s+");
        // 结果
        StringBuilder res = new StringBuilder();
        //对其处理
        for(int i=0;i<strs.length;i++){
            // 添加
            res.append(new StringBuilder(strs[i]).reverse().toString());
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```

### [Leetcode151 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。


示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

> 解题思路一、调用API

```java
class Solution {
    //使用split和reverse
    public String reverseWords(String s) {
        // 先对其分割成单词
        String[] words = s.trim().split("\\s+");
        //翻转 
        Collections.reverse(Arrays.asList(words));
        //对数组结果拼接
        return String.join(" ",words);
    }
}
```

**解题思路二、**

```java
class Solution {
    public String reverseWords(String s) {
        //分三步走
        // 先翻转整个数组
        // 再翻转单个单词
        //清除多余空格
        if(s==null){
            return null;
        }
        char[] s_arr = s.toCharArray();
        int n = s_arr.length;
        //第一步翻转这个数组
        reverse(s_arr,0,n-1);
        // 第二步翻转单个单词
        word_reversee(s_arr,n);
        // 第三步去除多余空格
        return clean_space(s_arr,n);
    }

    public void  reverse(char[] s_arr,int i,int j){
        while(i<j){
            char temp = s_arr[i];
            s_arr[i++] = s_arr[j];
            s_arr[j--] = temp;
        }
    }
    // 单词翻转
    public void word_reversee(char[] s_arr,int n){
        int i = 0;
        int j = 0;
        //结束条件
        while(j<n){
            //找到第一个的首字母
            while(i<n&&s_arr[i]==' ')i++;
            // 继续寻找
            j = i;
            while(j<n&&s_arr[j]!=' ')j++;
            reverse(s_arr,i,j-1);
            // 继续找
            i = j;
        }
    }

    // 去除多余的空格
    public String clean_space(char[] s_arr,int n){
        int i = 0;
        int j = 0;
        // 结束条件
        while(j<n){
            while(j<n&&s_arr[j]==' ')j++;
            while(j<n&&s_arr[j]!=' ')s_arr[i++] = s_arr[j++];
            while(j<n&&s_arr[j]==' ')j++;
            if(j<n)s_arr[i++] = ' ';
        }
        return new String(s_arr).substring(0,i);
    }

}
```

### Leetcode344 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

 

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

```java
class Solution {
    public void reverseString(char[] s) {
        int n = s.length;
        int left = 0;
        int right = n-1;
        while(left<right){
            char temp = s[left];
            s[left]  = s[right];
            s[right] = temp;
            // 继续走
            left++;
            right--;
        }
    }
}
```

递归

![image-20210819151904341](imgs\726.png)

### Leetcode7 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0){
            int digit = x%10;
            // 判断是否溢出
            if((res*10)/10!=res){
                return 0;
            }
            res = res*10+digit;
            x = x/10;
        }
        return res;
    }
}
```

### Leetcoode796 旋转字符串

给定两个字符串, A 和 B。

A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

示例 1:
输入: A = 'abcde', B = 'cdeab'
输出: true

示例 2:
输入: A = 'abcde', B = 'abced'
输出: false

```java
class Solution {
    public boolean rotateString(String A, String B) {
                return A.length() == B.length() && (A + A).contains(B);

    }
}

```

### 反转字符串中的单词

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```java
class Solution {
    //反转字符串中的单词II
    public String reverseWords(String s) {
        //先分割
        String[] strs = s.split("\\s+");
        // 结果
        StringBuilder res = new StringBuilder();
        //对其处理
        for(int i=0;i<strs.length;i++){
            // 添加
            res.append(new StringBuilder(strs[i]).reverse().toString());
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```

### Leetcode709 转换成小写字母

给你一个字符串 s ，将该字符串中的大写字母转换成相同的小写字母，返回新的字符串。

 

示例 1：

输入：s = "Hello"
输出："hello"
示例 2：

输入：s = "here"
输出："here"
示例 3：

输入：s = "LOVELY"
输出："lovely"

```java
class Solution {
    public String toLowerCase(String str) {
          if (str == null && "".equals(str)) {
            return null;
        }
        
        StringBuilder sb = new StringBuilder();
        for (char c : str.toCharArray()) {
            if (c >= 'A' && c <= 'Z') {
                sb.append((char)(c + 32));
            } else {
                sb.append(c);
            }
        }
        
        return sb.toString();
    }
}
```

### Leetcode917 仅仅反转字母

给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。

 

示例 1：

输入："ab-cd"
输出："dc-ba"
示例 2：

输入："a-bC-dEf-ghIj"
输出："j-Ih-gfE-dCba"
示例 3：

输入："Test1ng-Leet=code-Q!"
输出："Qedo1ct-eeLg=ntse-T!"

```java
class Solution {
    public String reverseOnlyLetters(String s) {
         char[] chars = s.toCharArray();
        int sIndex = 0, eIndex = chars.length - 1;
        while (sIndex < eIndex) {
            if (!Character.isLetter(chars[sIndex])) {
                sIndex++;
            }
            if (!Character.isLetter(chars[eIndex])) {
                eIndex--;
            }
            if (Character.isLetter(chars[sIndex]) &&   Character.isLetter(chars[eIndex])) {
                char temp = chars[sIndex];
                chars[sIndex] = chars[eIndex];
                chars[eIndex] = temp;
                sIndex++;
                eIndex--;
            }
        }
        return new String(chars);
    }
}
```



## 滑动窗口

### [NC82 滑动窗口的最大值](https://www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788?tpId=188&&tqId=38561&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。

例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。

窗口大于数组长度的时候，返回空

**示例1**

输入：

```
[2,3,4,2,6,2,5,1],3
```

复制

返回值：

```
[4,4,6,6,6,5]
```

```java
import java.util.*;
public class Solution {
    public ArrayList<Integer> maxInWindows(int [] nums, int k) {
        Deque<Integer> queue = new LinkedList<>();
        int len = nums.length;
        if(len==0 || k==0){
            return new ArrayList<>();
        }
        // 结果
        ArrayList<Integer> res = new ArrayList<>();
        int i = 0;
        while(i<len){
            // 开始
            while(!queue.isEmpty()&&nums[i]>nums[queue.peekLast()]){
                queue.pollLast();
            }
            // 存入其值
            queue.offerLast(i);
            // 判断是否过期
            if(k+queue.peekFirst()<=i){
                queue.pollFirst();
            }
            // 结果存储
            if(i+1>=k){
                res.add(nums[queue.peekFirst()]);
            }
            i++;
        }
        return res;
    }
}
```

### Leetcode239 滑动窗口最大值

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> queue = new LinkedList<>();
        int len = nums.length;
        //注意这个
        if(len==0 || k==0){
            return new int[]{};
        }
        // 结果
        int[] res = new int[len-k+1];
        int i = 0;
        while(i<len){
            // 开始
            while(!queue.isEmpty()&&nums[i]>nums[queue.peekLast()]){
                queue.pollLast();
            }
            // 存入其值
            queue.offerLast(i);
            // 判断是否过期
            if(k+queue.peekFirst()<=i){
                queue.pollFirst();
            }
            // 结果存储
            if(i+1>=k){
                res[i+1-k] = nums[queue.peekFirst()];
            }
            i++;
        }
        return res;
    }
}
```



### Leetcode727 最小窗口子序列

给定字符串 S and T，找出 S 中最短的（连续）子串 W ，使得 T 是 W 的 子序列 。

如果 S 中没有窗口可以包含 T 中的所有字符，返回空字符串 ""。如果有不止一个最短长度的窗口，返回开始位置最靠左的那个。

示例 1：

输入：
S = "abcdebdde", T = "bde"
输出："bcde"
解释：
"bcde" 是答案，因为它在相同长度的字符串 "bdde" 出现之前。
"deb" 不是一个更短的答案，因为在窗口中必须按顺序出现 T 中的元素。

```java
class Solution {
    public String minWindow(String S, String T) {
        int n = T.length();
        int m = S.length();
        int[][] dp = new int[S.length() + 1][T.length() + 1];
        //dp[i][j] length of minmum W of S:(0~i) ending with S[i]
        // that contains T[0 : j]
        S = "#" + S;
        T = "#" + T;
        for (int i = 1; i <= n; i++) {
            dp[0][i] = S.length() + 1;
        }
        for (int i = 1; i < dp.length; i++) {
            for (int j = 1; j < dp[0].length; j++) {
                if (S.charAt(i) == T.charAt(j)) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    // 这里 加1 是 i - 1包含了t ,  但是这里是已i结尾 ，所以 加上这个i的长度1
                    dp[i][j] = dp[i - 1][j] + 1;
                }
            }
        }
        int minLen = S.length() + 1;
        int pos = -1;
        for (int i = 1; i < dp.length; i++) {
            if (dp[i][n] < minLen) {
                minLen = dp[i][n];
                pos = i;
            }
        }
        if (minLen == S.length() + 1) {
            return "";
        }
        return S.substring(pos - minLen + 1, pos + 1);
    }
}
```

### Leetcode480 滑动窗口的中位数

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

窗口位置                      中位数
---------------               -----
[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        // 1.维护一个排过序的滑动窗口数组
        // 2.使用二分查找检索删除的索引
        // 3.将需要删除的值替换为需要插入的值
        // 4.使用局部冒泡排序保证数组顺序
        int len = nums.length;
        int[] windows = new int[k];
        // 结果
        double[] res = new double[len-k+1];
        //给初始化的滑动窗口赋值
        for(int i=0;i<k;i++){
            windows[i] = nums[i];
        }
        // 对其排序
        Arrays.sort(windows);
        // 二分查找中间的值
        res[0] = getMid(windows);
        // 遍历其它的
        for(int i=0;i<len-k;i++){
            // 获取要删除的索引
            int index = binarySearch(windows,nums[i]);
            // 删除即替换
            windows[index] = nums[i+k];
            // 重新排序
            while(index<windows.length-1&&windows[index]>windows[index+1]){
                // 交换
                swap(windows,index,index+1);
                index++;
            }
            while(index>0&&windows[index]<windows[index-1]){
                swap(windows,index,index-1);
                index--;
            }
            // 重新寻找中位数
            res[i+1] = getMid(windows);
        }
        // 返回其值
        return res;
    }

    // 交换
    public void swap(int[] windows,int left,int right){
        int temp = windows[left];
        windows[left] = windows[right];
        windows[right] = temp;
    }
    // 二分查找
    public int binarySearch(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            // 判断
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
               l = mid+1; 
            }
        }
        return -1;
    }

    // 求数组的中位数
    public double getMid(int[] windows){
        int len = windows.length;
        if(len%2==0){
            // 避免溢出
            return windows[len/2]/2.0 +windows[len/2-1]/2.0;
        }else{
            return windows[len/2];
        }
    }
}
```

### 剑指OfferII 041 滑动窗口的平均值

给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。

实现 MovingAverage 类：

MovingAverage(int size) 用窗口大小 size 初始化对象。
double next(int val) 成员函数 next 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size 个值的移动平均值，即滑动窗口里所有数字的平均值。


示例：

输入：
inputs = ["MovingAverage", "next", "next", "next", "next"]
inputs = [[3], [1], [10], [3], [5]]
输出：
[null, 1.0, 5.5, 4.66667, 6.0]

解释：
MovingAverage movingAverage = new MovingAverage(3);
movingAverage.next(1); // 返回 1.0 = 1 / 1
movingAverage.next(10); // 返回 5.5 = (1 + 10) / 2
movingAverage.next(3); // 返回 4.66667 = (1 + 10 + 3) / 3
movingAverage.next(5); // 返回 6.0 = (10 + 3 + 5) / 3

```java
class MovingAverage {
    int size;
    Queue<Integer> queue;
    public MovingAverage(int size) {
        this.size = size;
        queue = new LinkedList<>();
    }

    double total = 0;
    public double next(int val) {
        total += val;
        if (queue.size() < size) {
            queue.offer(val);
        } else {
            total -= queue.poll();
            queue.offer(val);
        }
        return total / queue.size();
    }
}

/**
 * Your MovingAverage object will be instantiated and called as such:
 * MovingAverage obj = new MovingAverage(size);
 * double param_1 = obj.next(val);
 */
```





## 二分算法

```java
public int binarySearch(int[] nums,int target){
    int left = 0, right=nums.length-1;
    while(left<=right){
        int mid = left + ((right-left)>>1);
        if(nums[mid]==target){
            return mid;
        }else if(nums[mid]>target){
            right = mid-1;
        }else if(nums[mid]<target){
            left  = mid+1;
        }
    }
    return -1;
}
```

### a.Leetcode035搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

输入: [1,3,5,6], 5
输出: 2
示例 2:

输入: [1,3,5,6], 2
输出: 1

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l+((r-l)>>1);
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
                l = mid+1;
            }
        }
        return -1;
    }
}
```

### b.Leetcode034在排序数组中查找第一个和最后第一的位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？


示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int l = binarySearchLeft(nums,target);
        int r = binarySearchRight(nums,target);
        return new int[]{l,r};
    }

    public int  binarySearchLeft(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]>=target){
                r = mid - 1;
            }else if(nums[mid]<target){
                l = mid + 1;
            }
        }
        if(l>=nums.length || nums[l]!=target){
            return -1;
        }
        return l;
    }

    public int binarySearchRight(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]>target){
                r = mid - 1;
            }else{
                l = mid +1;
            }
        }
        if(r<0 || nums[r]!=target){
            return -1;
        }
        return r;
    }
}
```

### c.Leetcode189 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

 

进阶：

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？


示例 1:

输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
示例 2:

输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        k = k%len;
        reverse(nums,0,len-1);
        reverse(nums,0,k-1);
        reverse(nums,k,len-1);
    }
    public void reverse(int[] nums,int i,int j){
        while(i<j){
            int temp = nums[i];
            nums[i]  = nums[j];
            nums[j]  = temp;
            i++;
            j--;
        }
    }
}
```

### d.Leetcode153 寻找旋转排序数组中的最小值

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

 

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
示例 2：

输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0;
        int r = nums.length-1;
        int mid = 0;
        while(l<=r){
            mid = l+((r-l)>>1);
            if(nums[mid]>=nums[r]){
                l = mid+1;
            }else if(nums[mid]<nums[r]){
                r = mid;
            }
        }
        return nums[mid];
    }
}
```

### e.Leetcode154 寻找旋转排序数组中的最小值II

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

 

示例 1：

输入：nums = [1,3,5]
输出：1
示例 2：

输入：nums = [2,2,2,0,1]
输出：0

```java
class Solution {
    public int findMin(int[] nums) {
        int l = 0;
        int r = nums.length-1;
        int mid = 0;
        while(l<=r){
            mid = l+((r-l)>>1);
            if(nums[mid]>nums[r]){
                l=mid+1;
            }else if(nums[mid]<nums[r]){
                r=mid;
            }else if(nums[mid]==nums[r]){
                r--;
            }
        }
        return nums[mid];
    }
}
```

### f.Leetcode033 搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
示例 2：

输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1

> 判断哪边有序

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l+((r-l)>>1);
            if(nums[mid]==target){
                return mid;
            }
            if(nums[mid]>=nums[l]){
                if(nums[l]<=target&&target<=nums[mid]){
                    r = mid-1;
                }else{
                    l = mid+1;
                }
            }else{
                if(nums[mid]<target&&target<=nums[r]){
                    l = mid+1;
                }else{
                    r = mid-1;
                }
            }
        }
        return -1;
    }
}
```

### g.搜索旋转排序数组II

已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。

给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。

 

示例 1：

输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
示例 2：

输入：nums = [2,5,6,0,0,1,2], target = 3
输出：false

```java
class Solution {
    public boolean search(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            while(l+1<=r&&nums[l]==nums[l+1]){
                l++;
            }
            while(r-1>=l&&nums[r]==nums[r-1]){
                r--;
            }
            int mid = l + ((r-l)>>1);
            if(nums[mid]==target){
                return true;
            }
            if(nums[mid]>=nums[l]){
                //判断
                if(nums[l]<=target&&target<nums[mid]){
                    r = mid-1;
                }else{
                    l = mid+1;
                }
            }else{
                if(nums[mid]<target&&target<=nums[r]){
                    l = mid+1;
                }else{
                    r = mid-1;
                }
            }
        }
        return false;
    }
}
```

### h.面试题10.03 搜索旋转数组

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

示例1:

 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
示例2:

 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
 输出：-1 （没有找到）

```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            if(nums[l]==target){
                return l;
            }
            int mid = l+ ((r-l)>>1);
            if(nums[mid]==target){
                r = mid;
            }else if(nums[mid]>nums[l]){
                if(nums[l]<=target&&target<nums[mid]){
                    r = mid-1;
                }else{
                    l = mid+1;
                }
            }else if(nums[mid]<nums[l]){
                if(nums[mid]<=target&&target<=nums[r]){
                    l = mid+1;
                }else{
                    r= mid-1;
                }
            }else if(nums[mid]==nums[l]){
                l++;
            }
        }
        return -1;
    }
}
```



## 排序（第k，合并区间，滑动窗口最大值，删除使其有序，排序数组，字典序，下一个排列，最大交换，自定义排序 版本号）

### [1.插入排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 插入排序
    public int[] sortArray(int[] nums) {
        for(int i=1;i<nums.length;i++){
            for(int j=i-1;j>=0&&nums[j]>nums[j+1];j--){
                // 交换两数
                swap(nums,j,j+1);
            }
        }
        return nums;
    }

    // 交换两数
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [2.冒泡排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 冒泡排序
    public int[] sortArray(int[] nums) {
        for(int i=nums.length-1;i>=0;i--){
            for(int j=0;j<i;j++){
                if(nums[j]>nums[j+1]){
                    swap(nums,j,j+1);
                }
            }
        }
        return nums;
    }

    // 交换两数
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [3.选择排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 选择排序
    public int[] sortArray(int[] nums) {
        for(int i=0;i<nums.length-1;i++){
            int minIndex = i;
            for(int j=i+1;j<nums.length;j++){
                minIndex = nums[minIndex]<nums[j]?minIndex:j;
            }
            // 交换
            swap(nums,i,minIndex);
        }
        return nums;
    }
    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [4.归并排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 归并排序
    public int[] sortArray(int[] nums) {
        mergeSort(nums,0,nums.length-1);
        return nums;
    }
    // 归并
    public void mergeSort(int[] nums,int l,int r){
        // 递归截止条件
        if(l>=r){
            return;
        }
        int mid = l+((r-l)>>1);
        mergeSort(nums,l,mid);
        mergeSort(nums,mid+1,r);
        merge(nums,l,mid,r);
    }
    // 合并
    public void merge(int[] nums,int l,int mid,int r){
        // 临时数组
        int[] temp = new int[r-l+1];
        int index = 0;
        int p1 = l;
        int p2 = mid+1;
        //开始
        while(p1<=mid&&p2<=r){
            temp[index++] = nums[p1]>=nums[p2]?nums[p2++]:nums[p1++];
        }
        while(p1<=mid){
            temp[index++] = nums[p1++];
        }
        while(p2<=r){
            temp[index++] = nums[p2++];
        }
        // 重新赋值
        for(int i=0;i<temp.length;i++){
            nums[l+i] = temp[i];
        }
    }
}
```



###  [5.快速排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 快速排序
    public int[] sortArray(int[] nums) {
        quickSort(nums,0,nums.length-1);
        return nums;
    }
    // 快速排序
    public void quickSort(int[] nums,int l,int r){
        if(l<r){
            // 随机排序
            swap(nums,r,l+(int)(Math.random()*(r-l+1)));
            int[] arr = sort(nums,l,r);
            quickSort(nums,l,arr[0]-1);
            quickSort(nums,arr[1]+1,r);
        }
    }
    // 排序
    public int[] sort(int[] nums,int L,int R){
        int less = L-1;
        int more = R;
        while(L<more){
            if(nums[L]>nums[R]){
                swap(nums,L,--more);
            }else if(nums[L]<nums[R]){
                swap(nums,L++,++less);
            }else{
                L++;
            }
        }
        // 交换两数
        swap(nums,more,R);
        return new int[]{less+1,more};
    }

    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [NC77 调整数组顺序使奇数位于偶数前面](https://www.nowcoder.com/practice/ef1f53ef31ca408cada5093c8780f44b?tpId=117&&tqId=37776&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)(荷兰国旗问题,重点在于顺序不变)

**描述**

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

**示例1**

输入：

```
[1,2,3,4]
```

复制

返回值：

```
[1,3,2,4]
```

复制

**示例2**

输入：

```
[2,4,6,5,7]
```

复制

返回值：

```
[5,7,2,4,6]
```



**该方法会使得数组的相对顺序改变**

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    public int[] reOrderArray (int[] nums) {
        // write code here
        //荷兰国旗问题
        int  less = -1;
        int L = 0;
        int more = nums.length;
        //开始比较
        while(L<more){
            if(nums[L]%2==1){
                swap(nums,++less,L++);
            }else{
                L++;
            }
        }
        return nums;
    }
    
    public void swap(int[] nums,int l,int r){
        int temp = nums[l];
        nums[l]  = nums[r];
        nums[r]  = temp;
    }
}
```

**不改变相对顺序**

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param array int整型一维数组 
     * @return int整型一维数组
     */
    //解题思路
/*（O(n),O(n)）
遍历两次数组，第一次只添加奇数到新数组里，第二次只添加奇数到新数组里
 */

    public int[] reOrderArray (int[] array) {
        int index = 0;
        int[] res = new int[array.length];
        for (int i : array) {
            if (i % 2 != 0) {
                res[index] = i;
                index++;
            }
        }
        for (int i : array) {
            if (i % 2 == 0) {
                res[index] = i;
                index++;
            }
        }
        return res;
    }
}
```

### [NC119 最小的K个数](https://www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf?tpId=188&&tqId=38570&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个数组，找出其中最小的K个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。

- 0 <= k <= input.length <= 10000
- 0 <= input[i] <= 10000

**示例1**

输入：

```
[4,5,1,6,2,7,3,8],4 
```

复制

返回值：

```
[1,2,3,4]
```

复制

说明：

```
返回最小的4个数即可，返回[1,3,2,4]也可以    
```

**优先级队列**

```java
import java.util.ArrayList;
import java.util.*;

public class Solution {
    public ArrayList<Integer> GetLeastNumbers_Solution(int [] input, int k) {
        ArrayList<Integer> res = new ArrayList<>();
        if(input==null||input.length==0||input.length < k || k==0){
            return res;
        }
        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->(b-a));
        int len = input.length;
        for(int i=0;i<len;i++){
            if(queue.size()!=k){
                queue.offer(input[i]);
            }else if(queue.peek()>input[i]){
                queue.poll();
                queue.offer(input[i]);
            }
        }
        for(Integer num:queue){
            res.add(num);
        }
        return res;
    }
}
```



**快速排序**

```java
class Solution {
    public int[] getLeastNumbers(int[] nums, int k) {
        quickSelect(nums,0,nums.length - 1,k);
        int[] res = new int[k];
        for(int i=0;i<k;i++){
            res[i] = nums[i];
        }
        return res;
    }
     public void quickSelect(int[] a, int l, int r, int index) {
        if(l>=r){
            return;
        }
        int q = partition(a, l, r);
        if(q == index) {
            return;
        }else if( q < index){
            quickSelect(a, q + 1, r, index);
        }else{
             quickSelect(a, l, q - 1, index);
        }
    }
    //有多少个元素比其小
    public int partition(int[] a, int l, int r) {
        int base = a[r], less = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= base) {
                swap(a, ++less, j);
            }
        }
        swap(a, less + 1, r);
        return less + 1;
    }
    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### [NC88 寻找第K大](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=188&&tqId=38572&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

有一个整数数组，请你根据快速排序的思路，找出数组中第 ![img](https://www.nowcoder.com/equation?tex=K%5C)大的数。

给定一个整数数组 ![img](https://www.nowcoder.com/equation?tex=a%5C),同时给定它的大小n和要找的 ![img](https://www.nowcoder.com/equation?tex=K(1%5Cleq%20K%5Cleq%20n)%5C)，请返回第 ![img](https://www.nowcoder.com/equation?tex=K%5C)大的数(包括重复的元素，不用去重)，保证答案存在。

要求时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n)%5C)

**示例1**

输入：

```
[1,3,5,2,2],5,3
```

复制

返回值：

```
2
```



```java
import java.util.*;

public class Solution {
    // 快速排序的思路寻找第k大的元素
    public int findKth(int[] a, int n, int K) {
        // write code here
        return quickSelect(a,0,n-1,n-K);
    }
    // 快速选择
    public int quickSelect(int[] a,int l,int r,int index){
        int q = partition(a,l,r);
        if(q==index){
            return a[q];
        }else{
            return q<index?quickSelect(a,q+1,r,index):quickSelect(a,l,q-1,index);
        }
    }
    
    public int partition(int[] a,int l,int r){
        int less = l-1;
        int base = a[r];
        for(int j=l;j<r;j++){
            if(a[j]<=base){
                swap(a,++less,j);
            }
        }
        swap(a,less+1,r);
        return less+1;
    }
    public void swap(int[] a,int i,int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### [NC111 最大数](https://www.nowcoder.com/practice/fc897457408f4bbe9d3f87588f497729?tpId=188&&tqId=38571&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个nums数组由一些非负整数组成，现需要将他们进行排列并拼接，每个数不可拆分，使得最后的结果最大，返回值需要是string类型，否则可能会溢出

提示:

1 <= nums.length <= 100

0 <= nums[i] <= 10000

**示例1**

输入：

```
[30,1]
```

复制

返回值：

```
"301"
```

复制

**示例2**

输入：

```
[2,20,23,4,8]
```

复制

返回值：

```
"8423220"
```

```java
import java.util.*;


public class Solution {
    /**
     * 最大数
     * @param nums int整型一维数组 
     * @return string字符串
     */
    public String solve (int[] nums) {
        // write code here
        //将其转换为string的数组
        int len = nums.length;
        String[] s_arr = new String[len];
        for(int i=0;i<len;i++){
            s_arr[i] = Integer.toString(nums[i]);
        }
        //排序
        Arrays.sort(s_arr,(s1,s2)->(  Integer.valueOf(s2+s1) - Integer.valueOf(s1+s2)  ));
        //判断
        if(s_arr[0].equals("0")){
            return "0";
        }
        //结果
        StringBuilder res = new StringBuilder();
        for(int i=0;i<len;i++){
            res.append(s_arr[i]);
        }
        return res.toString();
        
    }
}
```



### [NC97 字符串出现次数的topK问题](https://www.nowcoder.com/practice/fd711bdfa0e840b381d7e1b82183b3ee?tpId=188&&tqId=38637&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个字符串数组，再给定整数k，请返回出现次数前k名的字符串和对应的次数。

返回的答案应该按字符串出现频率由高到低排序。如果不同的字符串有相同出现频率，按字典序排序。

对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。

比如"ah1x"小于"ahb"，"231"<”32“

字符仅包含数字和字母



[要求]

如果字符串数组长度为N，时间复杂度请达到O(N \log K)*O*(*N*log*K*)

**示例1**

输入：

```
["a","b","c","b"],2
```

复制

返回值：

```
[["b","2"],["a","1"]]
```

复制

说明：

```
"b"出现了2次，记["b","2"]，"a"与"c"各出现1次，但是a字典序在c前面，记["a","1"]，最后返回[["b","2"],["a","1"]]
 
```

```java
import java.util.*;


public class Solution {
    /**
     * return topK string
     * @param strings string字符串一维数组 strings
     * @param k int整型 the k
     * @return string字符串二维数组
     */
    HashMap<String,Integer> dict = new HashMap<>();
    public String[][] topKstrings (String[] strings, int k) {
        // write code here
        for(String str:strings){
            dict.put(str,dict.getOrDefault(str,0)+1);
        }
        // 优先级队列
        PriorityQueue<String> queue = new PriorityQueue<>((a,b)->compareTo(a,b));
        // 维持一个小顶堆
        for(String key:dict.keySet()){
            if(k>queue.size()){
                queue.offer(key);
            }else if(compareTo(key,queue.peek())>0){
                queue.poll();
                queue.offer(key);
            }
        }
        // 结果
        String[][] res = new String[k][2];
        int index = k-1;
        while(!queue.isEmpty()){
            res[index][0] = queue.poll();
            res[index][1] = Integer.toString(dict.get(res[index][0]));
            index--;
        }        
        return res;
    }
    
    public int compareTo(String a,String b){
        Integer freqa = dict.get(a);
        Integer freqb = dict.get(b);
        if(freqa.equals(freqb)){
            return b.compareTo(a);
        }else{
            return Integer.compare(freqa,freqb);
        }
    }
}
```



### [NC22 合并两个有序的数组](https://www.nowcoder.com/practice/89865d4375634fc484f3a24b7fe65665?tpId=188&&tqId=38585&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给出一个整数数组 ![img](https://www.nowcoder.com/equation?tex=A%20%5C)和有序的整数数组 ![img](https://www.nowcoder.com/equation?tex=B%5C)，请将数组 ![img](https://www.nowcoder.com/equation?tex=B%5C)合并到数组 ![img](https://www.nowcoder.com/equation?tex=A%5C)中，变成一个有序的升序数组
注意：
1.可以假设 ![img](https://www.nowcoder.com/equation?tex=A%5C)数组有足够的空间存放 ![img](https://www.nowcoder.com/equation?tex=B%5C)数组的元素， ![img](https://www.nowcoder.com/equation?tex=A%5C)和 ![img](https://www.nowcoder.com/equation?tex=B%5C)中初始的元素数目分别为 ![img](https://www.nowcoder.com/equation?tex=m%5C)和 ![img](https://www.nowcoder.com/equation?tex=n%5C)，![img](https://www.nowcoder.com/equation?tex=A%5C)的数组空间大小为 ![img](https://www.nowcoder.com/equation?tex=m%5C)+ ![img](https://www.nowcoder.com/equation?tex=n%5C)

2.不要返回合并的数组，返回是空的，将数组 ![img](https://www.nowcoder.com/equation?tex=B%5C)的数据合并到![img](https://www.nowcoder.com/equation?tex=A%5C)里面就好了

3.![img](https://www.nowcoder.com/equation?tex=A%5C)数组在[0,m-1]的范围也是有序的

例1:

A: [4,5,6,0,0,0]，m=3

B: [1,2,3]，n=3

合并过后A为:

A: [1,2,3,4,5,6]

**示例1**

输入：

```
[4,5,6],[1,2,3]
```

复制

返回值：

```
[1,2,3,4,5,6]
```

复制

说明：

```
A数组为[4,5,6]，B数组为[1,2,3]，后台程序会预先将A扩容为[4,5,6,0,0,0]，B还是为[1,2,3]，m=3，n=3，传入到函数merge里面，然后请同学完成merge函数，将B的数据合并A里面，最后后台程序输出A数组       
```

```java
public class Solution {
    public void merge(int A[], int m, int B[], int n) {
        int index = A.length-1;
        int a1 = m-1;
        int b1 = n-1;
        while(a1>=0&&b1>=0){
            if(A[a1]>B[b1]){
                A[index--] = A[a1--];
            }else{
                A[index--] = B[b1--];
            }
        }
        while(b1>=0){
            A[index--] = B[b1--];
        }
    }
}
```







### [6.堆排序-Leetcode912 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```java
class Solution {
    // 堆排序
    public void slipDown(int[] nums,int parentIndex,int length){
        // 判断是否右孩子
        while(2*parentIndex+1<length){
            int childIndex = 2*parentIndex+1;
            if(childIndex+1<length&&nums[childIndex]<nums[childIndex+1]){
                childIndex = childIndex + 1;
            }
            // 结束条件
            if(nums[parentIndex]>nums[childIndex]){
                break;
            }
            // 交换
            swap(nums,parentIndex,childIndex);            
            parentIndex = childIndex;
        }
    }
    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
    public int[] sortArray(int[] nums) {
        // 建堆
        for(int i=nums.length/2;i>=0;i--){
            slipDown(nums,i,nums.length);
        }
        // 继续
        for(int i=nums.length-1;i>=0;i--){
            swap(nums,0,i);
            slipDown(nums,0,i);
        }

        return nums;

    }
}
```

### [7.自定义排序-Leetcode1387 将整数按权重排序](https://leetcode-cn.com/problems/sort-integers-by-the-power-value/)

我们将整数 x 的 权重 定义为按照下述规则将 x 变成 1 所需要的步数：

如果 x 是偶数，那么 x = x / 2
如果 x 是奇数，那么 x = 3 * x + 1
比方说，x=3 的权重为 7 。因为 3 需要 7 步变成 1 （3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）。

给你三个整数 lo， hi 和 k 。你的任务是将区间 [lo, hi] 之间的整数按照它们的权重 升序排序 ，如果大于等于 2 个整数有 相同 的权重，那么按照数字自身的数值 升序排序 。

请你返回区间 [lo, hi] 之间的整数按权重排序后的第 k 个数。

注意，题目保证对于任意整数 x （lo <= x <= hi） ，它变成 1 所需要的步数是一个 32 位有符号整数。

 

示例 1：

输入：lo = 12, hi = 15, k = 2
输出：13
解释：12 的权重为 9（12 --> 6 --> 3 --> 10 --> 5 --> 16 --> 8 --> 4 --> 2 --> 1）
13 的权重为 9
14 的权重为 17
15 的权重为 17
区间内的数按权重排序以后的结果为 [12,13,14,15] 。对于 k = 2 ，答案是第二个整数也就是 13 。
注意，12 和 13 有相同的权重，所以我们按照它们本身升序排序。14 和 15 同理。

> 解题思路：递归



```java
class Solution {
    public int getKth(int lo, int hi, int k) {
        List<Integer> list = new ArrayList<>();
        for(int i=lo;i<=hi;i++){
            list.add(i);
        }
        //排序
        Collections.sort(list,(a,b)->{
            if(getf(a)!=getf(b)){
                return getf(a)-getf(b);
            }else{
                return a-b;
            }
        });
        return list.get(k-1);
    }

    public int getf(int x){
        if(x==1){
            return 0;
        }else if((x&1)!=0){
            return getf(x*3+1)+1;
        }else{
            return getf(x/2)+1;
        }
    }
}
```

### [Leetcode031 下一个排列](https://leetcode-cn.com/problems/next-permutation/)

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

 

示例 1：

输入：nums = [1,2,3]
输出：[1,3,2]
示例 2：

输入：nums = [3,2,1]
输出：[1,2,3]

```java
class Solution {
    public void nextPermutation(int[] nums) {
        // 第一步先找到
        int firstIndex = -1;
        int len = nums.length;
        for(int i=len-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                firstIndex = i;
                break;
            }
        }
        // 没有找到
        if(firstIndex==-1){
            reverse(nums,0,len-1);
            return;
        }
        int secondIndex = -1;
        for(int i=len-1;i>=0;i--){
            if(nums[i]>nums[firstIndex]){
                secondIndex = i;
                break;
            }
        }
        swap(nums,firstIndex,secondIndex);
        reverse(nums,firstIndex+1,len-1);
        return;
    }

    public void reverse(int[] nums,int i,int j){
        while(i<j){
            swap(nums,i,j);
            i++;
            j--;
        }
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### Leetcode670 最大交换

给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。

示例 1 :

输入: 2736
输出: 7236
解释: 交换数字2和数字7。
示例 2 :

输入: 9973
输出: 9973
解释: 不需要交换。

```java
class Solution {
    public int maximumSwap(int num) {
        // 利用排序算法了
        char[] oldArr = Integer.toString(num).toCharArray();
        char[] sortArr = Integer.toString(num).toCharArray();
        // 排序算法
        int firstIndex = -1;
        int secondIndex = -1;
        Arrays.sort(sortArr);
        // 继续
        int n = oldArr.length;
        for(int i=0;i<n;i++){
            //判断
            if(oldArr[i]!=sortArr[n-i-1]){
                firstIndex = i;
                secondIndex = n-i-1;
                break;
            }
        }
        if(firstIndex==-1){
            return num;
        }
        // 继续
        for(int i=n-1;i>=0;i--){
            if(oldArr[i]==sortArr[secondIndex]){
                secondIndex = i;
                // 交换
                swap(oldArr,firstIndex,secondIndex);
                break;
            }
        }
        return Integer.valueOf(new String(oldArr));
    }

    public void swap(char[] nums,int i,int j){
        char temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### 数组中前k大的数字

### 1.数组中第K个最大元素

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return quickSelect(nums,0,nums.length - 1,nums.length - k);
    }
    public int quickSelect(int[] a, int l, int r, int index) {
        int q = partition(a, l, r);
        if (q == index) {
            return a[q];
        } else{
            return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);
        }
    }
    //有多少个元素比其小
    public int partition(int[] a, int l, int r) {
        int base = a[r], less = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= base) {
                swap(a, ++less, j);
            }
        }
        swap(a, less + 1, r);
        return less + 1;
    }
    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### 在两个长度相等的排序数组中找到中位数

**描述**

给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。

上中位数：假设递增序列长度为n，若n为奇数，则上中位数为第n/2+1个数；否则为第n/2个数

[要求]

时间复杂度为O(logN)*O*(*l**o**g**N*)，额外空间复杂度为O(1)*O*(1)

**示例1**

输入：

```
[1,2,3,4],[3,4,5,6]
```

复制

返回值：

```
3
```

复制

说明：

```
总共有8个数，上中位数是第4小的数，所以返回3。 
```

**示例2**

输入：

```
[0,1,2],[3,4,5]
```

复制

返回值：

```
2
```

复制

说明：

```
总共有6个数，那么上中位数是第3小的数，所以返回2 
import java.util.*;


public class Solution {
    /**
     * find median in two sorted array
     * @param arr1 int整型一维数组 the array1
     * @param arr2 int整型一维数组 the array2
     * @return int整型
     */
    public int findMedianinTwoSortedAray (int[] nums1, int[] nums2) {
        // write code here
        int n = nums1.length;
        int m = nums2.length;
        //
        int left = (n+m+1)/2;
        int right = (n+m+2)/2;
        return getKth(nums1,0,nums1.length-1,nums2,0,nums2.length-1,n);
    }
    
    public int getKth(int[] nums1,int start1,int end1,int[] nums2,int start2,int end2,int k){
        int len1 = end1-start1+1;
        int len2 = end2-start2+1;
        
        
        if(len1==0){
            return nums2[start2+k-1];
        }
        if(k==1){
            return Math.min(nums1[start1],nums2[start2]);
        }

        // 继续递归 新的索引
        int i = start1 + Math.min(len1,k/2) - 1;
        int j = start2 + Math.min(len2,k/2) - 1;
        if(nums1[i]>nums2[j]){
            return getKth(nums1,start1,end1,nums2,j+1,end2,k-(j-start2+1));
        }else{
            return getKth(nums1,i+1,end1,nums2,start2,end2,k-(i-start1+1));
        }
        
    }
}
```

### 

#### 剑指Offer40 最小的k个数

输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。

 

示例 1：

输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
示例 2：

输入：arr = [0,1,2,1], k = 1
输出：[0]

```java
class Solution {
    public int[] getLeastNumbers(int[] nums, int k) {
        quickSelect(nums,0,nums.length - 1,k);
        int[] res = new int[k];
        for(int i=0;i<k;i++){
            res[i] = nums[i];
        }
        return res;
    }
     public void quickSelect(int[] a, int l, int r, int index) {
        if(l>=r){
            return;
        }
        int q = partition(a, l, r);
        if(q == index) {
            return;
        }else if( q < index){
            quickSelect(a, q + 1, r, index);
        }else{
             quickSelect(a, l, q - 1, index);
        }
    }
    //有多少个元素比其小
    public int partition(int[] a, int l, int r) {
        int base = a[r], less = l - 1;
        for (int j = l; j < r; ++j) {
            if (a[j] <= base) {
                swap(a, ++less, j);
            }
        }
        swap(a, less + 1, r);
        return less + 1;
    }
    public void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

#### 剑指Offer II 076 数组中的第k大的数字

给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。

请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。

 

示例 1:

输入: [3,2,1,5,6,4] 和 k = 2
输出: 5
示例 2:

输入: [3,2,3,1,2,4,5,5,6] 和 k = 4
输出: 4


提示：

1 <= k <= nums.length <= 104
-104 <= nums[i] <= 104

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
		return quickSort(nums,nums.length-k,0,nums.length-1);
    }
	
	private int quickSort(int[] nums,int k,int l,int r){
		if(l>r) return 1;
		int piv=partition(nums,l,r);
		if(piv<k) return quickSort(nums,k,piv+1,r);
		else if(piv>k) return quickSort(nums,k,l,piv-1);
		else return nums[piv];
	}
	
	private int partition(int[] nums,int l,int r){
		int slow=l;
		for(int fast=l;fast<r;fast++){
			if(nums[fast]<nums[r]){
				swap(nums,fast,slow++);
			}
		}
		swap(nums,slow,r);
		return slow;
	}
	
	private void swap(int[] a,int l,int r){
		int t=a[l];
		a[l]=a[r];
		a[r]=t;
	}
}

```



#### 19.1 数组中第k大的数(Leetcode215)

首先想到最简单的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，然后返回第k大的元素，时间复杂度O(NlogN)。

**快排的patition思想** ：

时间复杂度O（n)，空间复杂度O(1)

```java
public class Solution {
    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        int left = 0;
        int right = len - 1;
        // 转换一下，第 k 大元素的索引是 len - k
        int target = len - k;

        while (true) {
            int index = partition(nums, left, right);
            if (index == target) {
                return nums[index];
            } else if (index < target) {
                left = index + 1;
            } else {
                right = index - 1;
            }
        }
    }

    /**
     * 在数组 nums 的子区间 [left, right] 
     执行 partition 操作，返回 nums[left] 排序以后应该在的位置
     * 在遍历过程中保持循环不变量的语义
     * 1、[left + 1, j] < nums[left]
     * 2、(j, i] >= nums[left]
     */
    public int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        int j = left;
        for (int i = left + 1; i <= right; i++) {
            if (nums[i] < pivot) {
                // 小于 pivot 的元素都被交换到前面
                j++;
                swap(nums, j, i);
            }
        }
        // 在之前遍历的过程中，满足 [left + 1, j] < pivot，
        //并且 (j, i] >= pivot
        swap(nums, j, left);
        // 交换以后 [left, j - 1] < pivot, nums[j] = pivot,
        // [j + 1, right] >= pivot
        return j;
    }

    private void swap(int[] nums, int index1, int index2) {
        int temp = nums[index1];
        nums[index1] = nums[index2];
        nums[index2] = temp;
    }
}
```

#### [NC88 寻找第K大](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=190&&tqId=35209&rp=1&ru=/ta/job-code-high-rd&qru=/ta/job-code-high-rd/question-ranking)

**描述**

有一个整数数组，请你根据快速排序的思路，找出数组中第 ![img](https://www.nowcoder.com/equation?tex=K%5C)大的数。

给定一个整数数组 ![img](https://www.nowcoder.com/equation?tex=a%5C),同时给定它的大小n和要找的 ![img](https://www.nowcoder.com/equation?tex=K(1%5Cleq%20K%5Cleq%20n)%5C)，请返回第 ![img](https://www.nowcoder.com/equation?tex=K%5C)大的数(包括重复的元素，不用去重)，保证答案存在。

要求时间复杂度 ![img](https://www.nowcoder.com/equation?tex=O(n)%5C)

**示例1**

输入：

```
[1,3,5,2,2],5,3
```

复制

返回值：

```
2
```

```java
import java.util.*;

public class Solution {
    // 快速排序的思路寻找第k大的元素
    public int findKth(int[] a, int n, int K) {
        // write code here
        return quickSelect(a,0,n-1,n-K);
    }
    // 快速选择
    public int quickSelect(int[] a,int l,int r,int index){
        int q = partition(a,l,r);
        if(q==index){
            return a[q];
        }else{
            return q<index?quickSelect(a,q+1,r,index):quickSelect(a,l,q-1,index);
        }
    }
    
    public int partition(int[] a,int l,int r){
        int less = l-1;
        int base = a[r];
        for(int j=l;j<r;j++){
            if(a[j]<=base){
                swap(a,++less,j);
            }
        }
        swap(a,less+1,r);
        return less+1;
    }
    public void swap(int[] a,int i,int j){
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```



#### 19.2 topK 返回前k大的元素

这里可以使用和上题一样的快排patition。   

​    也可以用堆[排序]()，可以取前k个元素构造小根堆，然后遍历后面的元素，如果读取到的元素比堆顶下，直接丢弃，如果比堆顶大，就替换掉堆顶元素，然后调整堆。时间复杂度O(NlogK)。

```java
public class Solution {
    public ArrayList<Integer> topK(int[] nums){
        if(nums.length <= k) return nums;
        int n = nums.length;
        int left = 0;
        int right = n - 1;
        int target = n - k;
        int index = 0;
        while(true){
            index = partition(nums,left,right)
            if(index == target){
                break; 
            }else if(index < target{
                left = index + 1;
            }else{
                right = index - 1;
            }
        }
        ArrayList<Integer> list = new ArrayList<>();
        for(int i = target;i < n;i++){
            list.add(nums[i]);
        }
        return list;
    }
    public int pattition(int[] nums,int left,int right){
        int pivot = nums[left];
        int j =left;
       for(int i = left + 1;i <= right;i++){
           if(nums[i] > pivot){
               j++;
               swap(nums,i,j);
           }
       }
       swap(nums,left,j);
       return j;
    }
    public void swap(int nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] =temp;
    }
}
```

#### Leetcode字符串出现次数的topK问题

链接：https://www.nowcoder.com/questionTerminal/fd711bdfa0e840b381d7e1b82183b3ee
来源：牛客网



给定一个字符串数组，再给定整数k，请返回出现次数前k名的字符串和对应的次数。 

  返回的答案应该按字符串出现频率由高到低排序。如果不同的字符串有相同出现频率，按字典序排序。 

  对于两个字符串，大小关系取决于两个字符串从左到右第一个不同字符的 ASCII 值的大小关系。 

  比如"ah1x"小于"ahb"，"231"<”32“


  字符仅包含数字和字母 



   [要求]  

   如果字符串数组长度为N，时间复杂度请达到O(Nlog⁡K)O(N \log K)O(NlogK)    

示例1

**输入**

```
["a","b","c","b"],2
```

**输出**

```
[["b","2"],["a","1"]]
```

**说明**

```
"b"出现了2次，记["b","2"]，"a"与"c"各出现1次，但是a字典序在c前面，记["a","1"]，最后返回[["b","2"],["a","1"]]
 
```

示例2

**输入**

```
["123","123","231","32"],2
```

**输出**

```
[["123","2"],["231","1"]]
```

**说明**

```
 "123"出现了2次，记["123","2"]，"231"与"32"各出现1次，但是"231"字典序在"32"前面，记["231","1"]，最后返回[["123","2"],["231","1"]] 
```

```java
import java.util.*;


public class Solution {
    /**
     * 题意要求是TopK问题，时间复杂度达到O(NlogK)，并且相同大小要按字典排序，
     * 所以排序方法应该是堆排序或者快速选择排序。
     * 这里排序使用小顶堆，按值排序时是从小到大。当值相同时，比较str，这里重写堆节点的比较方法，
     * 值相同时，str字典序大的先入堆。
     * 最后，排序好的小顶堆输出k个数到结果集，结果集数组从尾部开始填充，
     * 这样小顶堆的数据刚好逆序，在结果集里的表现就是 按值排序是升序，值相同是字典小的在数组前面。
     * return topK string
     * @param strings string字符串一维数组 strings
     * @param k int整型 the k
     * @return string字符串二维数组
     */
    public String[][] topKstrings (String[] strings, int k) {
       
        if(strings==null || strings.length==0){
            return null;
        }
        
        HashMap<String,Integer> map = new HashMap();
        for(String s : strings){
            //初始化 数组中每个字符串默认出现一次
            map.put(s,map.getOrDefault(s,0)+1);
        }
        
        // 优先队列，实现小顶堆，输出到结果集就是堆的逆序,即倒序输出小顶堆，即大顶堆
        //https://blog.csdn.net/wufaliang003/article/details/82940218参考最小堆的思想
        PriorityQueue<Node> minHeap = new PriorityQueue();
        for(Map.Entry<String,Integer> entrySet : map.entrySet()){
            Node node = new Node(entrySet.getKey(),entrySet.getValue());
            //先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。
            if(minHeap.size() < k){
                minHeap.add(node);
            }else{
                // 堆中元素等于 k 个时
                // 当 node的值大于栈顶元素，或者值相同时node的字典小于栈顶元素 时(最小堆构建规则,就是如此)
                //这相当于上一个条件:先用前k个元素生成一个小顶堆，这个小顶堆用于存储，当前最大的k个元素。
                //接着，从第k+1个元素开始扫描，和堆顶（堆中最小的元素）比较，如果被扫描的元素大于堆顶，则替换堆顶的元素，并调整堆，
                //以保证堆内的k个元素，总是当前最大的k个元素。
                if(minHeap.peek().compareTo(node) < 0){
                    minHeap.poll();
                    minHeap.add(node);
                }
            }
        }
        
        String[][] result = new String[k][2];
        //正序弹出小顶堆上面的元素,数组逆序输出
        for(int i=k-1;i>=0;i--){
            Node node = minHeap.poll();
            result[i][0] = node.name;
            result[i][1] = String.valueOf(node.count); 
        }
        return result;
    }
    
    class Node implements Comparable<Node>{
        
        //对应上面Map里的key
        String name;
        //对应上面Map里的value
        int count;
        
        public Node(String name,int count){
            this.name = name;
            this.count = count;
        }
        
        @Override
        public int compareTo(Node node){
            //正常是通过Node对象里的count来比较大小的
            if(this.count > node.count){
                return 1;
            }else if(this.count < node.count){
                return -1;
            }else{
                //比如["2","2","1","1"]的情况 数组中字符串2出现2次 字符串1出现2次 这时候要求按字典顺序输出["1","2"]、["2","2"]1出现2次 2出现2次
                //此时使用原生的比较器 用2个Node对象的string进行字典顺序比较
                //上面的2个条件比较对象是堆顶的元素 被比较对象是要是否加入替代堆顶最小元素的元素 用的是count大小做比较
                //但此时Node值相同,应该比较的是要加入的node的name字典值,小于栈顶元素 才会重新进行构建最小堆 应该反过来比较
                return node.name.compareTo(this.name);
            }
        }
    }
}
```



#### [Leetcode347 前K个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。

 

示例 1:

输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
示例 2:

输入: nums = [1], k = 1
输出: [1]

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        // 统计dict
        HashMap<Integer,Integer> dict = new HashMap<>();
        for(int num:nums){
            dict.put(num,dict.getOrDefault(num,0)+1);
        }
        // 堆排序 字典序 从频率小到频率大 小顶堆
        PriorityQueue<Integer> queue = new PriorityQueue((a,b)->(dict.get(a)-dict.get(b)));
        // 遍历
        for(Integer key:dict.keySet()){
            //判断
            if(queue.size()<k){
                queue.offer(key);
            }else if(dict.get(queue.peek())<dict.get(key)){
                //更新
                queue.poll();
                queue.offer(key);
            }
        }
        // 结果
        int[] res = new int[k];
        for(int i=0;i<k;i++){
            res[i] = queue.poll();
        }
        return res;
    }
}
```

#### [Leetcode440 字典序的第K小的数字](https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/)

给定整数 n 和 k，找到 1 到 n 中字典序第 k 小的数字。

注意：1 ≤ k ≤ n ≤ 109。

示例 :

输入:
n: 13   k: 2

输出:
10

解释:
字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。

```java
class Solution {
    public int findKthNumber(int n, int k) {
        int cur = 1;
        k--;
        while (k > 0) {
            long step = 0, first = cur, last = cur + 1;
            while (first <= n) {
                step += Math.min(last, (long) (n + 1)) - first;
                first *= 10;
                last *= 10;
            }

            if (step > k) {
                //在树里
                k--;
                cur *= 10;
            }
            if (step <= k) {
                //不在树里
                k -= step;
                ++cur;
            }
        }
        return cur;
    }
}
```

#### 19.3 10亿个数，取最小的100个数





\1.   最大堆   ：   

​    先取出前100个数，维护一个100个数的最大堆，遍历一遍剩余的元素，在此过程中维护这个最大堆就可以了。   

​    具体步骤如下：   

​    step1：取前m个元素（例如m=100），建立一个大根堆。保持一个大根堆得性质的步骤，运行时间为O（logm);建立一个大根堆运行时间为mO(logm）=O(m logm);   

​    step2:   顺序读取后续元素，直到结束   。每次读取一个元素，如果该元素比堆顶元素大，直接丢弃；如果小于堆顶元素，则用该元素替换堆顶元素，然后保持最大堆性质。最坏情况是每次都需要替换掉堆顶的最大元素，因此需要维护堆的代价为(N-m)O(lgm); 最后这个堆中的元素就是前最小的100个。时间复杂度为O(N lgm）。   

​    时间复杂度为O(10亿*lg100)。

```java
//构建大根堆：将array看成完全二叉树的顺序存储结构
private int[] buildMaxHeap(int[] array) {
    //从最后一个节点array.length-1的父节点（array.length-1-1）/2开始，
    //直到根节点0，反复调整堆
    for (int i = (array.length - 2) / 2; i >= 0; i--) {
        adjustDownToUp(array, i, array.length);
    }
    return array;
}
//将元素array[k]自下往上逐步调整树形结构
private void adjustDownToUp(int[] array, int k, int length) {
    int temp = array[k];
    for (int i = 2 * k + 1; i < length - 1; i = 2 * i + 1) {    
    //i为初始化为节点k的左孩子，沿节点较大的子节点向下调整
        if (i < length && array[i] < array[i + 1]) {  
        //取节点较大的子节点的下标
            i++;   //如果节点的右孩子>左孩子，则取右孩子节点的下标
        }
        if (temp >= array[i]) {  //根节点 >=左右子女中关键字较大者，调整结束
            break;
        } else {   //根节点 <左右子女中关键字较大者
            array[k] = array[i]; //将左右子结点中较大值array[i]调整到双亲节点上
            k = i; //【关键】修改k值，以便继续向下调整
        }
    }
    array[k] = temp;  //被调整的结点的值放人最终位置
}
```

```java
//堆排序
public int[] heapSort(int[] array) {
    array = buildMaxHeap(array); //初始建堆，array[0]为第一趟值最大的元素
    for (int i = array.length - 1; i > 1; i--) {
        int temp = array[0];  //将堆顶元素和堆底元素交换，即得到当前最大元素正确的排序位置
        array[0] = array[i];
        array[i] = temp;
        adjustDownToUp(array, 0, i);  //整理，将剩余的元素整理成堆
    }
    return array;
}
```

```java
public int[] findMin(int[] array,int[] all){
    array = buildMaxHeap(array);
    //前面100个数字（0-99号）已经取出了
    for(int i = 100;i <  all.length - 1; i++){
        if(all[i] >= array[0]){
            continue;
        } else {
            array[0] = all[i];
            adjustDownToUp(array,0,array.length);
        }    
    }
    return array;
}
```





\2.   快排划分   的思想：   

​    每次分割之后只考虑比轴小的一部分，直到比轴小的一部分数量在100多个的时候，采用传统[排序]()[算法]()[排序]()，取前100个。   

​    step1：递归对所有数据分成[a,b)，(b,d]两个区间，[a,b)区间内的数都是小于(b,d]区间内的数。   

​    step2：对[a,b)重复 step1操作，直到最左边的区间个数小于100个。注意(b,d]区间不用划分   

​    step3：   返回上一个区间   ，并返回此区间的数字数目。接着方法仍然是对上一区间的左边进行划分，分为[a2,b2)，(b2,d2]两个区间，取(a2,b2]区间。如果个数不够，继续 step3操作，如果个数超过100的就重复 step1操作，直到最后右边只有100个数为止。   

​    复杂度为O(10亿*100)

#### 6.两个有序数组的topK问题

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组 

  按照降序输出 

  [要求] 

  时间复杂度为O(klog⁡k)O(k \log k)O(klogk)  

**输入描述:**

```
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
```

**输出描述:**

```
输出K个整数表示答案
```

示例1

**输入**

```
5 4
1 2 3 4 5
3 5 7 9 11
```

**输出**

```
16 15 14 14
```

```java
import java.util.*;
public class Main {
    //放入大根堆中的结构
    static class Node {
        public int index1;  //arr1中的位置
        public int index2;  //arr2中的位置
        public int sum;     //arr1[index1]+arr2[index2]
        public Node(int i1, int i2, int s) {
            index1 = i1;
            index2 = i2;
            sum = s;
        }
    }

    public static int[] topKSum(Integer[] arr1, Integer[] arr2, int topK) {
        if (arr1 == null || arr2 == null || topK < 1) {
            return null;
        }
        topK = Math.min(topK, arr1.length * arr2.length);
        int[] res = new int[topK];
        int resIndex = 0;
        //自定义比较器，实现大根堆
        PriorityQueue<Node> maxHeap = new PriorityQueue<>((N1, N2) -> N2.sum - N1.sum);
        // set[i][j] == false , arr1[i] arr2[j] 之前没进过堆
        // set[i][j] == true , arr1[i] arr2[j] 之前进过堆
        //boolean[][] set = new boolean[arr1.length][arr2.length];
        //使用hashset解决超内存问题
        HashSet<String> positionSet = new HashSet<>();
        //从右下角开始
        int i1 = arr1.length - 1;
        int i2 = arr2.length - 1;
        maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
        //set[i1][i2] = true;
        positionSet.add(i1 + "_" + i2);
        while (resIndex != topK) {
            Node curNode = maxHeap.poll();
            res[resIndex++] = curNode.sum;
            i1 = curNode.index1;
            i2 = curNode.index2;
//            if (i1 - 1 >= 0 && set[i1 - 1][i2] == false) {
//                set[i1 - 1][i2] = true;
//                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
//            }
//            if (i2 - 1 >= 0 && set[i1][i2 - 1] == false) {
//                set[i1][i2 - 1] = true;
//                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
//            }
            if (i1 - 1 >= 0 && !positionSet.contains(i1 - 1 + "_" + i2)) {
                positionSet.add(i1 - 1 + "_" + i2);
                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
            }
            if (i2 - 1 >= 0 && !positionSet.contains(i1 + "_" + (i2 - 1))) {
                positionSet.add(i1 + "_" + (i2 - 1));
                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
            }
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        Integer[] arr1 = new Integer[n];
        Integer[] arr2 = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = in.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arr2[i] = in.nextInt();
        }
        //要将输入的两个数字排序
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        int[] res = topKSum(arr1, arr2, k);
        for (int re : res) {
            System.out.print(re + " ");
        }
    }
}
```

#### [Leetcode题解]从两个有序数组的并集中寻找第k小元素

不得不承认这道题目解决起来非常的巧妙。像大多数难题一样，需要经过非常巧妙的观察才可以用简洁的方式求解。

**朴素解法, O(m+n):**

将两个数组进行合并，然后寻找第k小的元素可能非常直观。合并操作需要花费额外的O(m + n)的空间。线性运行时间已经很好了，但我们还能再做一些优化吗？

**朴素解法的优化, O(k):**

上面的方法可以这样优化，在此感谢提出该方法的读者Martin。

```java
int findKthSMallest(int[] A, int[] B, int k) {
    int a_offset = 0, b_offset = 0;
    if (A.length + B.length < k) return -1;
 
    while (true) {
        if (a_offset < A.length) {
            while (b_offset == B.length ||
                A[a_offset] <= B[b_offset]) {
                a_offset++;
                if (a_offset + b_offset == k) return A[a_offset];
            }
        }
        if (b_offset < B.length) {
            while (a_offset == A.length ||
                A[a_offset] >= B[b_offset]) {
                b_offset++;
            }
            if (a_offset + b_offset == k) return B[b_offset];
        }
    }
}

```

**最佳解法, O(log m + log n):**

尽管上面的解法在时间和空间复杂度上都有了提升，但是仍然只能处理较小的k值，并且仍然是线性时间算法。我们还能再做优化吗？

上面的对数复杂度给了我们一个重要的提示。二分查找是对数复杂度算法的很好的例子，每次迭代时将查找空间折半。因此，为了达到O(logm + logn)的复杂度，我们必须在每轮迭代时将A和B的查找空间折半。

我们可以从比较A和B的中间元素出发解决这个比较棘手的问题，我们将这两个元素记为Ai和Bj。如果Ai在Bj和Bj-1之间，我们就恰好找到了第i+j+1小的元素。想想这是为什么。因此，如果我们选出i和j，使得i + j = k - 1，我们就可以找到第k小的元素。这是解决此问题的一个重要的等式变形。

总结一下上面的思路，

```
维护等式，
i + j = k – 1,
如果 Bj-1 < Ai < Bj, 那么 Ai 就是第k小的元素,
否则，如果 Ai-1 < Bj < Ai, 那么 Bj 就是第k小的元素
```

如果满足了上面的条件之一，我们就完成了问题的求解。如果没有满足，我们再使用i和j作为枢轴对数组进行划分。但是怎样做呢？我们应该舍弃哪一部分？还有Ai和Bj自己应当怎样处理？

```java
int findKthSmallest(int A[], int m, int B[], int n, int k) {
  assert(m >= 0); assert(n >= 0); assert(k > 0); assert(k <= m+n);
  
  int i = (int)((double)m / (m+n) * (k-1));
  int j = (k-1) - i;
 
  assert(i >= 0); assert(j >= 0); assert(i <= m); assert(j <= n);
  // invariant: i + j = k-1
  // Note: A[-1] = -INF and A[m] = +INF to maintain invariant
  int Ai_1 = ((i == 0) ? INT_MIN : A[i-1]);
  int Bj_1 = ((j == 0) ? INT_MIN : B[j-1]);
  int Ai   = ((i == m) ? INT_MAX : A[i]);
  int Bj   = ((j == n) ? INT_MAX : B[j]);
 
  if (Bj_1 < Ai && Ai < Bj)
    return Ai;
  else if (Ai_1 < Bj && Bj < Ai)
    return Bj;
 
  assert((Ai > Bj && Ai_1 > Bj) || 
         (Ai < Bj && Ai < Bj_1));
 
  // if none of the cases above, then it is either:
  if (Ai < Bj)
    // exclude Ai and below portion
    // exclude Bj and above portion
    return findKthSmallest(A+i+1, m-i-1, B, j, k-i-1);
  else /* Bj < Ai */
    // exclude Ai and above portion
    // exclude Bj and below portion
}
```

#### [5.Leetcode373 查找和最小的top k对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。

找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。

示例 1:

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
示例 2:

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        //构建数组对
        List<List<Integer>> res = new ArrayList<>();
        // 大顶堆
        PriorityQueue<int[]> queue = new PriorityQueue<>(k,((a,b)->compare(a,b)));
        // 开始
        for(int i:nums1){
            for(int j:nums2){
                int[] arr = new int[]{i,j};
                if(k>queue.size()){
                    queue.offer(arr);
                }else if(compare(arr,queue.peek())>0){
                    queue.poll();
                    queue.offer(arr);
                }
            }
        }
        // 结果
        while(!queue.isEmpty()){
            int[] poll = queue.poll();
            res.add(0,Arrays.asList(poll[0],poll[1]));
        }
        return res;
    }
    // 定义比较函数
    private int compare(int[] arr1,int[] arr2){
        return (arr2[0]+arr2[1])-(arr1[0]+arr1[1]);
    }
}
```

#### 20.有序数组间相加和的topk问题

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组 

  按照降序输出 

  [要求] 

  时间复杂度为O(klog⁡k)O(k \log k)O(klogk)  

**输入描述:**

```
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
```

**输出描述:**

```
输出K个整数表示答案
```

示例1

**输入**

```
5 4
1 2 3 4 5
3 5 7 9 11
```

**输出**

```
16 15 14 14
```

```java
import java.util.*;
public class Code04_TopKSumCrossTwoArrays {

    public static class Node {
        int x;
        int y;
        int sum;
        public Node(int x, int y, int sum) {
            this.x = x;
            this.y = y;
            this.sum = sum;
        }
    }
    public static class MaxHeapComp implements Comparator<Node> {
        @Override
        public int compare(Node o1, Node o2) {
            return o2.sum - o1.sum;
        }
    }

    public static int[] topKSum(int[] arr1, int[] arr2, int topK) {
        if (arr1 == null || arr2 == null || topK < 1) return null;
        topK = Math.min(topK, arr1.length * arr2.length);
        int[] res = new int[topK];
        int resIndex = 0;
        // 建立大根堆
        PriorityQueue<Node> maxHeap = new PriorityQueue<>(new MaxHeapComp());
        boolean[][] visit = new boolean[arr1.length][arr2.length];
        int i1 = arr1.length - 1;
        int i2 = arr2.length - 1;
        // 初始化队列
        maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
        visit[i1][i2] = true;
        while (resIndex != topK) {
            Node curNode = maxHeap.poll();
            if (curNode == null) break;
            res[resIndex] = curNode.sum;
            i1 = curNode.x;
            i2 = curNode.y;
            if (i1 - 1 >= 0 && !visit[i1-1][i2]) {
                visit[i1-1][i2] = true;
                maxHeap.add(new Node(i1 - 1, i2, arr1[i1-1] + arr2[i2]));
            }
            if (i2 - 1 >= 0 && !visit[i1][i2-1]) {
                visit[i1][i2-1] = true;
                maxHeap.add(new Node(i1, i2-1, arr1[i1] + arr2[i2-1]));
            }
            resIndex++;
        }
        return res;
    }
    public static void main(String[] args) {
        int n, k;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        k = sc.nextInt();
        int[] arr1 = new int[n];
        int[] arr2 = new int[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arr2[i] = sc.nextInt();
        }
        int[] res = topKSum(arr1, arr2, k);
        for (int i = 0; i < res.length; i++) {
            if (i == 0) System.out.print(res[i]);
            else System.out.print(" " + res[i]);
        }
        System.out.println();
    }
}

```

#### 面试题17.09 第K个数

有些数的素因子只有 3，5，7，请设计一个算法找出第 k 个数。注意，不是必须有这些素因子，而是必须不包含其他的素因子。例如，前几个数按顺序应该是 1，3，5，7，9，15，21。

示例 1:

输入: k = 5

输出: 9

```java
class Solution {
   /**
     * 题目分析：
     *  由题意的，某一个满足结果的数，一定是之前的某个 resultA*3 或者是 resultB*5 或者是 resultC*7 的结果
     *  并且结果一定是 这三个乘积的最小值，
     *  因此，只要能够记录 resultA、resultB、resultC 的值，再相互与 3、5、7 相乘，取其中的最小值，就是当前的目标值！
     *  需要注意，resultA、B、C 是不断变化的，并且都应该是由小到大，谁被选中，就应该取下一个值！
     *      例如 3 就是 resultA=1 的结果，此时 B、C 都等于 1，此后 resultA 取下一个值 3 
     *      例如 5 就是 resultB=1 的结果，此时 resultA=3，resultC=1，此后 resultB 取下一个值 3
     *      例如 7 就是 resultC=1 的结果，此时 resultA、resultB 都等于 3，此后 resultC 取下一个值 3
     *      例如 15 就是 resultA=5 或者是 resultB=3 的结果，此时 resultC=7，此后 resultA 取下一个值 7 ，resultB 取下一个值 5
     *      自己在纸上多画画，就明白了！
     * @param k
     * @return
     */
    public int getKthMagicNumber(int k) {
        int [] result = new int[k];
        result[0] = 1;
        // 定义三个 指针，分别表示 resultA、B、C 的下标
        int point3 = 0;
        int point5 = 0;
        int point7 = 0;
        for (int i = 1; i < k; i++) {
            int resultN = Math.min(Math.min(result[point3] * 3, result[point5] * 5), result[point7] * 7);
            if (resultN % 3 == 0) {
                point3++;
            }
            if (resultN % 5 == 0) {
                point5++;
            }
            if (resultN % 7 == 0) {
                point7++;
            }
            result[i] = resultN;
        }
        return result[k - 1];
    }
}
```

#### Leetcode15399 第k个缺失的正整数

给你一个 严格升序排列 的正整数数组 arr 和一个整数 k 。

请你找到这个数组里第 k 个缺失的正整数。

 

示例 1：

输入：arr = [2,3,4,7,11], k = 5
输出：9
解释：缺失的正整数包括 [1,5,6,8,9,10,12,13,...] 。第 5 个缺失的正整数为 9 。
示例 2：

输入：arr = [1,2,3,4], k = 2
输出：6
解释：缺失的正整数包括 [5,6,7,...] 。第 2 个缺失的正整数为 6 。

```java
class Solution {
     public int findKthPositive(int[] arr, int k) {
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            if (arr[i] - i - 1 >= k) {
                return k + i;
            }
        }
        return k + n;
    }
}
```





### 数组中字典中最大比较大的（有个竞争力的）

#### [NC111 最大数](https://www.nowcoder.com/practice/fc897457408f4bbe9d3f87588f497729?tpId=188&&tqId=38571&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个nums数组由一些非负整数组成，现需要将他们进行排列并拼接，每个数不可拆分，使得最后的结果最大，返回值需要是string类型，否则可能会溢出

提示:

1 <= nums.length <= 100

0 <= nums[i] <= 10000

**示例1**

输入：

```
[30,1]
```

复制

返回值：

```
"301"
```

复制

**示例2**

输入：

```
[2,20,23,4,8]
```

复制

返回值：

```
"8423220"
```

```java
import java.util.*;


public class Solution {
    /**
     * 最大数
     * @param nums int整型一维数组 
     * @return string字符串
     */
    public String solve (int[] nums) {
        // write code here
        //将其转换为string的数组
        int len = nums.length;
        String[] s_arr = new String[len];
        for(int i=0;i<len;i++){
            s_arr[i] = Integer.toString(nums[i]);
        }
        //排序
        Arrays.sort(s_arr,(s1,s2)->(  Integer.valueOf(s2+s1) - Integer.valueOf(s1+s2)  ));
        //判断
        if(s_arr[0].equals("0")){
            return "0";
        }
        //结果
        StringBuilder res = new StringBuilder();
        for(int i=0;i<len;i++){
            res.append(s_arr[i]);
        }
        return res.toString();
        
    }
}
```

#### [Leetcode402 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。


示例 1 ：

输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
示例 2 ：

输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 ：

输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。

```java
class Solution {
    public String removeKdigits(String num, int k) {
        Deque<Character> deque = new LinkedList<Character>();
        int length = num.length();
        for (int i = 0; i < length; ++i) {
            char digit = num.charAt(i);
            while (!deque.isEmpty() && k > 0 && deque.peekLast() > digit) {
                deque.pollLast();
                k--;
            }
            deque.offerLast(digit);
        }
        
        for (int i = 0; i < k; ++i) {
            deque.pollLast();
        }
        
        StringBuilder ret = new StringBuilder();
        boolean leadingZero = true;
        while (!deque.isEmpty()) {
            char digit = deque.pollFirst();
            if (leadingZero && digit == '0') {
                continue;
            }
            leadingZero = false;
            ret.append(digit);
        }
        return ret.length() == 0 ? "0" : ret.toString();
    }
}
```

#### [删除多余的字符得到字典序最小的字符串](https://www.nowcoder.com/questionTerminal/611d16ddd5344bfdb76c22306247dcf3?commentTags=C%2FC%2B%2B)

给一个全是小写字母的字符串str，删除多余字符，使得每种字符只保留一个，并且让最终结果字符串字典序最小。

**输入描述:**

```
输入包含一行字符串，代表str（1≤lengthstr≤105）（1 \leq length_{str} \leq 10^5 ）（1≤lengthstr≤105）。
```

**输出描述:**

```
输出一行，代表删除后的字符串。
```

示例1

**输入**

```
acbc
```

**输出**

```
abc
```

示例2

**输入**

```
dbcacbca
```

**输出**

```
dabc
```





首先统计各个字符出现的数目          int count[26]
标记数组表明结果中是否包含当前字符  bool visit[26]
对于新来的一个字符，如果已经在结果中那么跳过
如果不在结果中，那么需要判断结果末尾的元素是否需要弹出，条件为：
①末尾元素之后还存在剩余
②末尾元素的字典序比当前字符字典序大

待弹出一定的末尾元素后（或者不需要弹出），当前字符放入到结果中

```java
int main(){
    string s;
    cin>>s;
    int n = s.length();
    bool visit[26]={false};//是否已经添加到最终字符串中
    int count[26]={0};//计数
    vector<char> res;
    for(int i=0;i<n;i++)
        count[s[i]-'a']++;//计数
    for(int i=0;i<n;i++)
    {
        count[s[i]-'a']--;//删除
        if(visit[s[i]-'a'])//已经访问过
        {
            continue;
        }
        //如果没有访问过
        while(res.size()>0 &&  count[res.back()-'a']>0 &&  res.back()>s[i])
        {
            //如果比末尾的小 且末尾后面还有重复字符  那么末尾弹出
            visit[res.back()-'a']=false;
                  res.pop_back();// 
        }
        //当前字符进入
        res.push_back(s[i]);
        visit[s[i]-'a']=true;

    }
    for(auto i:res)
        cout<<i;

}
```



```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
             String str=sc.nextLine();
             solve(str,"");
        }
       
        sc.close();
    }
    public static void solve(String str,String res) {
		if(str.isEmpty()) {
			System.out.println(res);
			return;
		}
		String s=str.substring(0,1);
		if(res.contains(s)) {
			String tmp=res.replace(s, "").concat(s);
			if(tmp.compareTo(res)>0) {
				str=str.replace(s, "");
			}else {
				res=tmp;
				str=str.substring(1);
			}
		}else {
			res=res.concat(s);
			str=str.substring(1);
		}
		solve(str,res);
	}
}
```

#### [拼接所有的字符串产生字典序最小的字符串](https://www.nowcoder.com/questionTerminal/d5d1a56491384b2486480730f78f6da2)





给定一个字符串的数组strs，请找到一种拼接顺序，使得所有的字符串拼接起来组成的字符串是所有可能性中字典序最小的，并返回这个字符串。

**输入描述:**

```
输入包含多行，第一行包含一个整数n（1≤n≤105）（ 1 \leq n \leq 10^5 ）（1≤n≤105），代表字符串数组strs的长度，后面n行，每行一个字符串，代表strs[i]（保证所有字符串长度都小于10）。
```

**输出描述:**

```
输出一行，包含一个字符串，代表返回的字典序最小的字符串。
```

示例1

**输入**

```
2
abc
de
```

**输出**

```
abcde
```

示例2

**输入**

```
2
b
ba
```

**输出**

```
bab
```

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        String[] strs = new String[n];
        for(int i=0;i<n;i++){
            strs[i] = sc.next();
            //System.out.print(strs[i]);
        }
        System.out.println(lowestString(strs));
    }
    
    public static String lowestString(String strs[]){
        if(strs == null||strs.length == 0) return "";
        Arrays.sort(strs,new Mycomparator());
        StringBuilder res = new StringBuilder();
        for(int i=0;i<strs.length;i++){
            res.append(strs[i]);
        }
        return res.toString();
    }
}

class Mycomparator implements Comparator<String>{
    @Override
    public int compare(String a,String b){
        return (a+b).compareTo(b+a);
    }
}

```

### Leetcode1673 找出最具竞争力的子序列

给你一个整数数组 nums 和一个正整数 k ，返回长度为 k 且最具 竞争力 的 nums 子序列。

数组的子序列是从数组中删除一些元素（可能不删除元素）得到的序列。

在子序列 a 和子序列 b 第一个不相同的位置上，如果 a 中的数字小于 b 中对应的数字，那么我们称子序列 a 比子序列 b（相同长度下）更具 竞争力 。 例如，[1,3,4] 比 [1,3,5] 更具竞争力，在第一个不相同的位置，也就是最后一个位置上， 4 小于 5 。

 

示例 1：

输入：nums = [3,5,2,6], k = 2
输出：[2,6]
解释：在所有可能的子序列集合 {[3,5], [3,2], [3,6], [5,2], [5,6], [2,6]} 中，[2,6] 最具竞争力。
示例 2：

输入：nums = [2,4,3,3,5,4,9,6], k = 4
输出：[2,3,3,4]

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public int[] mostCompetitive(int[] nums, int k) {
        int len = nums.length;
        if (k == len) {
            return nums;
        }

        // 需要移除的元素的个数
        int removeCount = len - k;
        Deque<Integer> stack = new ArrayDeque<>();
        for (int num : nums) {
            // 注意：只有在有元素可以移除的时候才可以移除
            while (removeCount > 0 && !stack.isEmpty() && num < stack.peekLast()) {
                stack.removeLast();
                removeCount--;
            }
            stack.addLast(num);
        }

        // 如果还有可以删除的元素，从末尾删除
        for (int i = 0; i < removeCount; i++) {
            stack.removeLast();
        }

        // 此时栈中的元素就是最具竞争力的数组，遍历栈赋值到数组上即可
        int[] res = new int[k];
        int index = k - 1;
        for (int i = 0; i < k; i++) {
            res[index] = stack.removeLast();
            index--;
        }
        return res;
    }
}


```



### [NC85 拼接所有的字符串产生字典序最小的字符串](https://www.nowcoder.com/practice/f1f6a1a1b6f6409b944f869dc8fd3381?tpId=117&&tqId=37815&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个长度为 ![img](https://www.nowcoder.com/equation?tex=n%5C) 的字符串数组 ![img](https://www.nowcoder.com/equation?tex=strs%5C) ，请找到一种拼接顺序，使得数组中所有的字符串拼接起来组成的字符串是所有拼接方案中字典序最小的，并返回这个拼接后的字符串。

**示例1**

输入：

```
["abc","de"]
```

复制

返回值：

```
"abcde"
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param strs string字符串一维数组 the strings
     * @return string字符串
     */
    public String minString (String[] strs) {
        // write code here
        StringBuffer sb = new StringBuffer();
        Arrays.sort(strs, (s1,s2)->( (s1+s2).compareTo(s2+s1)  ));
    
        for (String s:strs) {
            sb.append(s);
        }

        return sb.toString();

    }
}
```

#### Leetcode386 字典序倒数

给定一个整数 n, 返回从 1 到 n 的字典顺序。

例如，

给定 n =1 3，返回 [1,10,11,12,13,2,3,4,5,6,7,8,9] 。

请尽可能的优化算法的时间复杂度和空间复杂度。 输入的数据 n 小于等于 5,000,000。

```java
class Solution {
    public List<Integer> lexicalOrder(int n) {
        ArrayList<Integer> res = new ArrayList<>();
        for (int i = 1; i < 10; i++) 
            dfs(n, i, res);
        return res;
    }
    private static void dfs(int n, int target, List<Integer> list) {
        if (target>n) return;
        list.add(target);
        target*=10;
        for (int i = 0; i < 10; i++) 
            dfs(n,target+i,list);
    }
}
```





### [NC36 在两个长度相等的排序数组中找到上中位数](https://www.nowcoder.com/practice/6fbe70f3a51d44fa9395cfc49694404f?tpId=188&&tqId=38639&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定两个有序数组arr1和arr2，已知两个数组的长度都为N，求两个数组中所有数的上中位数。

上中位数：假设递增序列长度为n，若n为奇数，则上中位数为第n/2+1个数；否则为第n/2个数

[要求]

时间复杂度为O(logN)*O*(*l**o**g**N*)，额外空间复杂度为O(1)*O*(1)

**示例1**

输入：

```
[1,2,3,4],[3,4,5,6]
```

复制

返回值：

```
3
```

复制

说明：

```
总共有8个数，上中位数是第4小的数，所以返回3。 
```

```java
import java.util.*;


public class Solution {
    /**
     * find median in two sorted array
     * @param arr1 int整型一维数组 the array1
     * @param arr2 int整型一维数组 the array2
     * @return int整型
     */
    public int findMedianinTwoSortedAray (int[] nums1, int[] nums2) {
        // write code here
        int n = nums1.length;
        int m = nums2.length;
        //
        int left = (n+m+1)/2;
        int right = (n+m+2)/2;
        return getKth(nums1,0,nums1.length-1,nums2,0,nums2.length-1,n);
    }
    
    public int getKth(int[] nums1,int start1,int end1,int[] nums2,int start2,int end2,int k){
        int len1 = end1-start1+1;
        int len2 = end2-start2+1;
        
        
        if(len1==0){
            return nums2[start2+k-1];
        }
        if(k==1){
            return Math.min(nums1[start1],nums2[start2]);
        }

        // 继续递归 新的索引
        int i = start1 + Math.min(len1,k/2) - 1;
        int j = start2 + Math.min(len2,k/2) - 1;
        if(nums1[i]>nums2[j]){
            return getKth(nums1,start1,end1,nums2,j+1,end2,k-(j-start2+1));
        }else{
            return getKth(nums1,i+1,end1,nums2,start2,end2,k-(i-start1+1));
        }
        
    }
}
```



### A,B 两个排序数组，原地合并数组（有序数组合并）

- AB两个[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)数组，原地合并数组。（A当中穿插一些无效数字怎么处理？）

思路：因为要原地合并数组，如果从前往后遍历，数组原来的值会被覆盖，所以只能从后往前遍历，将值从后往前存入。存入时比较当前两个指针指向的数字大小，选较大的存入，然后往前移动指针。   

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int i = m - 1,j = n - 1,k = m + n - 1;
        while(j >= 0){
            if(i < 0 || B[j] >= A[i]){
                A[k--] = B[j--];
            }else {
                A[k--] = A[i--];
            }
        }
    }
}
```

### 桶排序-利用桶排序排序后最大差值问题

**利用桶排序排序后最大差值问题**

> 题目：给定个数组，求如果排序之后，相邻两数的最大差值,要求时间复杂度O(N),且要求不能用非基于比较的排序。

给出三个桶，放最大值 最小值 是否有值 平均分配桶

```java
package com.lcz.leetcode;
import java.util.*;

public class MaxGap {
	// 求最大差值 用桶排序
	public static int maxGap(int[] nums) {
		if(nums==null || nums.length<2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for(int i=0;i<len;i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if(min==max) {
			return 0;
		}
		// 放入桶中
		boolean[] hasNum = new boolean[len+1];
		int[] maxs = new int[len+1];
		int[] mins = new int[len+1];
		int bid = 0;
		for(int i=0;i<len;i++) {
			bid = bucket(nums[i], len, min, max);
			mins[bid] = hasNum[bid]?Math.min(mins[bid], nums[i]):nums[i];
			maxs[bid] = hasNum[bid]?Math.max(maxs[bid], nums[i]):nums[i];
			hasNum[bid] =  true;
		}
		// 得到结果
		int res = 0;
		int lastMax = maxs[0];
		for(int i=1;i<=len;i++) {
			if(hasNum[i]) {
				res = Math.max(res, mins[i]-lastMax);
				lastMax = maxs[i];
			}
		}
		return res;
	}
	
	// 确定哪个桶
	public static int bucket(long num,long len,long min,long max) {
		return (int)((num-min)*len / (max-min));
	}
	
	
	// 标准方法
	public static int comparator(int[] nums) {
		if(nums==null||nums.length<2) {
			return 0;
		}
		// 对其排序
		Arrays.sort(nums);
		// 求最大差值
		int gap = Integer.MIN_VALUE;
		for(int i=1;i<nums.length;i++) {
			gap = Math.max(nums[i]-nums[i-1], gap);
		}
		return gap;
	}
	// 主函数
	public static void main(String[] args) {
		int[] arr = new int[] {1,3,2,6,5,7,8,9,0};
//		System.out.println(comparator(arr));
		System.out.println(maxGap(arr));
	}
}

```

### 桶排序-[Leetcode164最大间距](https://leetcode-cn.com/problems/maximum-gap/)

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

示例 1:

输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
示例 2:

输入: [10]
输出: 0

解释: 数组元素个数小于 2，因此返回 0。



**说明:**

- 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
- 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。

```java
class Solution {
    public int maximumGap(int[] nums) {
        int n = nums.length;
        if(n<2){
            return 0;
        }
        int minVal = Arrays.stream(nums).min().getAsInt();
        int maxVal = Arrays.stream(nums).max().getAsInt();
        //最大之和最小值
        int d = Math.max(1,(maxVal-minVal)/(n-1));
        int bucketSize = (maxVal-minVal)/d + 1;
        //桶算法
        int[][] bucket = new int[bucketSize][2];
        for(int i=0;i<bucketSize;i++){
            //存储(桶内最小值,桶内最大值)对,(-1,-1)表示该桶是空的
            Arrays.fill(bucket[i],-1);
        }
        for(int i=0;i<n;i++){
            int idx = (nums[i]-minVal)/d;
            if(bucket[idx][0]==-1){
                bucket[idx][0] = bucket[idx][1] = nums[i];
            }else{
                bucket[idx][0] = Math.min(bucket[idx][0],nums[i]);
                bucket[idx][1] = Math.max(bucket[idx][1],nums[i]);
            }
        }
        //差值
        int res = 0;
        int prev = -1;
        for(int i=0;i<bucketSize;i++){
            if(bucket[i][0]==-1){
                continue;
            }
            if(prev!=-1){
                res = Math.max(res,bucket[i][0]-bucket[prev][1]);
            }
            prev = i;
        }
        return res;
    }
}
```

 



### 基排序-[Leetcode164最大间距](https://leetcode-cn.com/problems/maximum-gap/)

给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。

如果数组元素个数小于 2，则返回 0。

示例 1:

输入: [3,6,9,1]
输出: 3
解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。
示例 2:

输入: [10]
输出: 0

解释: 数组元素个数小于 2，因此返回 0。



**说明:**

- 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。
- 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。



**解题思路：**

一种最简单的思路是将数组排序后再找出最大间距，但传统的基于比较的排序算法（快速排序、归并排序等）均需要 O(N\log N)O(NlogN) 的时间复杂度。如果要将时间复杂度降到 O(N)O(N)，我们就必须使用其他的排序算法。**例如，基数排序可以在 O(N)O(N) 的时间内完成整数之间的排序。**



```java
class Solution {
    public int maximumGap(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return 0;
        }
        long exp = 1;
        int[] buf = new int[n];
        int maxVal = Arrays.stream(nums).max().getAsInt();

        while (maxVal >= exp) {
            int[] cnt = new int[10];
            for (int i = 0; i < n; i++) {
                int digit = (nums[i] / (int) exp) % 10;
                cnt[digit]++;
            }
            for (int i = 1; i < 10; i++) {
                cnt[i] += cnt[i - 1];
            }
            for (int i = n - 1; i >= 0; i--) {
                int digit = (nums[i] / (int) exp) % 10;
                buf[cnt[digit] - 1] = nums[i];
                cnt[digit]--;
            }
            System.arraycopy(buf, 0, nums, 0, n);
            exp *= 10;
        }

        int ret = 0;
        for (int i = 1; i < n; i++) {
            ret = Math.max(ret, nums[i] - nums[i - 1]);
        }
        return ret;
    }
}

```







### 桶排序高考成绩

**高考成绩2000万数据，分数0-750，如何快速知道你的排名，如何知道任一分数排名 --->桶排序**

```java
public class Solution {
    public ArrayList<Integer> bucketSort(int[] scores){
      //先确定最大最小值，来确定范围
      int max = Integer.MIN_VALUE;
      int min = Integer.MAX_VALUE;
      for(int i = 0; i < scores.length;i++){
          max = Math.max(max,scores[i]);
          min = Math.min(min,scores[i]);
      }
      //计算出桶数
      //int bucketNum = (max - min)/scores.length + 1;
      //这里直接给出751个桶
      int bucketNum = 751;
      ArrayList<ArrayList<Integer>> list = new ArrayList<>(bucketNum);
      for(int i = 0; i < bucketNum; i++){
          list.add(new ArrayList<Integer>());
      }
      
      //将每个元素放入桶
      for(int i = 0; i < scores.length;i++){
          //本题中这里放元素也可以简化
          //list.get((scores[i] - min)/bucketNum).add(scores[i]);
          list.get(scores[i]).add(scores[i]);
      }
      
      //桶内排序,本题中可以省略这一步
      for(int i = 0; i< list.size();i++){
          Collections.sort(list.get(i));
      
      return list;
    }
}
```

### 剑指Offer51 数组中的逆序对

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

 

示例 1:

输入: [7,5,6,4]
输出: 5

```java
class Solution {
    int res = 0;
    public int reversePairs(int[] nums) {
        // 归并排序
        mergeSort(nums,0,nums.length-1);
        return res;
    }

    // 归并排序
    public void mergeSort(int[] nums,int l,int r){
        if(l>=r){
            return;
        }
        int mid = l + ((r-l)>>1);
        mergeSort(nums,l,mid);
        mergeSort(nums,mid+1,r);
        merge(nums,l,mid,r);
    }

    // 归并
    public void merge(int[] nums,int l,int mid,int r){
        int[] temp = new int[r-l+1];
        int index = 0;
        //开始
        int l1 = l;
        int l2 = mid+1;
        while(l1<=mid&&l2<=r){
            //判断
            if(nums[l1]>nums[l2]){
                temp[index++] = nums[l2++];
                res += (mid-l1+1);
            }else{
                temp[index++] = nums[l1++];
            }
        }
        while(l1<=mid){
            temp[index++] = nums[l1++];
        }
        while(l2<=r){
            temp[index++] = nums[l2++];
        }
        // 重新分配
        for(int i=0;i<temp.length;i++){
            nums[l+i] = temp[i];
        }
    }
}
```





### [NC115 栈和排序](https://www.nowcoder.com/practice/95cb356556cf430f912e7bdf1bc2ec8f?tpId=117&&tqId=37839&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给你一个 1 到 ![img](https://www.nowcoder.com/equation?tex=n%5C) 的排列和一个栈，入栈顺序给定

你要在不打乱入栈顺序的情况下，对数组进行从大到小排序

当无法完全排序时，请输出字典序最大的出栈序列

数据范围: 1 \le n \le 10^61≤*n*≤106

**示例1**

输入：

```
[2,1,5,3,4]
```

复制

返回值：

```
[5,4,3,1,2]
```

复制

说明：

```
2入栈；1入栈；5入栈；5出栈；3入栈；4入栈；4出栈；3出栈；1出栈；2出栈 
```

```java
import java.util.*;


public class Solution {
    /**
     * 栈排序
     * @param a int整型一维数组 描述入栈顺序
     * @return int整型一维数组
     */
   public int[] solve (int[] a) {
       int n=a.length;
        Stack<Integer>stack=new Stack<>();
        int[]dp=new int[n];
        dp[n-1]=a[n-1];
        for(int i=n-2;i>=0;i--)
            dp[i]=Math.max(dp[i+1],a[i]);  //用一个数组记录第i个及之后最大元素
        int[]res=new int[n];
        int j=0;
        for(int i=0;i<n;i++){
            stack.push(a[i]);
            while(!stack.isEmpty()&&i<n-1&&stack.peek()>=dp[i+1]) 
                res[j++]=stack.pop();//如果栈顶元素比后面的都大，那么出栈
        }
        while(!stack.isEmpty()) res[j++]=stack.pop(); //最后在栈中的按顺序弹出
        return res;
    }
}
```

### Leetcode1574 删除最短的子数组使剩余数组有序

给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。

一个子数组指的是原数组中连续的一个子序列。

请你返回满足题目要求的最短子数组的长度。

 

示例 1：

输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
示例 2：

输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。

```java
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
        int n = arr.length;
        int left = 0;
        while (left + 1 < n && arr[left] <= arr[left+1]) {
            left++;
        }
        // [0...left]有序
        if (left == n - 1) {
            return 0;
        }
        // [right...n-1]有序
        int right = n - 1;
        while (right > 0 && arr[right - 1] <= arr[right]) {
            right--;
        }
        
        // 完全删除一边[left+1, n-1], 或者[0...right - 1]
        int result = Math.min(n - left - 1, right);

        // 左边和右边各保留一部分
        int i = 0, j = right;
        
        while (i <= left && j <= n - 1) {
            if (arr[i] <= arr[j]) {
                // [0...i] 和 [j...n-1] 有序, 删除 [i+1...j-1]
                result = Math.min(result, j - i - 1);
                i++;
            } else {
                // 小的+1
                j++;
            }
        }
        return result;
    }
}

```

### Leetcode905 按奇偶排序数组

给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。

你可以返回满足此条件的任何数组作为答案。

 

示例：

输入：[3,1,2,4]
输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。

```java
class Solution {
    public int[] sortArrayByParity(int[] A) {
        if(A == null || A.length == 1)
            return A;
        //左、右指针初始化
        int left = 0;
        int right = A.length - 1;
        int tem;
        while(left < right){
            //左指针对应奇数值，右指针对应偶数值，进行交换
            if((A[left] & 1) == 1 && (A[right] & 1) == 0){
                tem = A[left];
                A[left] = A[right];
                A[right] = tem;
            }else if((A[left] & 1) == 0){
                //左指针对应的是偶数值，符合题意，继续向右移动
                left++;
            }else if((A[right] & 1) == 1){
                //右指针对应的是奇数值，符合题意，继续向左移动
                right--;
            }
        }
        return A;
    }
}
```

### Leetcode1031 两个非重叠子数组的最大和

给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）

从形式上看，返回最大的 V，而 V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) 并满足下列条件之一：

 

0 <= i < i + L - 1 < j < j + M - 1 < A.length, 或
0 <= j < j + M - 1 < i < i + L - 1 < A.length.


示例 1：

输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
输出：20
解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。
示例 2：

输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
输出：29
解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。

```java
class Solution {
    public int maxSumTwoNoOverlap(int[] nums, int f, int s) {
        int n = nums.length;
        int[] sum = new int[n+1];
        for (int i = 0;i < n;i++) sum[i+1] = sum[i] + nums[i];
        if (f > s) {
            int t = f; f = s; s = t;
        }
        int[][] dp = new int[n+1][2];
        int max = 0;
        for (int i = f;i <= n;i++) {
            int s1 = sum[i] - sum[i-f];
            dp[i][0] = Math.max(dp[i-1][0], s1);
            max = Math.max(max, s1 + dp[i-f][1]);
            if (i >= s) {
                int s2 = sum[i] - sum[i-s];
                dp[i][1] = Math.max(dp[i-1][1], s2);
                max = Math.max(max, s2 + dp[i-s][0]);
            }
        }
        return max;
    }

}
```



## 版本号

### [NC104 比较版本号](https://www.nowcoder.com/practice/2b317e02f14247a49ffdbdba315459e7?tpId=117&&tqId=37828&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

牛客项目发布项目版本时会有版本号，比如1.02.11，2.14.4等等

现在给你2个版本号version1和version2，请你比较他们的大小

版本号是由修订号组成，修订号与修订号之间由一个"."连接。1个修订号可能有多位数字组成，修订号可能包含前导0，且是合法的。例如，1.02.11，0.1，0.2都是合法的版本号

每个版本号至少包含1个修订号。

修订号从左到右编号，下标从0开始，最左边的修订号下标为0，下一个修订号下标为1，以此类推。

比较规则：

一. 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较忽略任何前导零后的整数值。比如"0.1"和"0.01"的版本号是相等的

二. 如果版本号没有指定某个下标处的修订号，则该修订号视为0。例如，"1.1"的版本号小于"1.1.1"。因为"1.1"的版本号相当于"1.1.0"，第3位修订号的下标为0，小于1

三. version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.

数据范围：

version1 和version2 字符串长度不超过1000 ，但是版本号的每一节可能超过 int 表达范围

**示例1**

输入：

```
"1.1","2.1"
```

复制

返回值：

```
-1
```

复制

说明：

```
version1 中下标为 0 的修订号是 "1"，version2 中下标为 0 的修订号是 "2" 。1 < 2，所以 version1 < version2，返回-1
     
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 比较版本号
     * @param version1 string字符串 
     * @param version2 string字符串 
     * @return int整型
     */
    public int compare (String version1, String version2) {
        // write code here
        if(version1==null||version2==null||version1.length()==0||version2.length()==0) return 0;
        String[] v1 = version1.split("\\.");
        String[] v2 = version2.split("\\.");
        int len = Math.min(v1.length,v2.length);
        for(int i=0;i<len;i++){
            v1[i]=stripZero(v1[i]);//去掉头部的0
            v2[i]=stripZero(v2[i]);//去掉头部的0
            if(v1[i].equals(v2[i])) continue;
            int n1=0, n2=0;
            try{ //如果能用int 去比较最好
                n1 = Integer.parseInt(v1[i]);
                n2 = Integer.parseInt(v2[i]);
            }catch(Exception e){ //不能用int 比较就用java string 的compareTo
                if(v1[i].compareTo(v2[i])>0){
                    return 1;
                }else if(v1[i].compareTo(v2[i])<0){
                    return -1;
                }else{
                    //return 0;
                    continue;
                }
            }
            if(n1>n2){
                return 1;
            }else if(n1<n2){
                return -1;
            }else{
                //return 0;
                continue;
            }
        }
        if(v1.length>v2.length){
            for(int i=len;i<v1.length;i++){
                int n1 = 0;
                try{
                    n1 = Integer.parseInt(v1[i]);
                    if(n1==0) continue;
                    else return 1;
                }catch(Exception e){
                    return 1;
                }
            }
            return 0;
        }else if(v1.length<v2.length){
            for(int i=len;i<v2.length;i++){
                int n2 = 0;
                try{
                    n2 = Integer.parseInt(v2[i]);
                    if(n2==0) continue;
                    else return -1;
                }catch(Exception e){
                    return -1;
                }
            }
            return 0;
        }
        return 0;
    }

    //去掉字符串头部的0的函数
    public String stripZero(String s){
        int i=0;
        while(i<s.length()){
            if(s.charAt(i)=='0'){
                i++;
                continue;
            } 
            break;
        }
        return s.substring(i,s.length());

    }
}
```

### Leetcode165 比较版本号

给你两个版本号 version1 和 version2 ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别为 0 和 1 ，0 < 1 。

返回规则如下：

如果 version1 > version2 返回 1，
如果 version1 < version2 返回 -1，
除此之外返回 0。


示例 1：

输入：version1 = "1.01", version2 = "1.001"
输出：0
解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] strs1 = version1.split("\\.");
        String[] strs2 = version2.split("\\.");
        int i = 0, len = strs1.length < strs2.length ? strs1.length : strs2.length;
        while (i < len){
            int valu1 = Integer.parseInt(strs1[i]);
            int valu2 = Integer.parseInt(strs2[i]);
            if (valu1 > valu2) return 1;
            else if (valu1 < valu2) return -1;
            else {
                ++ i;
            }
        }
        if (strs1.length == strs2.length) return 0;
        else if (strs1.length > strs2.length ){
            for (int j = i; j < strs1. length; j ++){
                if (Integer.parseInt(strs1[j]) > 0) return 1;
            }
        }else if (strs2.length > strs1.length ){
            for (int j = i; j < strs2. length; j ++){
                if (Integer.parseInt(strs2[j]) > 0) return -1;
            }
        }
        return 0;
    }
}
```

### [Leetcode171 Excel表列序列](https://leetcode-cn.com/problems/excel-sheet-column-number/)


给你一个字符串 `columnTitle` ，表示 Excel 表格中的列名称。返回该列名称对应的列序号。

 

例如，

```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...
```

 

**示例 1:**

```
输入: columnTitle = "A"
输出: 1
```

**示例 2:**

```
输入: columnTitle = "AB"
输出: 28
```

```java
class Solution {
    public int titleToNumber(String s) {
        char[] charArray = s.toCharArray();
        int res = 0;
        for(int i = 0; i < charArray.length; i++) {
            res = res*26 + (charArray[i] - 'A' + 1);
        }
        
        return res;
    }
}
```

### [Leetcode168 Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

例如：

A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...


示例 1：

输入：columnNumber = 1
输出："A"
示例 2：

输入：columnNumber = 28
输出："AB"

```java
class Solution {
    public String convertToTitle(int n) {
        if (n <= 0) {
            return "";
        }
        StringBuilder sb = new StringBuilder();
        while (n > 0) {
            n--;
            sb.append((char) (n % 26 + 'A'));
            n =n / 26;
        }
        return sb.reverse().toString();
    }
}
```

### Leetcode278 第一个错误的版本

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。


示例 1：

输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
示例 2：

输入：n = 1, bad = 1
输出：1

```java
public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int left = 1, right = n;
        while (left < right) { // 循环直至区间左右端点相同
            int mid = left + (right - left) / 2; // 防止计算时溢出
            if (isBadVersion(mid)) {
                right = mid; // 答案在区间 [left, mid] 中
            } else {
                left = mid + 1; // 答案在区间 [mid+1, right] 中
            }
        }
        // 此时有 left == right，区间缩为一个点，即为答案
        return left;
    }
}

```



## O(n)原地操作数组

### Leetcode1574 删除最短的子数组使剩余数组有序

给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。

一个子数组指的是原数组中连续的一个子序列。

请你返回满足题目要求的最短子数组的长度。

 

示例 1：

输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
示例 2：

输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。

```java
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
        int n = arr.length;
        int left = 0;
        while (left + 1 < n && arr[left] <= arr[left+1]) {
            left++;
        }
        // [0...left]有序
        if (left == n - 1) {
            return 0;
        }
        // [right...n-1]有序
        int right = n - 1;
        while (right > 0 && arr[right - 1] <= arr[right]) {
            right--;
        }
        
        // 完全删除一边[left+1, n-1], 或者[0...right - 1]
        int result = Math.min(n - left - 1, right);

        // 左边和右边各保留一部分
        int i = 0, j = right;
        
        while (i <= left && j <= n - 1) {
            if (arr[i] <= arr[j]) {
                // [0...i] 和 [j...n-1] 有序, 删除 [i+1...j-1]
                result = Math.min(result, j - i - 1);
                i++;
            } else {
                // 小的+1
                j++;
            }
        }
        return result;
    }
}

```



### [NC101 缺失数字](https://www.nowcoder.com/practice/9ce534c8132b4e189fd3130519420cde?tpId=188&&tqId=38653&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

从 0,1,2,...,n 这 n+1 个数中选择 n 个数，选择出的数字依然保持有序，找出这 n 个数中缺失的那个数，要求 O(n) 或 O(log(n)) 并尽可能小。

**示例1**

输入：

```
[0,1,2,3,4,5,7]
```

复制

返回值：

```
6
```

复制

**示例2**

输入：

```
[0,2,3]
```

复制

返回值：

```
1
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 找缺失数字
     * @param a int整型一维数组 给定的数字串
     * @return int整型
     */
    public int solve (int[] a) {
        // write code here
        int len = a.length;
        for(int i=0;i<len;i++){
            while(a[i]<len&&a[i]!=a[a[i]]){
                swap(a,i,a[i]);
            }
        }
        for(int i=0;i<len;i++){
            if(i!=a[i]){
                return i;
            }
        }
        return len;
    }
    
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [NC30 数组中未出现的最小正整数](https://www.nowcoder.com/practice/8cc4f31432724b1f88201f7b721aa391?tpId=188&&tqId=38665&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个无序数组arr，找到数组中未出现的最小正整数

例如arr = [-1, 2, 3, 4]。返回1

arr = [1, 2, 3, 4]。返回5

[要求]

时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)

**示例1**

输入：

```
[-1,2,3,4]
```

复制

返回值：

```
1
```

```java
import java.util.*;


public class Solution {
    /**
     * return the min number
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int minNumberdisappered (int[] arr) {
        // write code here
        //从未出现的最小正整数
        for(int i=0;i<arr.length;i++){
            while(arr[i]>=1&&arr[i]<=arr.length&& arr[i]!=arr[arr[i]-1]){
                swap(arr,i,arr[i]-1);
            }
        }
        //找到
        for(int i=0;i<arr.length;i++){
            if(i!=arr[i]-1){
                return i+1;
            }
        }
        return arr.length+1;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [NC74 数组在升序数组中出现的次数](https://www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2?tpId=117&&tqId=37772&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

统计一个数字在升序数组中出现的次数。

**示例1**

输入：

```
[1,2,3,3,3,3,4,5],3
```

复制

返回值：

```
4
```

```java
public class Solution {
    public int GetNumberOfK(int [] nums , int target) {
        int lbound = 0, rbound = 0;
        // 寻找上界
        int l = 0, r = nums.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] < target) {
                l = mid + 1;
            }
            else {
                r = mid;
            }
        }
        lbound = l;
        // 寻找下界
        l = 0;r = nums.length;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (nums[mid] <= target) {
                l = mid + 1;
            }
            else {
                r = mid;
            }
        }
        rbound = l;
        return rbound - lbound;
    }
}
```



### [1.Leetcode136 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

> 考察异或运算

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int num:nums){
            res ^= num;
        }
        return res;
    }
}
```

### 剑指Offer03 数组中重复的数字

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        //重复的数字
        int len = nums.length;
        for(int i=0;i<len;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                swap(nums,i,nums[i]);
            }
        }
        return -1;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```



### [1.Leetcode442 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)


给定一个整数数组 a，其中1 ≤ a[i] ≤ *n* （*n*为数组长度）, 其中有些元素出现**两次**而其他元素出现**一次**。

找到所有出现**两次**的元素。

你可以不用到任何额外空间并在O(*n*)时间复杂度内解决这个问题吗？

**示例：**

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

> 解题思路：可以在输入数组中用数字的正负来表示该位置所对应数字是否已经出现过。**遍历输入数组，给对应位置的数字取相反数，如果已经是负数，说明前面已经出现过，直接放入输出数组。**

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            int num = Math.abs(nums[i]);
            if(nums[num-1]>0){
                nums[num-1] *= -1;
            }else{
                res.add(num);
            }
        }
        return res;
    }
}
```



### [2.Leetcode137 只出现一次的数字II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

 

示例 1：

输入：nums = [2,2,3,2]
输出：3
示例 2：

输入：nums = [0,1,0,1,0,1,99]
输出：99

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}


```



```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}

```

### [3.Leetcode260 只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

示例 1：

输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
示例 2：

输入：nums = [-1,0]
输出：[-1,0]
示例 3：

输入：nums = [0,1]
输出：[1,0]

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int ret = 0;
        for (int n : nums) {
            ret ^= n;
        }
        int div = 1;
        while ((div & ret) == 0) {
            div <<= 1;
        }
        int a = 0, b = 0;
        for (int n : nums) {
            if ((div & n) != 0) {
                a ^= n;
            } else {
                b ^= n;
            }
        }
        return new int[]{a, b};
    }
}

```



```java
class Solution {
    public int[] singleNumber(int[] nums) {
        HashMap<Integer, Integer> temp = new HashMap<>();
        for (int e : nums)
        {
            int count = temp.getOrDefault(e, 0) + 1;
            temp.put(e, count);
        }
        int[] result = new int[2];
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : temp.entrySet())
        {
            if (entry.getValue() == 1)
            {
                result[i] = entry.getKey();
                i++;
            }
        }
        return result;
    }
}


```



### [3.剑指OfferII070 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/)

给定一个**只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次**，请找出这个唯一的数字。

 

示例 1:

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: nums =  [3,3,7,7,10,11,11]
输出: 10

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0,r = nums.length-1;
        while(l<r){
            int mid = l+r>>1;
            if(mid%2==1) mid--;
            if(nums[mid]==nums[mid+1]){
                l = mid+2;
            }else{
                r = mid-1;
            }
        }
        return nums[l];
    }
}
```





### [2.LeetcoderOffer03数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/)

找出数组中重复的数字。


在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

示例 1：

输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 

```java
class Solution {
    public int findRepeatNumber(int[] nums) {
        for(int i=0;i<nums.length;i++){
            while(i!=nums[i]){
                if(nums[i]==nums[nums[i]]){
                    return nums[i];
                }
                swap(nums,i,nums[i]);
            }
        }
        return -1;
    }
    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [3.Leetcode287 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。

假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。

 

示例 1：

输入：nums = [1,3,4,2,2]
输出：2
示例 2：

输入：nums = [3,1,3,4,2]
输出：3

```java
class Solution {
    public int findDuplicate(int[] nums) {
        // 寻找重复的数字
        int n = nums.length;
        for(int i=0;i<n;i++){
            while(i!=nums[i]-1){
                if(nums[i]==nums[nums[i]-1]){
                    return nums[i];
                }
                swap(nums,i,nums[i]-1);
            }
        }
        return -1;
    }

    // 交换
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```





### [3.Leetcode448 找到所有数组消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/submissions/)

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

 

示例 1：

输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
示例 2：

输入：nums = [1,1]
输出：[2]

```java
class Solution {
    public List<Integer> findDisappearedNumbers(int[] nums) {
        for(int i=0;i<nums.length;i++){
            while(nums[i]!=nums[nums[i]-1]){
                swap(nums,i,nums[i]-1);
            }
        }
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            if(i!=nums[i]-1){
                res.add(i+1);
            }
        }
        return res;
    }
    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



### [4.Leetcode041缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)


给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

 

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
```

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        for(int i=0;i<nums.length;i++){
            while(nums[i]>0&&nums[i]<=nums.length&&nums[i]!=nums[nums[i]-1]){
                swap(nums,i,nums[i]-1);
            }
        }
        for(int i=0;i<nums.length;i++){
            if(i!=nums[i]-1){
                return i+1;
            }
        }
        return nums.length+1;
    }

    public void swap(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i]  = nums[j];
        nums[j]  = temp;
    }
}
```

### [5.Leetcode_Offer53II 0-n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/)

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

 

示例 1:

输入: [0,1,3]
输出: 2
示例 2:

输入: [0,1,2,3,4,5,6,7,9]
输出: 8

```java
class Solution {
    public int missingNumber(int[] nums) {
        int l = 0;
        int r = nums.length-1;
        //判断
        while(l<=r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]==mid){
                l = mid+1;
            }else{
                r = mid-1;
            }
        }
        return l;
    }
}
```

### [5.Leetcode229 求众数II](https://leetcode-cn.com/problems/majority-element-ii/)

给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。

进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。

 

示例 1：

输入：[3,2,3]
输出：[3]
示例 2：

输入：nums = [1]
输出：[1]
示例 3：

输入：[1,1,1,3,3,2,2,2]
输出：[1,2]

```java
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        // 创建返回值
        List<Integer> res = new ArrayList<>();
        if (nums == null || nums.length == 0) return res;
        // 初始化两个候选人candidate，和他们的计票
        int cand1 = nums[0], count1 = 0;
        int cand2 = nums[0], count2 = 0;

        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段
        // 配对阶段
        for (int num : nums) {
            // 投票
            if (cand1 == num) {
                count1++;
                continue;
            }
            if (cand2 == num) {
                count2++;
                continue;
            }

            // 第1个候选人配对
            if (count1 == 0) {
                cand1 = num;
                count1++;
                continue;
            }
            // 第2个候选人配对
            if (count2 == 0) {
                cand2 = num;
                count2++;
                continue;
            }

            count1--;
            count2--;
        }

        // 计数阶段
        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3
        count1 = 0;
        count2 = 0;
        for (int num : nums) {
            if (cand1 == num) count1++;
            else if (cand2 == num) count2++;
        }

        if (count1 > nums.length / 3) res.add(cand1);
        if (count2 > nums.length / 3) res.add(cand2);

        return res;
    }
}

```



### [5.Leetcode169 多数元素](https://leetcode-cn.com/problems/majority-element/)


给定一个大小为 *n* 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

 

**示例 1：**

```
输入：[3,2,3]
输出：3
```

**示例 2：**

```
输入：[2,2,1,1,1,2,2]
输出：2
```

> 摩尔投票法



```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 1;
        int candate = nums[0];
        for(int i=1;i<nums.length;i++){
            if(count==0){
                candate = nums[i];
            }
            count += candate==nums[i]?+1:-1;
        }
        return candate;
    }
}
```

###  有序数组找超过数组长度的一半

![image-20210818162122539](imgs\720.png)

### 16.缺失的第一个数(不同于leetcode，值的范围不定)

- 一个无序数组，从小到大找到第一个缺的数，比如[8 2 4 3 6 9 7 11 12],第一个缺的就是5 （2）

1.[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)，时间复杂度O(NlogN)

2.用 数组作为[哈希表](https://www.nowcoder.com/jump/super-jump/word?word=哈希表) ，将数字i放入数组中的i索引处，然后找中间没有存入数字的位置。时间和空间复杂度都是O(N)

```java
public  class Solution {
    public int findLost(int[] nums){
        int min = nums[0];
        int max = nums[0];
        for(int value : nums){
            min = Math.min(min,value);
            max = Math.max(max,value);
        }
        int[] res = new int[max - min + 1];
        for(int i = 0; i < res.length;i++){
            res[i] = min - 1;
        }
        for(int value : nums){
            res[value] = value;
        }
        int i = 0;
        while(i < res.length){
            if(res[i] = min - 1)
                break;
        }
        return i;
    }
}

```



桶[排序]()    (Bucket sort)的工作的原理：假设输入数据   服从均匀分布   ，将数据分到有限数量的桶里，每个桶再分别[排序]()（有可能再使用别的[排序]()[算法]()或是以递归方式继续使用桶[排序]()进行排）。   

​    [算法]()描述：   

​    设置一个定量的数组当作空桶；   

​    遍历输入数据，并且把数据一个一个放到对应的桶里去；   

​    对每个不是空的桶进行[排序]()；   

​    从不是空的桶里把排好序的数据拼接起来。

```java
public class Solution {
    public ArrayList<Integer> bucketSort(int[] scores){
      //先确定最大最小值，来确定范围
      int max = Integer.MIN_VALUE;
      int min = Integer.MAX_VALUE;
      for(int i = 0; i < scores.length;i++){
          max = Math.max(max,scores[i]);
          min = Math.min(min,scores[i]);
      }
      //计算出桶数
      //int bucketNum = (max - min)/scores.length + 1;
      //这里直接给出751个桶
      int bucketNum = 751;
      ArrayList<ArrayList<Integer>> list = new ArrayList<>(bucketNum);
      for(int i = 0; i < bucketNum; i++){
          list.add(new ArrayList<Integer>());
      }
      
      //将每个元素放入桶
      for(int i = 0; i < scores.length;i++){
          //本题中这里放元素也可以简化
          //list.get((scores[i] - min)/bucketNum).add(scores[i]);
          list.get(scores[i]).add(scores[i]);
      }
      
      //桶内排序,本题中可以省略这一步
      for(int i = 0; i< list.size();i++){
          Collections.sort(list.get(i));
      } 
      return list;
    }
}
```

### 求平方后不重复的数

给一个有序数组，求每个数的平方的结果，不重复的有几个
-5，-5，-1，0，1，1，1，1，2，5
这里平方数不重复的一共4个

怎么样用O(1)的空间复杂度实现

```java


    public static int findUniqSquare(int[] nums) {
 int l = 0;
 int r = nums.length - 1;
 int cnt = 0;
 while (l <= r) {
     int left = nums[l] * nums[l];
     int right = nums[r] * nums[r];
     if (left == right) {
  cnt ++;
  while (++l <= r && nums[l] == nums[l - 1]);
  while (--r >= l && nums[r] == nums[r + 1]);
     } else {
  if (left < right) {
      cnt ++;
      while (--r > l && nums[r] == nums[r + 1]);
  } else {
      cnt ++;
      while (++l < r && nums[l] == nums[l - 1]);
  }
     }
 }
 return cnt;
    }
```

### Leetcode26 删除有序数组中的重复项

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

示例 1：

输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        // 新数组中的索引是从0开始的
        int left = 0;
        // 旧数组中的索引是从1开始的
        int right = 1;
        // 就数组遍历
        while(right<nums.length){
            // 相等
            if(nums[right]==nums[left]){
                right++;
            }else{
                // 不相等了
                nums[++left] = nums[right++];
            }
        }
        // 返回长度
        return left+1;
    }
    
    
}
```

### Leetcode80 删除有序数组中的重复项II

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

 

说明：

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

```java
class Solution {
    public int removeDuplicates(int[] nums) {
            int low = 0;
	    	int fast = 1;
	    	int fre = 0;
	    	while(fast<nums.length) {
	    		// 老数组
	    		if(nums[fast]==nums[low]) {
	    			fre++;
	    		}else {
	    			fre = 0;
	    		}
	    		
	    		// 新数组
	    		if(fre<2) {
	    			low++;
	    			nums[low] = nums[fast];
	    		}
	    		
	    		// 接着走
	    		fast++;
	    	}
	    	return low+1;
    }
}
```

```java
class Solution {
    public int removeDuplicates(int[] nums) {
            int low = 0;
	    	int fast = 1;
	    	int fre = 0;
	    	while(fast<nums.length) {
	    		// 老数组
	    		if(nums[fast]==nums[low]) {
	    			fre++;
	    		}else {
	    			fre = 0;
	    		}
	    		
	    		// 新数组
	    		if(fre<2) {
	    			low++;
	    			nums[low] = nums[fast];
	    		}
	    		
	    		// 接着走
	    		fast++;
	    	}
	    	return low+1;
    }
}
```

### Leetcode645 错误的集合

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有一个数字重复 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

示例 1：

输入：nums = [1,2,2,4]
输出：[2,3]
示例 2：

输入：nums = [1,1]
输出：[1,2]

```java
class Solution {
    public int[] findErrorNums(int[] nums) {
        
        int[] counter = new int[nums.length+1];
        
        for (int i: nums) {
            counter[i]++;
        }
        
        int[] result = new int[2];
        for (int i = 1; i<counter.length; i++) {
            if (counter[i] == 0) {
                result[1] = i;
            } else if (counter[i] == 2) {
                result[0] = i;
            }
        }
        
        return result;
    }
}
```





## 位运算(可以用hashset或者hashmap来实现)

### Leetcode717 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

示例 1:

输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
示例 2:

输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符

```java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int start = 0 ;
        while(start<bits.length-1){
            if(bits[start] == 0){
                start++;
            }else{
                start+=2;
            }
        }
        return start == bits.length-1;
    }
}
```



### [1.Leetcode136 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，**除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素**。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

> 解题思路：用异或运算

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int num:nums){
            res ^= num;
        }
        return res;
    }
}
```

### [1.Leetcode442 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)


给定一个整数数组 a，其中1 ≤ a[i] ≤ *n* （*n*为数组长度）, 其中有些元素出现**两次**而其他元素出现**一次**。

找到所有出现**两次**的元素。

你可以不用到任何额外空间并在O(*n*)时间复杂度内解决这个问题吗？

**示例：**

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

> 解题思路：可以在输入数组中用数字的正负来表示该位置所对应数字是否已经出现过。**遍历输入数组，给对应位置的数字取相反数，如果已经是负数，说明前面已经出现过，直接放入输出数组。**

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            int num = Math.abs(nums[i]);
            if(nums[num-1]>0){
                nums[num-1] *= -1;
            }else{
                res.add(num);
            }
        }
        return res;
    }
}
```



### [2.Leetcode137 只出现一次的数字II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，**除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次**的元素。

 

示例 1：

输入：nums = [2,2,3,2]
输出：3
示例 2：

输入：nums = [0,1,0,1,0,1,99]
输出：99

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}


```



```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}

```

### [3.Leetcode260 只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，**其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。**你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

示例 1：

输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
示例 2：

输入：nums = [-1,0]
输出：[-1,0]
示例 3：

输入：nums = [0,1]
输出：[1,0]

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int ret = 0;
        for (int n : nums) {
            ret ^= n;
        }
        int div = 1;
        while ((div & ret) == 0) {
            div <<= 1;
        }
        int a = 0, b = 0;
        for (int n : nums) {
            if ((div & n) != 0) {
                a ^= n;
            } else {
                b ^= n;
            }
        }
        return new int[]{a, b};
    }
}

```



```java
class Solution {
    public int[] singleNumber(int[] nums) {
        HashMap<Integer, Integer> temp = new HashMap<>();
        for (int e : nums)
        {
            int count = temp.getOrDefault(e, 0) + 1;
            temp.put(e, count);
        }
        int[] result = new int[2];
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : temp.entrySet())
        {
            if (entry.getValue() == 1)
            {
                result[i] = entry.getKey();
                i++;
            }
        }
        return result;
    }
}


```

### [3.剑指OfferII070 排序数组中只出现一次的数字](https://leetcode-cn.com/problems/skFtm2/)

给定一个只包含整数的有序数组 nums ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

 

示例 1:

输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
示例 2:

输入: nums =  [3,3,7,7,10,11,11]
输出: 10

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int l = 0,r = nums.length-1;
        while(l<r){
            int mid = l+r>>1;
            if(mid%2==1) mid--;
            if(nums[mid]==nums[mid+1]){
                l = mid+2;
            }else{
                r = mid-1;
            }
        }
        return nums[l];
    }
}
```



## 应用场景操作-如何操作  规律操作 替换操作 几个操作

### Leetcode397 整数替换


给定一个正整数 `n` ，你可以做如下操作：

1. 如果 `n` 是偶数，则用 `n / 2`替换 `n` 。
2. 如果 `n` 是奇数，则可以用 `n + 1`或`n - 1`替换 `n` 。

`n` 变为 `1` 所需的最小替换次数是多少？

 

**示例 1：**

```
输入：n = 8
输出：3
解释：8 -> 4 -> 2 -> 1
```

**示例 2：**

```
输入：n = 7
输出：4
解释：7 -> 8 -> 4 -> 2 -> 1
或 7 -> 6 -> 3 -> 2 -> 1
```

```java
class Solution {
    public int integerReplacement(int n) {
      return (int)func((long)n);
    }
    public long func(long n){
        if(n ==1) return 0;
      if(n%2==0){
          return  1 + func(n/2);
      }else  { 
          return 1 + Math.min(func(n+1),func(n-1));
      }
    }
}

```

### Leetcode365 水壶问题

有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

你允许：

装满任意一个水壶
清空任意一个水壶
从一个水壶向另外一个水壶倒水，直到装满或者倒空
示例 1: (From the famous "Die Hard" example)

输入: x = 3, y = 5, z = 4
输出: True
示例 2:

输入: x = 2, y = 6, z = 5
输出: False

```java
class Solution {
    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {
        // 该题数学公式可求解就是判断z判断是不是x和y最大公约数的倍数
        // 判断
        if(jug1Capacity+jug2Capacity<targetCapacity){
            return false;
        }
        if(jug1Capacity==0 || jug2Capacity==0){
            return targetCapacity==0 || jug1Capacity+jug2Capacity==targetCapacity;
        }
        return targetCapacity%gcd(jug1Capacity,jug2Capacity)==0;
    }

    public int gcd(int x,int y){
        int remain = x % y;
        while(remain!=0){
            x = y;
            y = remain;
            remain = x % y;
        }
        return y;
    }
}
```

## 快乐数

### Leetcode202 快乐数

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
- 如果 可以变为  1，那么这个数就是快乐数。

如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

示例 1：

输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
示例 2：

输入：n = 2
输出：false

```java
class Solution {
    public int bitSqureSum(int n){
        int sum = 0;
        while(n>0){
            int bit = n%10;
            sum += bit*bit;
            n = n/10;
        }
        return sum;
    }

    public boolean isHappy(int n) {
        int slow = n;
        int fast = n;
        do{
            slow = bitSqureSum(slow);
            fast = bitSqureSum(fast);
            fast = bitSqureSum(fast);

        }while(slow!=fast);
        return slow==1;
    }
}
```



## 数学知识（比特 数字1的个数）

### 计算n个数内的质数和

```java
int SumOfPrime(int n)
{
    int i, k, sum = 0;
    for (i = 2; i < n; i++)
    {
        bool prime = true;
        for (k = 2; k <= i / 2; k++)
        {
            if (i % k == 0)
            {
                prime = false;
                break;
            }
        }
        if (prime)
            sum += i;
    }
    return sum;
}

```



### Leetcode717 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

示例 1:

输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
示例 2:

输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符

```java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int start = 0 ;
        while(start<bits.length-1){
            if(bits[start] == 0){
                start++;
            }else{
                start+=2;
            }
        }
        return start == bits.length-1;
    }
}
```



### Leetcode397 整数替换


给定一个正整数 `n` ，你可以做如下操作：

1. 如果 `n` 是偶数，则用 `n / 2`替换 `n` 。
2. 如果 `n` 是奇数，则可以用 `n + 1`或`n - 1`替换 `n` 。

`n` 变为 `1` 所需的最小替换次数是多少？

 

**示例 1：**

```
输入：n = 8
输出：3
解释：8 -> 4 -> 2 -> 1
```

**示例 2：**

```
输入：n = 7
输出：4
解释：7 -> 8 -> 4 -> 2 -> 1
或 7 -> 6 -> 3 -> 2 -> 1
```

```java
class Solution {
    public int integerReplacement(int n) {
      return (int)func((long)n);
    }
    public long func(long n){
        if(n ==1) return 0;
      if(n%2==0){
          return  1 + func(n/2);
      }else  { 
          return 1 + Math.min(func(n+1),func(n-1));
      }
    }
}

```



### Leetcode611 有效三角形的个数

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:

输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3

```java
class Solution {
    public int triangleNumber(int[] nums) {
        // 结果
        int res = 0;
        // 排序
        Arrays.sort(nums);
        for(int i=2;i<nums.length;i++){
            int left = 0;
            int right = i-1;
            // 开始
            while(left<right){
                //判断
                if(nums[left]+nums[right]>nums[i]){
                    res += (right-left);
                    right--;
                }else if(nums[left]+nums[right]<=nums[i]){
                    left++;
                }
            }
        }
        return res;
    }
}
```



### [Leetcode191 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

 

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。


示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int sum = 0;
	        while(n!=0) {
	        	sum++;
	        	n &= (n-1);
	        }
	        return sum;
    }
}
```

### [Leetcode233 数字1的个数](https://leetcode-cn.com/problems/number-of-digit-one/)

给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。

 

示例 1：

输入：n = 13
输出：6
示例 2：

输入：n = 0
输出：0

**暴力解法**

```java
class Solution {
    public int countDigitOne(int n) {
        int ans = 0;
        for (int i = 1; i <= n; i++) {
            int count = 0;
            int num = i;
            while (num != 0) {
                // 从个位数开始一位一位的和1比较
                if (num % 10 == 1) {
                    count++;
                }
                num /= 10;
            }
            ans += count;
        }
        return ans;
    }
}

```

**动态规划**

```java
class Solution {
    public int countDigitOne(int n) {
        if(n==0){
            return 0;
        }
        int ans = 0;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        for (int i = 1; i <= n; i++) {
            dp[i] = dp[i % 10] + dp[i / 10];
            ans += dp[i];
        }
        return ans;
    }
}

```

**找规律**

```java
class Solution {
    public int countDigitOne(int n) {
        // 2021
        int ans = 0;
        for (int i = 1; i <= n; i *= 10) {
            ans += (n / (i * 10)) * i + Math.min(Math.max(n % (i * 10) - i + 1,0), i);
        }
        return ans;
    }
}

```

### [Leetcode008字符串转整数atoi](https://leetcode-cn.com/problems/string-to-integer-atoi/)

请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。

函数 myAtoi(string s) 的算法如下：

读入字符串并丢弃无用的前导空格
检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。
读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。
将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。
如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。
返回整数作为最终结果。
注意：

本题中的空白字符只包括空格字符 ' ' 。
除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。


示例 1：

输入：s = "42"
输出：42
解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。
第 1 步："42"（当前没有读入字符，因为没有前导空格）
         ^
第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）
         ^
第 3 步："42"（读入 "42"）
           ^
解析得到整数 42 。
由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。
示例 2：

输入：s = "   -42"
输出：-42
解释：
第 1 步："   -42"（读入前导空格，但忽视掉）
            ^
第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）
             ^
第 3 步："   -42"（读入 "42"）
               ^
解析得到整数 -42 。
由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。

```java
class Solution {
    //1.去除空格
    //2.判断正负号
    //3.判断是否为数字 判断是否超过最大值
    public int myAtoi(String s) {
        // 用while来做
        char[] arr = s.toCharArray();
        int index = 0;
        int len = arr.length;
        // 先去除空格
        while(index<len&&arr[index]==' '){
            index++;
        }
        // 判断
        if(index==len){
            return 0;
        }
        // 再去判断正负号
        boolean flag = true;
        if(arr[index]=='+'){
            flag = true;
            index++;
        }else if(arr[index]=='-'){
            flag = false;
            index++;
        }
        // 之后再去判断是否为数字
        // 结果
        int res = 0;
        while(index<len&&Character.isDigit(arr[index])){
            int digit = arr[index] - '0';
            // 判断是否超过最大值范围 res*10+digit>Integer.max_value;
            if((res)>(Integer.MAX_VALUE-digit)/10){
                return flag?Integer.MAX_VALUE:Integer.MIN_VALUE;
            }
            res = res*10 + digit;
            index++;
        }
        return flag?res:(-1)*res;

    }
}
```

### Leetcode1027 最长等差数列

给定一个整数数组 A，返回 A 中最长等差子序列的长度。

回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。

 

示例 1：

输入：[3,6,9,12]
输出：4
解释： 
整个数组是公差为 3 的等差数列。
示例 2：

输入：[9,4,7,2,10]
输出：3
解释：
最长的等差子序列是 [4,7,10]。

```java
class Solution {
    public int longestArithSeqLength(int[] A) {
        int len = A.length;
        int[][] dp = new int[len][len];
        for(int i = 0; i < len; i++){
            for(int j = 0; j < len; j++){
                dp[i][j] = 2;
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        int max = 0;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j < len; j++){
                int target = 2 * A[i] - A[j];
                if(map.containsKey(target)) dp[i][j] = dp[map.get(target)][i] + 1;
                max = Math.max(max, dp[i][j]);
            }
            map.put(A[i], i);
        }
        return max;
    }
}
```

### Leetcode1262 可被三整除的最大和

给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。

 

示例 1：

输入：nums = [3,6,5,1,8]
输出：18
解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
示例 2：

输入：nums = [4]
输出：0
解释：4 不能被 3 整除，所以无法选出数字，返回 0。

```java
class Solution {
    public int maxSumDivThree(int[] nums) {
        int[] dp = new int[3];
        dp[nums[0] % 3] = nums[0];
        for (int i = 1; i < nums.length; i++) {
            int[] temp = new int[3];
            for (int k = 0; k < 3; k++)
                temp[k] = dp[k];
            for (int j = 0; j < 3; j++) {
                int index = (temp[j] + nums[i]) % 3;
                dp[index] = Math.max(dp[index], temp[j] + nums[i]);
            }
        }
        return dp[0];
    }
}
```

### Leetcode65 有效数字

有效数字（按顺序）可以分成以下几个部分：

一个 小数 或者 整数
（可选）一个 'e' 或 'E' ，后面跟着一个 整数
小数（按顺序）可以分成以下几个部分：

（可选）一个符号字符（'+' 或 '-'）
下述格式之一：
至少一位数字，后面跟着一个点 '.'
至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字
一个点 '.' ，后面跟着至少一位数字
整数（按顺序）可以分成以下几个部分：

（可选）一个符号字符（'+' 或 '-'）
至少一位数字
部分有效数字列举如下：

["2", "0089", "-0.1", "+3.14", "4.", "-.9", "2e10", "-90E3", "3e+7", "+6e-1", "53.5e93", "-123.456e789"]
部分无效数字列举如下：

["abc", "1a", "1e", "e3", "99e2.5", "--6", "-+3", "95a54e53"]
给你一个字符串 s ，如果 s 是一个 有效数字 ，请返回 true 。

 

```java
class Solution {
    public boolean isNumber(String s) {
        boolean ans = true, occur = false;
        int n = s.length();
        for (int i=0; i<n; i++) {
            char ch = s.charAt(i);
            if (ch == '+' || ch == '-') {
                if (!(i < n-1 && ((s.charAt(i+1)-'0' >= 0 && s.charAt(i+1)-'0' <= 9) || s.charAt(i+1) == '.')))
                    return false;
            }
            else if (ch == '.') {
                if (!((i > 0 && s.charAt(i-1)-'0'>=0 && s.charAt(i-1)-'0'<=9) ||
                        (i < n-1 && s.charAt(i+1)-'0'>=0 && s.charAt(i+1)-'0'<=9)) || occur)
                    return false;
                occur = true;
            }
            else if (ch == 'e' || ch == 'E') {
                if (i == 0 || i == n-1)
                    return false;
                else {
                    for (int j=i+1; j<n; j++) {
                        char c = s.charAt(j);
                        if ((c == '+' || c == '-') && !(j == i+1 && j != n-1))
                            return false;
                        if (c == '.' || (c-'a'>=0 && c-'a'<=25) || (c-'A'>=0 && c-'A'<=25))
                            return false;
                    }
                    break;
                }
            }
            else if (ch-'0' >= 0 && ch-'0'<=9) {
                if (i < n-1 && (s.charAt(i+1) == '+' || s.charAt(i+1) == '-'))
                    return false;
            }
            else
                return false;
        }
        return ans;
    }
}
```

### Leetcode1318 或运算的最小翻转次数

给你三个正整数 a、b 和 c。

你可以对 a 和 b 的二进制表示进行位翻转操作，返回能够使按位或运算   a OR b == c  成立的最小翻转次数。

「位翻转操作」是指将一个数的二进制表示任何单个位上的 1 变成 0 或者 0 变成 1 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/11/sample_3_1676.png)

输入：a = 2, b = 6, c = 5
输出：3
解释：翻转后 a = 1 , b = 4 , c = 5 使得 a OR b == c

```java
class Solution {
    public int minFlips(int a, int b, int c) {
        int d = (a | b)^c;
        return Integer.bitCount(d) + Integer.bitCount(a&b&d);
    }
}
```

## 丑数

### Leetcode263 丑数

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 

示例 1：

输入：n = 6
输出：true
解释：6 = 2 × 3
示例 2：

输入：n = 8
输出：true
解释：8 = 2 × 2 × 2
示例 3：

输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。

```java
class Solution {
    //让其对5 3 2一直不停的
    public boolean isUgly(int num) {
        //判断一个是否是丑数
        if(num<1){
            return false;
        }
        while(num%5==0){
            num/=5;
        }
        while(num%3==0){
            num/=3;
        }
        while(num%2==0){
            num>>=1;
        }
        return num==1;
    }
}
```

### Leetcode264 丑数II

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 

示例 1：

输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
示例 2：

输入：n = 1
输出：1
解释：1 通常被视为丑数。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for(int i=2;i<=n;i++){
            int num2 = dp[p2]*2, num3 = dp[p3]*3, num5 = dp[p5]*5;
            dp[i] = Math.min(Math.min(num2,num3),num5);
            if(dp[i]==num2){
                p2++;
            }
            if(dp[i]==num3){
                p3++;
            }
            if(dp[i]==num5){
                p5++;
            }
        }
        return dp[n];
    }
}
```

### Leetcode1201 丑数III

给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。

丑数是可以被 a 或 b 或 c 整除的 正整数 。

 

示例 1：

输入：n = 3, a = 2, b = 3, c = 5
输出：4
解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。
示例 2：

输入：n = 4, a = 2, b = 3, c = 4
输出：6
解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。
示例 3：

输入：n = 5, a = 2, b = 11, c = 13
输出：10
解释：丑数序列为 2, 4, 6, 8, 10, 11, 12, 13... 其中第 5 个是 10。

```java
class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {
        if (n < 1 || a < 1 || b < 1 || c < 1) throw new IllegalArgumentException("invalid param");
        
        // 两两组合的最小公倍数
        long lcmAB = lcm(a, b);
        long lcmAC = lcm(a, c);
        long lcmBC = lcm(b, c);
        // 三个数的最小公倍数
        long lcm = lcm(lcmAB, c);
        
        // lcm之内的数字数目，即一个周期内的元素数
        long m = lcm / a + lcm / b + lcm / c - lcm / lcmAB - lcm / lcmAC - lcm / lcmBC + 1;

        long epoch = n / m;
        long r = n % m;
        long result = epoch * lcm;
		
        if (r > 0) {
            // 二分查找，范围缩小为1～lcm
            long left = 1, right = lcm;
            while (left < right) {
                long mid = left + (right - left) / 2;
                long count = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmAC - mid / lcmBC + mid / lcm;
                if (count >= r) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            // 最后left就是要查找的值
            result += left;
        }

        return (int)result;
    }
    
    // 最小公倍数
    private long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }
    
    // 最大公因数
    private long gcd(long x, long y) {
        if (x == 0) return y;
        return gcd(y % x, x);
    }
}
```

### Leetcode313 超级丑数

超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。

给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。

题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。

 

示例 1：

输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
示例 2：

输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<Long>queue=new PriorityQueue<>();
        long res=1;
        for(int i=1;i<n;i++){
            for(int prime:primes){
                queue.add(prime*res);
            }
            res=queue.poll();
            while(!queue.isEmpty()&&res==queue.peek()) queue.poll();
        }
        return (int)res;
        
    }
}
```

## Nim游戏和石子游戏

### Leetcode292 Nim游戏

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合，你作为先手。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

 

示例 1：

输入：n = 4
输出：false 
解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
示例 2：

输入：n = 1
输出：true

```java
class Solution {
    public boolean canWinNim(int n) {
        return (n%4!=0);
    }
}
```

### Leetcode877 石子游戏

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。

 

示例：

输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        //dp其实就是存储了递归过程中的数值
        //dps[i][j]代表从i到j所能获得的最大的绝对分数
        //（比如为1就说明亚历克斯从i到j可以赢李1分）
        //如何计算dps[i][j]呢:max(piles[i]-dp[i+1][j],piles[j]-dp[i][j-1]);
        //这里减去dps数组是因为李也要找到最大的
        //最后dps=[5 2 4 1]
        //        [0 3 1 4]
        //        [0 0 4 1]
        //        [0 0 0 5]
        int n=piles.length;
        int [][]dps=new int[n][n];
        //dps[i][i]存储当前i的石子数
        for(int i=0;i<n;i++)
            dps[i][i]=piles[i];
        //d=1,其实代表，先算两个子的时候
        for(int d=1;d<n;d++)
        {
            //有多少组要比较
            for(int j=0;j<n-d;j++)
            {
                //比较j到d+j
                dps[j][d+j]=Math.max(piles[j]-dps[j+1][d+j],piles[d+j]-dps[j][d+j-1]);
            }
        }
        return dps[0][n-1]>0;
    }
}
```

### Leetcode1140 石子游戏II

亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。

亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。

在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。

游戏一直持续到所有石子都被拿走。

假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。

 

示例：

输入：piles = [2,7,9,4,4]
输出：10
解释：
如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。 
如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。
所以我们返回更大的 10。 

```java
class Solution {
   public int stoneGameII(int[] piles) {
        int len = piles.length, sum = 0;
        int[][] dp = new int[len][len + 1];
        for (int i = len - 1; i >= 0; i--) {
            sum += piles[i];
            for (int M = 1; M <= len; M++) {
                if (i + 2 * M >= len) {
                    dp[i][M] = sum;
                } else {
                    for (int x = 1; x <= 2 * M; x++) {
                        dp[i][M] = Math.max(dp[i][M], sum - dp[i + x][Math.max(M, x)]);
                    }
                }
            }
        }
        return dp[0][1];
    }
}
```

### Leetcode1406 石子游戏III

Alice 和 Bob 用几堆石子在做游戏。几堆石子排成一行，每堆石子都对应一个得分，由数组 stoneValue 给出。

Alice 和 Bob 轮流取石子，Alice 总是先开始。在每个玩家的回合中，该玩家可以拿走剩下石子中的的前 1、2 或 3 堆石子 。比赛一直持续到所有石头都被拿走。

每个玩家的最终得分为他所拿到的每堆石子的对应得分之和。每个玩家的初始分数都是 0 。比赛的目标是决出最高分，得分最高的选手将会赢得比赛，比赛也可能会出现平局。

假设 Alice 和 Bob 都采取 最优策略 。如果 Alice 赢了就返回 "Alice" ，Bob 赢了就返回 "Bob"，平局（分数相同）返回 "Tie" 。

 

示例 1：

输入：values = [1,2,3,7]
输出："Bob"
解释：Alice 总是会输，她的最佳选择是拿走前三堆，得分变成 6 。但是 Bob 的得分为 7，Bob 获胜。
示例 2：

输入：values = [1,2,3,-9]
输出："Alice"
解释：Alice 要想获胜就必须在第一个回合拿走前三堆石子，给 Bob 留下负分。
如果 Alice 只拿走第一堆，那么她的得分为 1，接下来 Bob 拿走第二、三堆，得分为 5 。之后 Alice 只能拿到分数 -9 的石子堆，输掉比赛。
如果 Alice 拿走前两堆，那么她的得分为 3，接下来 Bob 拿走第三堆，得分为 3 。之后 Alice 只能拿到分数 -9 的石子堆，同样会输掉比赛。
注意，他们都应该采取 最优策略 ，所以在这里 Alice 将选择能够使她获胜的方案。

```java
class Solution {
    private Integer[] memo;
    public String stoneGameIII(int[] stoneValue) {
        memo = new Integer[stoneValue.length];
        int relative = stoneGameIII(stoneValue, 0);
        if(relative > 0)
            return "Alice";
        else if(relative == 0)
            return "Tie";
        return "Bob";
    }
    
    public int stoneGameIII(int[] stoneValue, int start) {
        if(start >= stoneValue.length)
            return 0;
        if(memo[start] != null) return memo[start];
        int ans = stoneValue[start] - stoneGameIII(stoneValue, start + 1);
        if(start + 1 < stoneValue.length)
            ans = Math.max(ans, stoneValue[start] + stoneValue[start+1] - stoneGameIII(stoneValue, start + 2));
        if(start + 2 < stoneValue.length)
            ans = Math.max(ans, stoneValue[start] + stoneValue[start+1] + stoneValue[start+2] - stoneGameIII(stoneValue, start + 3));
        return memo[start] = ans;
    }
}
```

### Leetcode1510 石子游戏IV

Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。

一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。

如果石子堆里没有石子了，则无法操作的玩家输掉游戏。

给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。

 

示例 1：

输入：n = 1
输出：true
解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。
示例 2：

输入：n = 2
输出：false
解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。

```java
class Solution {
        public boolean winnerSquareGame(int n) {
            // 动态规划，计算n-i*i的情况
            boolean[] state = new boolean[n + 1];
            for (int i = 1; i <= n; i++) {
                int sqrt = (int) Math.sqrt(i);
                if (sqrt * sqrt == i) {
                    // 当前石子数是平方数，稳赢
                    state[i] = true;
                } else {
                    // 当前石子数不是平方数，拿掉i*i个后如果自己之前是输的，那Bob按这个拿法肯定输，Alice就赢了
                    for (int j = 1; j * j < i; j++) {
                        if (state[i - j * j] == false) {
                            state[i] = true;
                            break;
                        }
                    }
                }
            }
            return state[n];
        }
    }

```



### Leetcode1563 石子游戏V

几块石子 排成一行 ，每块石子都有一个关联值，关联值为整数，由数组 stoneValue 给出。

游戏中的每一轮：Alice 会将这行石子分成两个 非空行（即，左侧行和右侧行）；Bob 负责计算每一行的值，即此行中所有石子的值的总和。Bob 会丢弃值最大的行，Alice 的得分为剩下那行的值（每轮累加）。如果两行的值相等，Bob 让 Alice 决定丢弃哪一行。下一轮从剩下的那一行开始。

只 剩下一块石子 时，游戏结束。Alice 的分数最初为 0 。

返回 Alice 能够获得的最大分数 。

 

示例 1：

输入：stoneValue = [6,2,3,4,5,5]
输出：18
解释：在第一轮中，Alice 将行划分为 [6，2，3]，[4，5，5] 。左行的值是 11 ，右行的值是 14 。Bob 丢弃了右行，Alice 的分数现在是 11 。
在第二轮中，Alice 将行分成 [6]，[2，3] 。这一次 Bob 扔掉了左行，Alice 的分数变成了 16（11 + 5）。
最后一轮 Alice 只能将行分成 [2]，[3] 。Bob 扔掉右行，Alice 的分数现在是 18（16 + 2）。游戏结束，因为这行只剩下一块石头了。

```java
class Solution {
    public int stoneGameV(int[] stoneValue) {
        // 存储分数
        int n = stoneValue.length;
        // score的含义表示从left到right之间最大的分数
        int[][] score = new int[n][n];
        // dfs
        return dfs(stoneValue,score,0,n-1);
    }
    // 回溯score的含义
    public int dfs(int[] stoneValue,int[][] score,int left,int right){
        // 截止条件
        if(left==right){
            return 0;
        }
        if(score[left][right]!=0){
            return score[left][right];
        }
        // 存储
        int sum = 0;
        for(int i=left;i<=right;i++){
            sum += stoneValue[i];
        }
        // 别的计算
        // 左边
        int suml = 0;
        for(int i=left;i<right;i++){
            suml += stoneValue[i];
            int sumr = sum-suml;
            // 开始比较
            if(suml>sumr){
                // 扔掉左边
                score[left][right] = Math.max(score[left][right],dfs(stoneValue,score,i+1,right)+sumr);
            }else if(suml<sumr){
                // 扔掉右边
                score[left][right] = Math.max(score[left][right],dfs(stoneValue,score,left,i)+suml);
            }else{
                score[left][right] = Math.max(score[left][right],Math.max(dfs(stoneValue,score,left,i),dfs(stoneValue,score,i+1,right))+suml);
            }
        }
        return score[left][right];
    }
}
```



### Leetcode1686 石子游戏VI

Alice 和 Bob 轮流玩一个游戏，Alice 先手。

一堆石子里总共有 n 个石子，轮到某个玩家时，他可以 移出 一个石子并得到这个石子的价值。Alice 和 Bob 对石子价值有 不一样的的评判标准 。双方都知道对方的评判标准。

给你两个长度为 n 的整数数组 aliceValues 和 bobValues 。aliceValues[i] 和 bobValues[i] 分别表示 Alice 和 Bob 认为第 i 个石子的价值。

所有石子都被取完后，得分较高的人为胜者。如果两个玩家得分相同，那么为平局。两位玩家都会采用 最优策略 进行游戏。

请你推断游戏的结果，用如下的方式表示：

如果 Alice 赢，返回 1 。
如果 Bob 赢，返回 -1 。
如果游戏平局，返回 0 。


示例 1：

输入：aliceValues = [1,3], bobValues = [2,1]
输出：1
解释：
如果 Alice 拿石子 1 （下标从 0开始），那么 Alice 可以得到 3 分。
Bob 只能选择石子 0 ，得到 2 分。
Alice 获胜。

```java
class Solution {
    public int stoneGameVI(int[] A, int[] B) {
        int n = A.length;
        //0存Alice与Bob认为当前石子的价值偶总和，1存Alice认为的石子的价值，2存Bob认为的石子价值
        int[][] sum = new int[n][3];
        for (int i = 0; i < n; i++) sum[i] = new int[]{A[i] + B[i], A[i], B[i]};
        //从大到小排序
        Arrays.sort(sum, (o1, o2) -> o2[0] - o1[0]);
        int a = 0, b = 0;
        for (int i = 0; i < n; i++) {
            //偶数 Alice从  0 2 4 ... a是Alice拿到的总价值
            if ((i & 1) == 0) a += sum[i][1];
            //奇数 Bob从 1 3 5 .... b是Bob拿到的总价值
            else b += sum[i][2];
        }
        return Integer.compare(a, b);
    }
}
```

### Leetcode1690 石子游戏VII

石子游戏中，爱丽丝和鲍勃轮流进行自己的回合，爱丽丝先开始 。

有 n 块石子排成一排。每个玩家的回合中，可以从行中 移除 最左边的石头或最右边的石头，并获得与该行中剩余石头值之 和 相等的得分。当没有石头可移除时，得分较高者获胜。

鲍勃发现他总是输掉游戏（可怜的鲍勃，他总是输），所以他决定尽力 减小得分的差值 。爱丽丝的目标是最大限度地 扩大得分的差值 。

给你一个整数数组 stones ，其中 stones[i] 表示 从左边开始 的第 i 个石头的值，如果爱丽丝和鲍勃都 发挥出最佳水平 ，请返回他们 得分的差值 。

 

示例 1：

输入：stones = [5,3,1,4,2]
输出：6
解释：
- 爱丽丝移除 2 ，得分 5 + 3 + 1 + 4 = 13 。游戏情况：爱丽丝 = 13 ，鲍勃 = 0 ，石子 = [5,3,1,4] 。
- 鲍勃移除 5 ，得分 3 + 1 + 4 = 8 。游戏情况：爱丽丝 = 13 ，鲍勃 = 8 ，石子 = [3,1,4] 。
- 爱丽丝移除 3 ，得分 1 + 4 = 5 。游戏情况：爱丽丝 = 18 ，鲍勃 = 8 ，石子 = [1,4] 。
- 鲍勃移除 1 ，得分 4 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [4] 。
- 爱丽丝移除 4 ，得分 0 。游戏情况：爱丽丝 = 18 ，鲍勃 = 12 ，石子 = [] 。
得分的差值 18 - 12 = 6 。

```java
class Solution {
    public int stoneGameVII(int[] stones) {
        int len = stones.length;
        //dp数组，dp[i][j]表示从i到j两人最后的最大差值
        int[][] dp = new int[len][len];
        //pre数组，为的是求拿去stones[i]或stones[j]之后元素的和
        //pre[i + 1]表示stones[0] + stones[1] + stones[2] + ... + stones[i] (i的范围:[0, len - 1])
        int[] pre = new int[len + 1];
        for(int i = 0; i < len; i++)
            pre[i + 1] = pre[i] + stones[i];

        //dp数组初始化：len = j - i + 1 = 1
        //dp[i][j]
        //可以注释掉，便于理解暂时不注释掉
        for(int i = 0; i < len; i++) 
            dp[i][i] = 0;
        
        //len >= 2
        for(int k = 2; k <= len; k++) {
            for(int i = 0; i + k - 1 <= len - 1; i++) {
                //根据i和长度计算j
                int j = i + k - 1;
                //第一个人：[0, j] - [0, i] ==> (i, j]
                //第二个人：dp[i + 1][j]
                //第一个人：[0, j - 1] - [0, i - 1] ==> [i, j)
                //第二个人：dp[i][j - 1]
                //计算差值
                dp[i][j] = Math.max(pre[j + 1] - pre[i + 1] - dp[i + 1][j], pre[j] - pre[i] - dp[i][j - 1]);
            }
        }
        return dp[0][len - 1];
    }
}
```

### Leetcode1872 石子 游戏VIII

Alice 和 Bob 玩一个游戏，两人轮流操作， Alice 先手 。

总共有 n 个石子排成一行。轮到某个玩家的回合时，如果石子的数目 大于 1 ，他将执行以下操作：

选择一个整数 x > 1 ，并且 移除 最左边的 x 个石子。
将 移除 的石子价值之 和 累加到该玩家的分数中。
将一个 新的石子 放在最左边，且新石子的值为被移除石子值之和。
当只剩下 一个 石子时，游戏结束。

Alice 和 Bob 的 分数之差 为 (Alice 的分数 - Bob 的分数) 。 Alice 的目标是 最大化 分数差，Bob 的目标是 最小化 分数差。

给你一个长度为 n 的整数数组 stones ，其中 stones[i] 是 从左边起 第 i 个石子的价值。请你返回在双方都采用 最优 策略的情况下，Alice 和 Bob 的 分数之差 。

 

示例 1：

输入：stones = [-1,2,-3,4,-5]
输出：5
解释：
- Alice 移除最左边的 4 个石子，得分增加 (-1) + 2 + (-3) + 4 = 2 ，并且将一个价值为 2 的石子放在最左边。stones = [2,-5] 。
- Bob 移除最左边的 2 个石子，得分增加 2 + (-5) = -3 ，并且将一个价值为 -3 的石子放在最左边。stones = [-3] 。
两者分数之差为 2 - (-3) = 5 。

```java
class Solution {
    public int stoneGameVIII(int[] stones) {
        //Alice想要Alice-Bob最大化
        //Bob想要Bob-Alice最小化也就是Alice-Bob最大化
        //所以对于任何一个决策者要达到的目的是一样的 都是想要Alice-Bob在当前决策区间内能够最大化
        //定义dp问题 dp[i]表示当前i~n-1的区间内 Alice-Bob能够达到的最大值
        //dp[i]=Math.max(preSum[i]-dp[i+1],preSum[i+1]-dp[i+2]...preSum[n-2]-dp[n-1])
        //其中preSum(i+1)-dp[i+2]....preSum[n-2]-dp[n-1]=dp[i+1]
        //所以dp[i]=Math.max(preSum[i]-dp[i+1],dp[i+1]);
        int n = stones.length;
        int[] sum = new int[n + 1];
        for(int i = 0; i < n; i++){
            sum[i + 1] = sum[i] + stones[i];
        }

        int[] dp = new int[n + 1];
        dp[n] = sum[n];

        for(int i = n - 1; i >= 2; i--){
            dp[i] = Math.max(dp[i + 1], sum[i] - dp[i + 1]);
        }
        return dp[2];
    }
}
```



## 概率游戏(取数)

### Leetcode464 我能赢吗

在 "100 game" 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到或超过 100 的玩家，即为胜者。

如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？

例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 >= 100。

给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？

你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。

示例：

输入：
maxChoosableInteger = 10
desiredTotal = 11

输出：
false

解释：
无论第一个玩家选择哪个整数，他都会失败。
第一个玩家可以选择从 1 到 10 的整数。
如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。
第二个玩家可以通过选择整数 10（那么累积和为 11 >= desiredTotal），从而取得胜利.
同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。

```java
class Solution {
    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {
        if(maxChoosableInteger >= desiredTotal) return true;
        if((1 + maxChoosableInteger) * maxChoosableInteger / 2 < desiredTotal) return false;

        return dfs(0, desiredTotal, new Boolean[1 << maxChoosableInteger], maxChoosableInteger);
    }

    private boolean dfs(int state, int desiredTotal, Boolean[] dp, int maxChoosableInteger){
        if(dp[state] != null){
            return dp[state];
        }

        for(int i = 1; i <= maxChoosableInteger; i++){
            int cur = 1 << (i - 1);
            if((cur & state) != 0){
                continue;
            }

            if(i >= desiredTotal || !dfs(cur|state, desiredTotal - i, dp, maxChoosableInteger)){
                return dp[state] = true;
            }
        }
        return dp[state] = false;
    }
}


```



### [Leetcode292 Nim游戏](https://leetcode-cn.com/problems/nim-game/)

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合，你作为先手。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

 

示例 1：

输入：n = 4
输出：false 
解释：如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。
示例 2：

输入：n = 1
输出：true

> 解决思路：
>
> 如果堆中石头的数量 n*n* 不能被 44 整除，那么你*总是*可以赢得 Nim 游戏的胜利。

让我们考虑一些小例子。显而易见的是，如果石头堆中只有一块、两块、或是三块石头，那么在你的回合，你就可以把全部石子拿走，从而在游戏中取胜。而如果就像题目描述那样，堆中恰好有四块石头，你就会失败。因为在这种情况下不管你取走多少石头，总会为你的对手留下几块，使得他可以在游戏中打败你。因此，要想获胜，在你的回合中，必须避免石头堆中的石子数为 4 的情况。

同样地，如果有五块、六块、或是七块石头，你可以控制自己拿取的石头数，总是恰好给你的对手留下四块石头，使他输掉这场比赛。但是如果石头堆里有八块石头，你就不可避免地会输掉，因为不管你从一堆石头中挑出一块、两块还是三块，你的对手都可以选择三块、两块或一块，以确保在再一次轮到你的时候，你会面对四块石头。

显然，它以相同的模式不断重复 n=4,8,12,16,\dotsn=4,8,12,16,…，基本可以看出是 44 的倍数。

```java
class Solution {
    public boolean canWinNim(int n) {
        return (n%4!=0);
    }
}
```







### Leetcode486 预测赢家

给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

 

示例 1：

输入：[1, 5, 2]
输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        // 预测赢家
        int n = nums.length;
        int[][] dp = new int[n][n];
        // 初始化
        for(int i=0;i<n;i++){
            // 对角线赋值
            dp[i][i] = nums[i];
        }

        // 转移方程从下到上
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                dp[i][j] = Math.max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);
            }
        }
        // 
        return dp[0][n-1]>=0;
    }
}
```

### Leetcode1227 飞机座位分配概率

有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。

剩下的乘客将会：

如果他们自己的座位还空着，就坐到自己的座位上，

当他们自己的座位被占用时，随机选择其他座位
第 n 位乘客坐在自己的座位上的概率是多少？

 

示例 1：

输入：n = 1
输出：1.00000
解释：第一个人只会坐在自己的位置上。
示例 2：

输入: n = 2
输出: 0.50000
解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5

```java
        return n == 1 ? 1.0 : 0.5;

```



```c++
class Solution {
public:
    double p[100001];
    double nthPersonGetsNthSeat(int n) {

        p[1] = 1.0;
        p[2] = 0.5;

        for (int i = 3; i <= n; i++) {
            double sum = 1.0 / i;
            for (int k = 2; k < i; k++) {
                sum += p[i - k + 1] / i;
            }
            p[i] = sum;
        }
        return p[n];
    }
};


```



```java
class Solution {
    public double nthPersonGetsNthSeat(int n) {
        return n == 1 ? 1.0 : 0.5;
    }
}
```



## 找规律

### Leetcode290 单词规律

给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

示例1:

输入: pattern = "abba", str = "dog cat cat dog"
输出: true
示例 2:

输入:pattern = "abba", str = "dog cat cat fish"
输出: false
示例 3:

输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false

```java
class Solution {
    public static boolean wordPattern(String pattern, String str) {
        if(pattern == null || str==null) return false;
        String[] string = str.split(" ");
        if(pattern.length() != string.length) return false;
        HashMap<Character,String> map = new HashMap<>();

        for(int i=0; i<pattern.length(); i++){
            char tmp = pattern.charAt(i);
            //key已经在
            if(map.containsKey(tmp)){
                //不对应就失败
                if(!map.get(tmp).equals(string[i])) return false;
            }
            //key不存在
            else{
                //两个value的值一样 a-dog b-dog->false
                if (map.containsValue(string[i])) return false;
                else
                //添加k-v值
                map.put(tmp,string[i]);
            }
        }
        return true;
    }
}
```



### Leetcode717 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

示例 1:

输入: 
bits = [1, 0, 0]
输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。
示例 2:

输入: 
bits = [1, 1, 1, 0]
输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符

```java
class Solution {
    public boolean isOneBitCharacter(int[] bits) {
        int start = 0 ;
        while(start<bits.length-1){
            if(bits[start] == 0){
                start++;
            }else{
                start+=2;
            }
        }
        return start == bits.length-1;
    }
}
```



### Leetcode932 漂亮数组

对于某些固定的 N，如果数组 A 是整数 1, 2, ..., N 组成的排列，使得：

对于每个 i < j，都不存在 k 满足 i < k < j 使得 A[k] * 2 = A[i] + A[j]。

那么数组 A 是漂亮数组。

 

给定 N，返回任意漂亮数组 A（保证存在一个）。

 

示例 1：

输入：4
输出：[2,1,4,3]
示例 2：

输入：5
输出：[3,1,2,5,4]

```java
/* A 是漂亮数组，则 a * A + b 也是漂亮数组 
 * A 为奇数漂亮数组，B 为偶数漂亮数组，A + B 为漂亮数组
 * 数组两两配对，左数组 * 2 - 1 一定是奇数组，右数组 * 2 一定为偶数组，合并一定为漂亮数组
 * 假设 [1] 是最小漂亮数组，按照上面规律递推得到的一定是漂亮数组。 
 * |1|1|1|1|1|1|1|1|
 * |1 2|1 2|1 2|1 2|
 * |1 3 2 4|1 3 2 4|
 * |1 5 3 7 2 6 4 8|
 */

class Solution {
    public int[] beautifulArray(int N) {
        int[] a = new int[N];
        Arrays.fill(a, 1);
        part(a, 0, N - 1);
        return a;
    }
    public void part(int[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        part(a, lo, mid);
        part(a, mid + 1, hi);
        for (int i = lo; i <= mid; i++) {
            a[i] = 2 * a[i] - 1;
        } 
        for (int i = mid + 1; i <= hi; i++) {
            a[i] = 2 * a[i];
        }
        return;
    }
}
```



### [Leetcode172 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

给定一个整数 n，返回 n! 结果尾数中零的数量。

示例 1:

输入: 3
输出: 0
解释: 3! = 6, 尾数中没有零。
示例 2:

输入: 5
输出: 1
解释: 5! = 120, 尾数中有 1 个零.

```java
class Solution {
    public int trailingZeroes(int n) {
         int count = 0;
        while(n >= 5) {
            count += n / 5;
            n /= 5;
        }
        return count;
    }
}
```





### [Leetcode38 外观数列](https://leetcode-cn.com/problems/count-and-say/)

给定一个正整数 n ，输出外观数列的第 n 项。

「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。

你可以将其视作是由递归公式定义的数字字符串序列：

countAndSay(1) = "1"
countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。
前五项如下：

1.     1
2.     11
3.     21
4.     1211
5.     111221
第一项是数字 1 
描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"
描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"
描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"
描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。

例如，数字字符串 "3322251" 的描述如下图：

![img](https://assets.leetcode.com/uploads/2020/10/23/countandsay.jpg)

**示例 1：**

```
输入：n = 1
输出："1"
解释：这是一个基本样例。
```

**示例 2：**

```
输入：n = 4
输出："1211"
解释：
countAndSay(1) = "1"
countAndSay(2) = 读 "1" = 一 个 1 = "11"
countAndSay(3) = 读 "11" = 二 个 1 = "21"
countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"
```

```java
class Solution {
    public String countAndSay(int n) {
        return countAndSay(n - 1, "1");
    }

    //1.     1
    //2.     11
    //3.     21
    //4.     1211
    //5.     111221
    public String countAndSay(int n, String s) {
        if (n == 0) return s;
        StringBuilder builder = new StringBuilder();
        int i = 0;
        while (i < s.length() - 1) {
            int count = 1;
            while (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {
                count++;
                i++;
            }
            builder.append(count).append(s.charAt(i));
            i++;
        }
        if (s.length() == 1 || s.charAt(s.length() - 1) != s.charAt(s.length() - 2))
            builder.append(1).append(s.charAt(s.length() - 1));

        return countAndSay(n - 1, builder.toString());
    }
}

```



### [Leetcode1553吃掉N个橘子的最少天数](https://leetcode-cn.com/problems/minimum-number-of-days-to-eat-n-oranges/)

厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子：

吃掉一个橘子。
如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子。
如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子。
每天你只能从以上 3 种方案中选择一种方案。

请你返回吃掉所有 n 个橘子的最少天数。

 

示例 1：

输入：n = 10
输出：4
解释：你总共有 10 个橘子。
第 1 天：吃 1 个橘子，剩余橘子数 10 - 1 = 9。
第 2 天：吃 6 个橘子，剩余橘子数 9 - 2*(9/3) = 9 - 6 = 3。（9 可以被 3 整除）
第 3 天：吃 2 个橘子，剩余橘子数 3 - 2*(3/3) = 3 - 2 = 1。
第 4 天：吃掉最后 1 个橘子，剩余橘子数 1 - 1 = 0。
你需要至少 4 天吃掉 10 个橘子。

**记忆化搜索**

```java
class Solution {
    
    Map<Integer,Integer> dict = new HashMap<Integer,Integer>();
    public int minDays(int n) {
        if(n<=1){
            return n;
        }
        //如果天数
        if(dict.containsKey(n)){
            return dict.get(n);
        }
        dict.put(n,Math.min( n%2+1+minDays(n/2) , n%3+1+minDays(n/3)));
        return dict.get(n);
    }
}
```

### [Leetcode781 森林中的兔子](https://leetcode-cn.com/problems/rabbits-in-forest/)

森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。

返回森林中兔子的最少数量。

示例:
输入: answers = [1, 1, 2]
输出: 5
解释:
两只回答了 "1" 的兔子可能有相同的颜色，设为红色。
之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。
设回答了 "2" 的兔子为蓝色。
此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。
因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。

输入: answers = [10, 10, 10]
输出: 11

输入: answers = []
输出: 0

```java
class Solution {
    public int numRabbits(int[] answers) {
        Map<Integer,Integer> dict = new HashMap<>();
        int num = 0;
        for(int answer:answers){
            if(dict.containsKey(answer)&&dict.get(answer)>0){
                dict.put(answer,dict.get(answer)-1);
            }else{
                num += answer+1;
                dict.put(answer,answer);
            }
        }
        return num;
    }
}
```

### [Leetcode984 不含AAA和BBB的字符串](https://leetcode-cn.com/problems/string-without-aaa-or-bbb/)

给定两个整数 A 和 B，返回任意字符串 S，要求满足：

S 的长度为 A + B，且正好包含 A 个 'a' 字母与 B 个 'b' 字母；
子串 'aaa' 没有出现在 S 中；
子串 'bbb' 没有出现在 S 中。


示例 1：

输入：A = 1, B = 2
输出："abb"
解释："abb", "bab" 和 "bba" 都是正确答案。
示例 2：

输入：A = 4, B = 1
输出："aabaa"

```java
class Solution {
    public String strWithout3a3b(int A, int B) {
        StringBuilder ans = new StringBuilder();

        while (A > 0 || B > 0) {
            boolean writeA = false;
            int L = ans.length();
            if (L >= 2 && ans.charAt(L-1) == ans.charAt(L-2)) {
                if (ans.charAt(L-1) == 'b')
                    writeA = true;
            } else {
                if (A >= B)
                    writeA = true;
            }

            if (writeA) {
                A--;
                ans.append('a');
            } else {
                B--;
                ans.append('b');
            }
        }

        return ans.toString();
    }
}

```

### [Leetcode1550 存在连续三个奇数的数组](https://leetcode-cn.com/problems/three-consecutive-odds/)

给你一个整数数组 arr，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 true ；否则，返回 false 。

 

示例 1：

输入：arr = [2,6,4,1]
输出：false
解释：不存在连续三个元素都是奇数的情况。
示例 2：

输入：arr = [1,2,34,3,4,5,7,23,12]
输出：true
解释：存在连续三个元素都是奇数的情况，即 [5,7,23] 。

```java
class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        int n = arr.length;
        for (int i = 0; i <= n - 3; ++i) {
            if ((arr[i] & 1) != 0 && (arr[i + 1] & 1) != 0 && (arr[i + 2] & 1) != 0) {
                return true;
            }
        }
        return false;
    }
}

```

### [Leetcode1556千位分隔数](https://leetcode-cn.com/problems/thousand-separator/)

给你一个整数 n，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回。

 

示例 1：

输入：n = 987
输出："987"
示例 2：

输入：n = 1234
输出："1.234"
示例 3：

输入：n = 123456789
输出："123.456.789"

```java
class Solution {
    public String thousandSeparator(int n) {
         StringBuffer sb = new StringBuffer(String.valueOf(n));
        for (int i = sb.length() - 3; i > 0; i -= 3) sb.insert(i, '.');
        return sb.toString();
    }
}
```

### Leetcode 319 灯泡开关

初始时有 n 个灯泡处于关闭状态。

对某个灯泡切换开关意味着：如果灯泡状态为关闭，那该灯泡就会被开启；而灯泡状态为开启，那该灯泡就会被关闭。

第 1 轮，每个灯泡切换一次开关。即，打开所有的灯泡。

第 2 轮，每两个灯泡切换一次开关。 即，每两个灯泡关闭一个。

第 3 轮，每三个灯泡切换一次开关。

第 i 轮，每 i 个灯泡切换一次开关。 而第 n 轮，你只切换最后一个灯泡的开关。

找出 n 轮后有多少个亮着的灯泡。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg)

输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。

```java
class Solution {
    public int bulbSwitch(int n) {
        int cnt = 0;
        // 统计区间 [1, n] 上完全平方数的个数
        for (int i = 1; i * i <= n; ++i) {
            ++cnt;
        }
        return cnt;

    }
}
```

### Leetcode36 有效的数独

请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

注意：

一个有效的数独（部分已被填充）不一定是可解的。
只需要根据以上规则，验证已经填入的数字是否有效即可。


示例 1：


输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]
输出：true

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
        // 记录某行，某位数字是否已经被摆放
        boolean[][] row = new boolean[9][9];
        // 记录某列，某位数字是否已经被摆放
        boolean[][] col = new boolean[9][9];
        // 记录某 3x3 宫格内，某位数字是否已经被摆放
        boolean[][] block = new boolean[9][9];

        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] != '.') {
                    int num = board[i][j] - '1';
                    int blockIndex = i / 3 * 3 + j / 3;
                    if (row[i][num] || col[j][num] || block[blockIndex][num]) {
                        return false;
                    } else {
                        row[i][num] = true;
                        col[j][num] = true;
                        block[blockIndex][num] = true;
                    }
                }
            }
        }
        return true;
    }
}

```





## 状态压缩

### [Leetcode1681 最小不兼容性](https://leetcode-cn.com/problems/minimum-incompatibility/)

给你一个整数数组 nums 和一个整数 k 。你需要将这个数组划分到 k 个相同大小的子集中，使得同一个子集里面没有两个相同的元素。

一个子集的 不兼容性 是该子集里面最大值和最小值的差。

请你返回将数组分成 k 个子集后，各子集 不兼容性 的 和 的 最小值 ，如果无法分成分成 k 个子集，返回 -1 。

子集的定义是数组中一些数字的集合，对数字顺序没有要求。

 

示例 1：

输入：nums = [1,2,1,4], k = 2
输出：4
解释：最优的分配是 [1,2] 和 [1,4] 。
不兼容性和为 (2-1) + (4-1) = 4 。
注意到 [1,1] 和 [2,4] 可以得到更小的和，但是第一个集合有 2 个相同的元素，所以不可行。

```java
class Solution {
    public int minimumIncompatibility(int[] nums, int k) {
        int n = nums.length;
        int m = n / k;
        int[] dp = new int[1 << n];
        int[] value = new int[1 << n];
        Arrays.fill(value, -1);
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        //预处理value数组，value[j]代表 j这个集合的 不兼容性
        for(int i = 0; i < (1 << n); i++) {
            int count = countOne(i);// 计算二进制中1的数量
            if(count == m) {//条件1：子集中有m个1
                //条件2：每个数字只能出现一次
                Map<Integer, Integer> map = new HashMap<>();//来存子集中每个数字出现的次数
                boolean flag = true;
                int max = Integer.MIN_VALUE;
                int min = Integer.MAX_VALUE;
                for(int j = 0; j < n; j++) {
                    if((i >> j & 1) == 1) { //i的第j位=1, 代表选了nums[j]
                        min = Math.min(min, nums[j]);
                        max = Math.max(max, nums[j]);
                        if(map.containsKey(nums[j])) {
                            flag = false;
                            break;
                        }else {
                            map.put(nums[j], 1);
                        }
                    }
                }
                //如果这个子集合法
                if(flag) {
                    value[i] = max - min;//更新子集i的不兼容性
                }
            }
        }
        //进行状态转移 ,dp[i]代表当选择的元素集合为i时最小的不兼容性的和
        for(int i = 0; i < (1 << n); i++) {
            if(countOne(i) % m == 0) {//当前的选择方式组合mask是否有n/k的倍数个1
                //枚举最后一个选择的子集j
                for(int j = i; j != 0; j = (j - 1) & i) {
                    if(value[j] != -1 && dp[i ^ j] != Integer.MAX_VALUE) { //i^j表示从i中去掉j这个集合
                        dp[i] = Math.min(dp[i], dp[i ^ j] + value[j]);
                    }
                }
            }
        }
        return dp[(1 << n) - 1] == Integer.MAX_VALUE ? -1 : dp[(1 << n) - 1];//最后返回dp[1111111],表示每个数字都选了以后
    }
    public int countOne(int x) {
        int res = 0;
        while(x != 0) {
            x &= (x - 1);
            res++;
        }
        return res;
    }
}


```





## 几何

### [Leetcode223 矩形面积](https://leetcode-cn.com/problems/rectangle-area/)

你 二维 平面上两个 由直线构成的 矩形，请你计算并返回两个矩形覆盖的总面积。

每个矩形由其 左下 顶点和 右上 顶点坐标表示：

第一个矩形由其左下顶点 (ax1, ay1) 和右上顶点 (ax2, ay2) 定义。
第二个矩形由其左下顶点 (bx1, by1) 和右上顶点 (bx2, by2) 定义。

示例 1：

![Rectangle Area](https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png)


输入：ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2
输出：45

```java
class Solution {
    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {
        int union;
        //没有重叠部分
        if (ax2 <= bx1 || bx2 <= ax1 || ay1 >= by2 || by1 >= ay2) {
            union = 0;
        } else {
            //重叠部分面积
            int a = Math.min(ay2, by2);
            int b = Math.max(ay1, by1);
            int c = a - b;

            int a1 = Math.min(ax2, bx2);
            int b1 = Math.max(ax1, bx1);
            int c1 = a1 - b1;
            union = c * c1;
        }
        //两矩形面积和
        int sum = (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1);
        return sum - union;
    }
}


```



### [Leetcode1401 圆和矩形是否有重叠](https://leetcode-cn.com/problems/circle-and-rectangle-overlapping/)

给你一个以 (radius, x_center, y_center) 表示的圆和一个与坐标轴平行的矩形 (x1, y1, x2, y2)，其中 (x1, y1) 是矩形左下角的坐标，(x2, y2) 是右上角的坐标。

如果圆和矩形有重叠的部分，请你返回 True ，否则返回 False 。

换句话说，请你检测是否 存在 点 (xi, yi) ，它既在圆上也在矩形上（两者都包括点落在边界上的情况）。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/04/sample_4_1728.png)

输入：radius = 1, x_center = 0, y_center = 0, x1 = 1, y1 = -1, x2 = 3, y2 = 1
输出：true
解释：圆和矩形有公共点 (1,0) 

> 基本思路：矩形区域内点离圆心最近的点距离小于等于圆的半径
>
> 矩形区域特点是x,y取值相互独立
> 又距离公式对x,y分别单调
> 分别取最小距离即可
>
> 又由 x1 < x2 , y1 < y2 可以简化最小距离获取过程
> 对于 x
> x_center < x1 < x2 =>min(dx) = x1 - x_center
> x1 <= x_center <= x2 =>min(dx) = 0
> x1 < x2 < x_center =>min(dx) = x_center - x2
> 对于 y 同理
>

```java
class Solution {
    public boolean checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) {
        int dx = x1 > x_center ? x1 - x_center : x2 < x_center ? x_center - x2 : 0;
        int dy = y1 > y_center ? y1 - y_center : y2 < y_center ? y_center - y2 : 0;
        return dx * dx + dy * dy <= radius * radius;
    }
}

```

### [Leetcode836 矩形重叠](https://leetcode-cn.com/problems/rectangle-overlap/)

矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。矩形的上下边平行于 x 轴，左右边平行于 y 轴。

如果相交的面积为 正 ，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形 rec1 和 rec2 。如果它们重叠，返回 true；否则，返回 false 。

 

示例 1：

输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
输出：true
示例 2：

输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
输出：false
示例 3：

输入：rec1 = [0,0,1,1], rec2 = [2,2,3,3]
输出：false

```java
class Solution {
    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {
                return !(rec1[2] <= rec2[0] || rec2[2] <= rec1[0] || rec1[3] <= rec2[1] || rec2[3] <= rec1[1]);
    }
}
```



### [Leetcode469 凸多边形](https://leetcode-cn.com/problems/convex-polygon/)

一个按顺序连接的多边形的顶点，判断该多边形是否为凸多边形。（凸多边形的定义）

注：

顶点个数至少为 3 个且不超过 10,000。
坐标范围为 -10,000 到 10,000。
你可以假定给定的点形成的多边形均为简单多边形（简单多边形的定义）。换句话说，保证每个顶点处恰好是两条边的汇合点，并且这些边 互不相交 。


示例 1：

[[0,0],[0,1],[1,1],[1,0]]

输出： True

解释：
示例 2：

[[0,0],[0,10],[10,10],[10,0],[5,5]]

输出： False

解释：

```java
public class Solution {
    public boolean isConvex(List<List<Integer>> points) {
        int n = points.size();
        long cur, pre = 0;
        for (int i = 0; i < n; i++) {
            cur = crossProduct(points.get((i + 1) % n).get(0) - points.get(i).get(0),
                    points.get((i + 1) % n).get(1) - points.get(i).get(1),
                    points.get((i + 2) % n).get(0) - points.get(i).get(0),
                    points.get((i + 2) % n).get(1) - points.get(i).get(1));
            if (cur != 0) {
                if (cur * pre < 0) {
                    return false;
                }
                pre = cur;
            }
        }
        return true;
    }

    private long crossProduct(long x1, long y1, long x2, long y2) {
        return x1 * y2 - x2 * y1;
    }
}


```



### 如何判断一个点是否在三角形内？

给定三角形3个点的坐标，在给定一个点(x,y)，判断该点是否在三角形中。

ps:坐标值均为double型

**题目分析**

![image-20210716093307293](E:/笔记/面试高频/imgs/475.png)

```java
#include <iostream>
#include <math.h>
using namespace std;

struct Point {
    double x;
    double y;
};

double getDist(Point p1,Point p2) {
    //两点之间计算距离公式
    return sqrt(pow(p1.x-p2.x,2) + pow(p1.y-p2.y,2));
}
double getArea(Point p1,Point p2,Point p3) {
    double a = getDist(p1, p2);
    double b = getDist(p2, p3);
    double c = getDist(p1, p3);
    double p = (a + b + c) / 2;
    return sqrt(p * (p - a) * (p - b) * (p - c));
}
bool isInTriangle(Point p1,Point p2,Point p3,Point o) {
    double s1 = getArea(p1,p2,o);
    double s2 = getArea(p2,p3,o);
    double s3 = getArea(p3,p1,o);
    double s = getArea(p1,p2,p3);
    return s1+s2+s3 == s; //此处没有用fabs(a-b)<eps比较，是方便大家理解思路
}
int main() {
    Point p1,p2,p3,o;
    cin >> p1.x >> p1.y;
    cin >> p2.x >> p2.y;
    cin >> p3.x >> p3.y;
    cin >> o.x >> o.y;
    bool flag = isInTriangle(p1,p2,p3,o);
    if(flag) puts("Yes");
    else puts("No");
}


```

![image-20210716093541382](E:/笔记/面试高频/imgs/476.png)

```c++
#include <iostream>
#include <math.h>
using namespace std;
struct Point {
    double x;
    double y;
};
double product(Point p1,Point p2,Point p3) {
    //首先根据坐标计算p1p2和p1p3的向量，然后再计算叉乘
    //p1p2 向量表示为 (p2.x-p1.x,p2.y-p1.y)
    //p1p3 向量表示为 (p3.x-p1.x,p3.y-p1.y)
    return (p2.x-p1.x)*(p3.y-p1.y) - (p2.y-p1.y)*(p3.x-p1.x);
}
bool isInTriangle(Point p1,Point p2,Point p3,Point o) {
    //保证p1，p2，p3是逆时针顺序
    if(product(p1, p2, p3)<0) return isInTriangle(p1,p3,p2,o);
    if(product(p1, p2, o)>0 && product(p2, p3, o)>0 && product(p3, p1, o)>0)
        return true;
    return false;
}
int main() {
    Point p1,p2,p3,o;
    cin >> p1.x >> p1.y;
    cin >> p2.x >> p2.y;
    cin >> p3.x >> p3.y;
    cin >> o.x >> o.y;
    bool flag = isInTriangle(p1,p2,p3,o);
    if(flag) puts("Yes");
    else puts("No");
}

```



### [1.Leetcode149 直线上最多的点数](https://leetcode-cn.com/problems/max-points-on-a-line/)

给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/25/plane1.jpg)


输入：points = [[1,1],[2,2],[3,3]]
输出：3

```java
class Solution {
    public int maxPoints(int[][] points) {
        int n = points.length;
         if(n<=2){
            return n;
        }
        // 用list下的map
        List<Map<Double,Integer>> dp = new ArrayList<>();
        // 初始化
        for(int i=0;i<n;i++){
            dp.add(new HashMap<>());
        }
        // 转移方程
        int maxCount = 0;
        int l = 0;
        int r = 0;
        // 开始
        for(int i=n-2;i>=0;i--){
            for(int j=n-1;j>i;j--){
                // 计算点的斜率
                int dx = points[i][0]-points[j][0];
                int dy = points[i][1]-points[j][1];
                double k = dx==0?Double.POSITIVE_INFINITY:dy==0?0:(double)dy/dx;
                // 计算数量
                int temp_count = dp.get(j).getOrDefault(k,1)+1;
                dp.get(i).put(k,temp_count);
                if(maxCount>temp_count){
                    continue;
                }
                maxCount = temp_count;
                l = i;
                r = j;
            }
        }
        return maxCount;

    }

    // 求解最大公约数
    public int gcd(int a,int b){
        return b!=0?gcd(b,a%b):a;
    }
}
```

### [2.Leetcode973 最接近原点的k个点](https://leetcode-cn.com/problems/k-closest-points-to-origin/)

我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。

（这里，平面上两点之间的距离是欧几里德距离。）

你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。

 

示例 1：

输入：points = [[1,3],[-2,2]], K = 1
输出：[[-2,2]]
解释： 
(1, 3) 和原点之间的距离为 sqrt(10)，
(-2, 2) 和原点之间的距离为 sqrt(8)，
由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。
我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。

> 解题思路：优先级队列

```java
class Solution {
    public int[][] kClosest(int[][] points, int k) {
        // 优先级队列 其中存储数组 点的距离和下标索引i 建立个大顶堆
        PriorityQueue<int[]> queue = new PriorityQueue<>((arr1,arr2)->(arr2[0]-arr1[0]));
        //先往里面放入k个
        for(int i=0;i<k;i++){
            queue.offer(new int[]{points[i][0]*points[i][0]+points[i][1]*points[i][1],i});
        }
        // 继续遍历
        int n = points.length;
        for(int i=k;i<n;i++){
            int dist = points[i][0]*points[i][0] + points[i][1]*points[i][1];
            if(dist<queue.peek()[0]){
                queue.poll();
                queue.offer(new int[]{dist,i});
            }
        }
        // 结果存储
        int[][] res = new int[k][2];
        for(int i=0;i<k;i++){
            res[i] = points[queue.poll()[1]];
        }
        return res;

    }
}
```

### [3.Leetcode478 在圆内随机生成点](https://leetcode-cn.com/problems/generate-random-point-in-a-circle/)

给定圆的半径和圆心的 x、y 坐标，写一个在圆中产生均匀随机点的函数 randPoint 。

说明:

输入值和输出值都将是浮点数。
圆的半径和圆心的 x、y 坐标将作为参数传递给类的构造函数。
圆周上的点也认为是在圆中。
randPoint 返回一个包含随机点的x坐标和y坐标的大小为2的数组。
示例 1：

输入: 
["Solution","randPoint","randPoint","randPoint"]
[[1,0,0],[],[],[]]
输出: [null,[-0.72939,-0.65505],[-0.78502,-0.28626],[-0.83119,-0.19803]]

> 解决思路：拒绝采样
>
> 为了在一个半径为 RR 的圆 CC 中均匀随机生成点，我们可以使用拒绝采样的方法。
>
> 我们使用一个边长为 2R2R 的正方形覆盖住圆 CC，并在正方形内随机生成点，若该点落在圆内，我们就返回这个点，否则我们拒绝这个点，重新生成知道新的随机点落在圆内。
>
> ![pic](https://pic.leetcode-cn.com/Figures/883/squareCircleOverlay.png)

```java
class Solution {
    double rad,xc,yc;
    public Solution(double radius, double x_center, double y_center) {
        rad = radius;
        xc  = x_center;
        yc  = y_center;
    }
    
    public double[] randPoint() {
        double x0 = xc-rad;
        double y0 = yc-rad;
        while(true){
            double xg = x0 + Math.random()*rad*2;
            double yg = y0 + Math.random()*rad*2;
            if(Math.sqrt(Math.pow((xg-xc),2) + Math.pow((yg-yc),2))<=rad){
                return new double[]{xg,yg};
            }
        }
    }
}

/**
 * Your Solution object will be instantiated and called as such:
 * Solution obj = new Solution(radius, x_center, y_center);
 * double[] param_1 = obj.randPoint();
 */
```

### [4.面试题16.14 最佳直线](https://leetcode-cn.com/problems/best-line-lcci/)

给定一个二维平面及平面上的 N 个点列表Points，其中第i个点的坐标为Points[i]=[Xi,Yi]。请找出一条直线，其通过的点的数目最多。

设穿过最多点的直线所穿过的全部点编号从小到大排序的列表为S，你仅需返回[S[0],S[1]]作为答案，若有多条直线穿过了相同数量的点，则选择S[0]值较小的直线返回，S[0]相同则选择S[1]值较小的直线返回。

示例：

输入： [[0,0],[1,1],[1,0],[2,0]]
输出： [0,2]
解释： 所求直线穿过的3个点的编号为[0,2,3]

```java
class Solution {
    // 动态规划
    // dp[i][k]表示以i为开始结点斜率为k的最大数量
    public int[] bestLine(int[][] points) {
        int n = points.length;
        // 用list下的map
        List<Map<Double,Integer>> dp = new ArrayList<>();
        // 初始化
        for(int i=0;i<n;i++){
            dp.add(new HashMap<>());
        }
        // 转移方程
        int maxCount = 0;
        int l = 0;
        int r = 0;
        // 开始
        for(int i=n-2;i>=0;i--){
            for(int j=n-1;j>i;j--){
                // 计算点的斜率
                int dx = points[i][0]-points[j][0];
                int dy = points[i][1]-points[j][1];
                double k = dx==0?Double.POSITIVE_INFINITY:dy==0?0:(double)dy/dx;
                // 计算数量
                int temp_count = dp.get(j).getOrDefault(k,1)+1;
                dp.get(i).put(k,temp_count);
                if(maxCount>temp_count){
                    continue;
                }
                maxCount = temp_count;
                l = i;
                r = j;
            }
        }
        return new int[]{l,r};
    }
}
```

### [Leetcode1035 不相交的线](https://leetcode-cn.com/problems/uncrossed-lines/)

在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。

现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足：

 nums1[i] == nums2[j]
且绘制的直线不与任何其他连线（非水平线）相交。
请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

 

示例 1：


输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
示例 2：

输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]
输出：3

```java
class Solution {
    public int maxUncrossedLines(int[] nums1, int[] nums2) {
        int m = nums1.length, n = nums2.length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            int num1 = nums1[i - 1];
            for (int j = 1; j <= n; j++) {
                int num2 = nums2[j - 1];
                if (num1 == num2) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
}

```



## 数值计算（回文对称旋转 加减乘除比较 二进制求和）

### Leetcode866 回文素数

求出大于或等于 N 的最小回文素数。

回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是素数。

例如，2，3，5，7，11 以及 13 是素数。

回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是回文数。

例如，12321 是回文数。

 

示例 1：

输入：6
输出：7
示例 2：

输入：8
输出：11
示例 3：

输入：13
输出：101

```java
class Solution {
    public int primePalindrome(int N) {
        while (true) {
            if (N == reverse(N) && isPrime(N))
                return N;
            N++;
            if (10_000_000 < N && N < 100_000_000)
                N = 100_000_000;
        }
    }

    public boolean isPrime(int N) {
        if (N < 2) return false;
        int R = (int) Math.sqrt(N);
        for (int d = 2; d <= R; ++d)
            if (N % d == 0) return false;
        return true;
    }

    public int reverse(int N) {
        int ans = 0;
        while (N > 0) {
            ans = 10 * ans + (N % 10);
            N /= 10;
        }
        return ans;
    }
}



```



### [Leecode246 中心对称数](https://leetcode-cn.com/problems/strobogrammatic-number/)

https://blog.csdn.net/qq_21201267/article/details/107100817

中心对称数是指一个数字在旋转了 180 度之后看起来依旧相同的数字（或者上下颠倒地看）。
 请写一个函数来判断该数字是否是中心对称数，其输入将会以一个字符串的形式来表达数字。
 示例 1:
 输入:  "69"
 输出: true
 示例 2:
 输入:  "88"
 输出: true
 示例 3:
 输入:  "962"
 输出: false

```java
package com.test001;
 
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
 
public class Test001 {
 
	public static List<String> centerNumber(int n) {
		Map<Integer, List<String>> map = new HashMap<Integer, List<String>>();
		List<String> numberList1 = Arrays.asList("0", "1", "8");
		List<String> numberList2 = Arrays.asList("11", "69", "88", "96");
		List<String> add1 = Arrays.asList("0", "1", "8");
		List<String> add2 = Arrays.asList("00","11", "69", "88", "96");
		List<String> numberList = new ArrayList<>();
		if (n <= 0) {
			return numberList;
		} else if (n == 1) {
			return numberList1;
		} else if (n == 2) {
			return numberList2;
		}
 
		map.put(1, numberList1);
		map.put(2, numberList2);
 
		for (int i = 3; i <= n; i++) {
			numberList = new ArrayList<>();
			if (i % 2 == 1) {
				List<String> bastList = map.get(i - 1);
				for (int j = 0; j < bastList.size(); j++) {
					String num = bastList.get(j);
					int h = num.length() / 2;
					for (int k = 0; k < add1.size(); k++) {
						numberList.add(num.substring(0, h) + add1.get(k) + num.substring(h));
					}
				}
				map.put(i, numberList);
 
			} else {
				List<String> bastList = map.get(i - 2);
				for (int j = 0; j < bastList.size(); j++) {
					String num = bastList.get(j);
					int h = num.length() / 2;
					for (int k = 0; k < add2.size(); k++) {
						numberList.add(num.substring(0, h) + add2.get(k) + num.substring(h));
					}
				}
				map.put(i, numberList);
			}
		}
 
		return map.get(n);
	}
 
	public static void main(String[] args) {
		//System.out.println(centerNumber(3));
		System.out.println(centerNumber(4));
		System.out.println(centerNumber(5));
	}
 
}
```



### [NC112进制转换](https://www.nowcoder.com/practice/2cc32b88fff94d7e8fd458b8c7b25ec1?tpId=188&&tqId=38624&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。

当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 'A' 表示此位为 10 ， 'B' 表示此位为 11 。

若 M 为负数，应在结果中保留负号。

**示例1**

输入：

```
7,2
```

复制

返回值：

```
"111"
```

复制

**备注：**

```
M是32位整数，2<=N<=16.
```

```java
import java.util.*;


public class Solution {
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    public String solve (int M, int N) {
        // write code here
        String t = "0123456789ABCDEF";
        if(M==0){
            return "0";
        }
        //结果
        StringBuilder res = new StringBuilder();
        //记录一下是否为负数
        boolean flag = false;
        if(M<0){
            flag = true;
            M = -M;
        }
        while(M!=0){
            res.append(t.charAt(M%N));
            M/=N;
        }
        if(flag){
            res.append('-');
        }
        return res.reverse().toString();
    }
}
```

### 

### [NC151 最大公约数](https://www.nowcoder.com/practice/cf4091ca75ca47958182dae85369c82c?tpId=188&&tqId=38574&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

如果有一个自然数 ![img](https://www.nowcoder.com/equation?tex=a%5C) 能被自然数 ![img](https://www.nowcoder.com/equation?tex=b%5C) 整除，则称 ![img](https://www.nowcoder.com/equation?tex=a%5C) 为 ![img](https://www.nowcoder.com/equation?tex=b%5C) 的倍数， ![img](https://www.nowcoder.com/equation?tex=b%5C) 为 ![img](https://www.nowcoder.com/equation?tex=a%5C) 的约数。几个自然数公有的约数，叫做这几个自然数的公约数。公约数中最大的一个公约数，称为这几个自然数的最大公约数。

输入 ![img](https://www.nowcoder.com/equation?tex=a%5C) 和 ![img](https://www.nowcoder.com/equation?tex=b%5C) , 请返回 ![img](https://www.nowcoder.com/equation?tex=a%5C) 和 ![img](https://www.nowcoder.com/equation?tex=b%5C) 的最大公约数。

数据范围：
1 \le a,b \le 10^91≤*a*,*b*≤109

**示例1**

输入：

```
3,6
```

复制

返回值：

```
3
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 求出a、b的最大公约数。
     * @param a int 
     * @param b int 
     * @return int
     */
    public int gcd (int a, int b) {
        // write code here
        if(a%b==0){return b;}
        else{return gcd(b,a%b);}
    }
    
}
```

### 

### [NC152 数的划分](https://www.nowcoder.com/practice/24c2045f2cce40a5bf410a369a001da8?tpId=117&&tqId=37862&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

将整数 n*n* 分成 k*k* 份，且每份不能为空，任意两个方案不能相同(不考虑顺序)。

例如： n=7, k=3*n*=7,*k*=3 ，下面三种分法被认为是相同的。

1，1，5;1，1，5;

1，5，1;1，5，1;

5，1，1;5，1，1;

问有多少种不同的分法, 答案对 10^9+7109+7 取模。

输入： n*n*，k*k*

6 \lt n \le 5000，2 \le k \le 10006<*n*≤5000，2≤*k*≤1000

输出：一个整数，即不同的分法。

**示例1**

输入：

```
7,3
```

复制

返回值：

```
4
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int 被划分的数
     * @param k int 化成k份
     * @return int
     设f(i,j)为i分成j份的方案数
    初值：
    当j=1以及i=j时f(i,j)=1
    递推：
    两种情况

    1.j份中至少一个是1，方案数为f(i-1,j-1)
    2.j份中一份1都没有，考虑将i-j分为j份，再往j份中的每一份+1，方案数为f(i-j,j）

    故有递推式：
    f ( i , j ) = f ( i − 1 , j − 1 ) + f ( i − j , j ) f(i,j)=f(i-1,j-1)+f(i-j,j)
    f(i,j)=f(i−1,j−1)+f(i−j,j)
     */
     public int divideNumber (int n, int k) {
        // 初始化dp数组，赋初值
        int[][] dp=new int[n+1][k+1];
        dp[0][0]=1;
        int mod=1000000007;
 
        for(int i=1;i<=n;i++){
            for(int j=1;j<=k;j++){
                //由于每份不能为空，所以划分数肯定大于总份数
                if(i>=j){
                    //分为至少存在一份是1，和所有份数大于1两种情况
                    dp[i][j]=(dp[i-1][j-1]+dp[i-j][j])%mod;
                }               
            }   
        }
        return dp[n][k];
    }
 
}
```

### 

### [NC106 三个数的最大乘积](https://www.nowcoder.com/practice/8ae05c2913fe438b8b14f3968f64fc0b?tpId=117&&tqId=37830&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个长度为 ![img](https://www.nowcoder.com/equation?tex=n%5C) 的无序数组 ![img](https://www.nowcoder.com/equation?tex=A%5C) ，包含正数、负数和 0 ，请从中找出 3 个数，使得乘积最大，返回这个乘积。

要求时间复杂度： ![img](https://www.nowcoder.com/equation?tex=O(n)%5C) ，空间复杂度： ![img](https://www.nowcoder.com/equation?tex=O(1)%5C) 。

数据范围：

3 \le n \le 2 * 10^53≤*n*≤2∗105

-10^6 \le A[i] \le 10^6−106≤*A*[*i*]≤106

**示例1**

输入：

```
[3,4,1,2]
```

复制

返回值：

```
24
```

> 解题思路：遍历数组，找到最大的三个数和最小的两个数，三个数的最大乘积来源可能有两种，一种是三个最大的数相乘，另一种是两个最小的数和一个最大的数相乘

```java
import java.util.*;
public class Solution {
    /**
     * 最大乘积
     * @param A int整型一维数组 
     * @return long长整型
     */
    public long solve (int[] A) {
        // write code here
        int max1=Integer.MIN_VALUE,max2=Integer.MIN_VALUE,max3=Integer.MIN_VALUE;
        int min1=Integer.MAX_VALUE,min2=Integer.MAX_VALUE;
        for(int num:A){
            if(num>max1){
                max3=max2;
                max2=max1;
                max1=num;
            } else if(num>max2){
                max3=max2;
                max2=num;
            } else if(num>max3) max3=num;
            if(num<min1){
                min2=min1;
                min1=num;
            } else if(num<min2) min2=num;
        }
        return Math.max((long)max1*max2*max3,(long)max1*min1*min2);
    }
}
```

### 

### [NC143 矩阵乘法](https://www.nowcoder.com/practice/bf358c3ac73e491585943bac94e309b0?tpId=117&&tqId=37854&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定两个 n*n*n*∗*n* 的矩阵 A*A* 和 B*B* ，求 A*B*A*∗*B* 。

数据范围：

1 \le n \le 5001≤*n*≤500

-100 \le n \le 100−100≤*n*≤100

**示例1**

输入：

```
[[1,2],[3,2]],[[3,4],[2,1]]
```

复制

返回值：

```
[[7,6],[13,14]]
```

```java
import java.util.*;
public class Solution {
    public int[][] solve (int[][] a, int[][] b) {
        // write code here
            int m = a.length;//A的行数
            int p = a[0].length;//A的列数=B的行数
            int n = b[0].length;//B的行数
            int[][] ans = new int[m][n];
            for(int i = 0 ; i < m ; i++)
            {
                for(int j = 0 ; j < n ; j++)
                {
                        int t = 0;
                        for(int k = 0 ; k < p ; k++)
                        {
                                t+=a[i][k]*b[k][j];
                        }
                        ans[i][j]=t;
                }
            }
            return ans;
    }
}
```

### [NC129 阶乘末尾0的数量](https://www.nowcoder.com/practice/aa03dff18376454c9d2e359163bf44b8?tpId=117&&tqId=37803&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个非负整数 N*N*，返回 N!*N*! 结果的末尾为 00 的数量。

N!*N*! 是指自然数 N*N* 的阶乘,即:N!=1*2*3…(N-2)*(N-1)*N*N*!=1∗2∗3…(*N*−2)∗(*N*−1)∗*N*。

特殊的, ![img](https://www.nowcoder.com/equation?tex=0%5C) 的阶乘是 ![img](https://www.nowcoder.com/equation?tex=1%5C) 。

**示例1**

输入：

```
3
```

复制

返回值：

```
0
```

复制

说明：

```
3!=6   
```

**示例2**

输入：

```
5
```

复制

返回值：

```
1
```

复制

说明：

```
5!=120  
```

```java
import java.util.*;


public class Solution {
    /**
     * the number of 0
     * @param n long长整型 the number
     * @return long长整型
     */
    public long thenumberof0 (long n) {
        // write code here
        long  res = 0;
        long d = 5;
        while(n>=d){
            res += n/d;
            d = d*5;
        }
        return res;
    }
}
```

### 

### [Leetcode367 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

 

示例 1：

输入：num = 16
输出：true
示例 2：

输入：num = 14
输出：false

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        // 实现sqrt
        long  res = num;
        while(res*res>num){
            res = (res+num/res)/2;
        }
        return (int)res*(int)res==num;
    }
}
```

### Leetcode279 完全平方数

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9

```java
class Solution {
    public int numSquares(int n) {
        // 动态规划 初始化 转移方程
        int[] dp = new int[n+1];
        for(int  i=1;i<=n;i++){
            // 最坏的情况下
            dp[i] = i;
            // 转移方程
            for(int j=1;i-j*j>=0;j++){
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
```



### [Leetcode166 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 任意一个 。

对于所有给定的输入，保证 答案字符串的长度小于 104 。

 

示例 1：

输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：

输入：numerator = 2, denominator = 1
输出："2"

```java
class Solution {
   public String fractionToDecimal(int numerator, int denominator) {
    if (numerator == 0) {
        return "0";
    }
    StringBuilder fraction = new StringBuilder();
    // If either one is negative (not both)
    if (numerator < 0 ^ denominator < 0) {
        fraction.append("-");
    }
    // Convert to Long or else abs(-2147483648) overflows
    long dividend = Math.abs(Long.valueOf(numerator));
    long divisor = Math.abs(Long.valueOf(denominator));
    fraction.append(String.valueOf(dividend / divisor));
    long remainder = dividend % divisor;
    if (remainder == 0) {
        return fraction.toString();
    }
    fraction.append(".");
    Map<Long, Integer> map = new HashMap<>();
    while (remainder != 0) {
        if (map.containsKey(remainder)) {
            fraction.insert(map.get(remainder), "(");
            fraction.append(")");
            break;
        }
        map.put(remainder, fraction.length());
        remainder *= 10;
        fraction.append(String.valueOf(remainder / divisor));
        remainder %= divisor;
    }
    return fraction.toString();
}

}
```



### [Leetcode456 132的模式](https://leetcode-cn.com/problems/132-pattern/)

给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数 nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k] < nums[j] 。

如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false 。

 

示例 1：

输入：nums = [1,2,3,4]
输出：false
解释：序列中不存在 132 模式的子序列。
示例 2：

输入：nums = [3,1,4,2]
输出：true
解释：序列中有 1 个 132 模式的子序列： [1, 4, 2] 。

```java
class Solution {
    public boolean find132pattern(int[] nums) {
        //132模式
        int n = nums.length;
        //132中的2
        int last = Integer.MIN_VALUE;
        //用来存储132模式中的3
        Stack<Integer> sta = new Stack<>();
        //提前递归结束
        if(nums.length<3){
            return false;
        }
        //开始遍历
        for(int i=n-1;i>=0;i--){
            //若出现132中的1则返回正确值
            if(nums[i]<last){
                return true;
            }
            //若当前值大于或等于2则更新(2为栈中小于当前值的最大元素)
            while(!sta.isEmpty()&&sta.peek()<nums[i]){
                last = sta.pop();
            }
            sta.push(nums[i]);
        }
        return false;
    }
}
```



### Leetcode008将字符串转化为整数

实现函数 atoi 。函数的功能为将字符串转化为整数

提示：仔细思考所有可能的输入情况。这个问题没有给出输入的限制，你需要自己考虑所有可能的情况。

**示例1**

输入：

```
"123"
```

复制

返回值：

```
123
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param str string字符串 
     * @return int整型
     */
    public int atoi (String str) {
        // write code here
        //1.去除空格
        str = str.trim();
        //2.转为数组处理方便
        char[] arr = str.toCharArray();
        // 3.变量
        int res = 0;
        int flag = 0;
        int i = 0;
        // 有正负号
        if(i==arr.length){
            return 0;
        }
        if(arr[i]=='-'){
            flag = -1;
            i++;
        }else if(arr[i]=='+'){
            i++;
        }
        while(i<arr.length&&Character.isDigit(arr[i])){
            int cur = arr[i]-'0';
            if((res)>(Integer.MAX_VALUE-cur)/10){
                return flag==0?Integer.MAX_VALUE:Integer.MIN_VALUE;
            }
            res = res*10 + cur;
            i++;
        }
        return flag==0?res:(-1)*res;
        
    }
}
```

### [NC57 反转数字](https://www.nowcoder.com/practice/1a3de8b83d12437aa05694b90e02f47a?tpId=117&&tqId=37755&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1][−231,231−1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。

**示例1**

输入：

```
12
```

复制

返回值：

```
21
```

复制

**示例2**

输入：

```
-123
```

复制

返回值：

```
-321
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    public int reverse (int x) {
        // write code here
        int res = 0;
        while(x!=0){
            int cur = x%10;
            if((res*10)/10!=res){
                return 0;
            }
            res = res*10+cur;
            x = x/10;
        }
        return res;
    }
}
```

### [NC56 回文数字](https://www.nowcoder.com/practice/35b8166c135448c5a5ba2cff8d430c32?tpId=117&&tqId=37753&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

在不使用额外的内存空间的条件下判断一个整数是否是回文数字

输入整数位于区间 [-2^{31}, 2^{31}-1][−231,231−1]之内

提示：

负整数可以是回文吗？（比如-1）

如果你在考虑将数字转化为字符串的话，请注意一下不能使用额外空间的限制

你可以将整数翻转。但是，如果你做过题目“[反转数字”](https://www.nowcoder.com/practice/1a3de8b83d12437aa05694b90e02f47a?tpId=117&&tqId=34978&rp=1&ru=/ta/job-code-high&qru=/ta/job-code-high/question-ranking)，你会知道将整数翻转可能会出现溢出的情况，你怎么处理这个问题？

**示例1**

输入：

```
121
```

复制

返回值：

```
true
```





```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return bool布尔型
     */
    public boolean isPalindrome (int x) {
        // write code here
        if(x<0){
            return false;
        }
        long res = 0;
        int num = x;
        while(x!=0){
            res = res*10 + x%10;
            x = x/10;
        }
        return  res==num;
    }
}
```



```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return bool布尔型
     */
    public boolean isPalindrome (int x) {
        // write code here
        String str = x+"";
        StringBuffer sa =  new StringBuffer(str);
        StringBuffer as =  sa.reverse();
        String str_reverse = as.toString();
        if(str.equals(str_reverse)){
            return true;
        }else{
            return false;
        }
    }
}
```



```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return bool布尔型
     */
    public boolean isPalindrome (int x) {
        // write code here
         // 如果是负数，或者10的整数倍，返回false
        if (x < 0 || x != 0 && x % 10 == 0)
            return false;
        int reverse = 0;
        while (x > reverse) {
            reverse = reverse * 10 + x % 10;
            x = x / 10;
        }
        return (reverse == x || reverse / 10 == x);
        
    }
}
```

### [NC141 判断回文](https://www.nowcoder.com/practice/e297fdd8e9f543059b0b5f05f3a7f3b2?tpId=188&&tqId=38638&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个字符串，请编写一个函数判断该字符串是否回文。如果回文请返回true，否则返回false。

**示例1**

输入：

```
"absba"
```

复制

返回值：

```
true
```

复制

**示例2**

输入：

```
"ranko"
```

复制

返回值：

```
false
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param str string字符串 待判断的字符串
     * @return bool布尔型
     */
    public boolean judge (String str) {
        // write code here
        char[] arr = str.toCharArray();
        int i = 0;
        int j = arr.length-1;
        while(i<j){
            if(arr[i]!=arr[j]){
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
```

### 

### 反转数字

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1][−231,231−1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。

**示例1**

输入：

```
12
```



返回值：

```
21
```



示例2

输入：

```
-123
```

复制

返回值：

```
-321
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    public int reverse (int x) {
        // write code here
        int res = 0;
        while(x!=0){
            int cur = x%10;
            if((res*10)/10!=res){
                return 0;
            }
            res = res*10+cur;
            x = x/10;
        }
        return res;
    }
}
```

### 字符串相加相减(大数相加或相减)

#### 1.1 Leetcode415字符串相加

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和。

```java
class Solution {
    public String addStrings(String num1, String num2) {
        char[] arr1 = num1.toCharArray();
        char[] arr2 = num2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        int mod  = 0;
        int i = len1-1;
        int j = len2-1;
        StringBuilder res = new StringBuilder();
        // 遍历
        while(i>=0||j>=0){
            int s1 = i>=0?arr1[i]-'0':0;
            int s2 = j>=0?arr2[j]-'0':0;
            int temp = s1+s2+mod;
            mod = temp/10;
            res.append(temp%10);
            i--;
            j--;
        }
        if(mod!=0){
            res.append(mod);
        }
        res = res.reverse();
        return res.toString();
    }
}
```

#### 1.2 字符串相减

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的差。

注意：

num1 和num2 都只会包含数字 0-9
num1 和num2 都不包含任何前导零
你不能使用任何內建 BigInteger 库

> 题目分析：

两个正数相减的结果可能为正，也可能为负。

因此，首先比较两个数的大小。

如代码所示，当小减大时，需将两个参数调换一下位置执行减法，在结果前填上负号即可

```java
string subStrings(string num1, string num2) {
    string res;
    if (isLess(num1, num2)) {
        res = sub(num2, num1);
        res.insert(0, "-");
    }
    else res = sub(num1, num2);
    return res;
}
```

**如何比较两个大数的大小呢？**

由于是大数，肯定不能直接转成int比较。

我们可以比较两个字符串的长度。

长度更长的字符串，数一定更大；当长度一样的就去比较字典序。

```java
bool isLess(string a, string b) {
    if (a.size() == b.size()) return a < b;
    return a.size() < b.size();
}
```

大体框架讲解完了，接下来实现关键的sub函数。

我强烈推荐下边这种实现算法，简洁优雅。

```java
string sub(string a, string b) {
    string res = "";
    int borrow = 0;
    int i = a.size() - 1, j = b.size() - 1;
    while (i >= 0 || j >= 0) {
        int x = i >= 0 ? (a[i] - '0') : 0; //字符转整数
        int y = j >= 0 ? (b[j] - '0') : 0; //字符转整数
        int z = (x - borrow - y + 10) % 10;
        res += ('0' + z); //整数转成字符
        borrow = x - borrow - y < 0 ? 1 : 0;
        i--, j--;
    }
    reverse(res.begin(), res.end());
    //删除前导0，注意边界是res.size()-1！！防止当res为"0000"时，删为""的清空
    int pos;
    for (pos = 0; pos < res.size() - 1; pos++) {
        if (res[pos] != '0') break;
    }
    return res.substr(pos);
}
```

c++的代码

```java
#include <iostream>
#include <algorithm>
using namespace std;

string sub(string a, string b) {
    string res = "";
    int borrow = 0;
    int i = a.size() - 1, j = b.size() - 1;
    while (i >= 0 || j >= 0) {
        int x = i >= 0 ? a[i] - '0' : 0;
        int y = j >= 0 ? b[j] - '0' : 0;
        int z = (x - borrow - y + 10) % 10;
        res += '0' + z;
        borrow = x - borrow - y < 0 ? 1 : 0;
        i--, j--;
    }
    reverse(res.begin(), res.end());
    //删除前导0。循环条件是res.size()-1是为防止"0000"的情况
    int pos;
    for (pos = 0; pos < res.size() - 1; pos++) {
        if (res[pos] != '0') break;
    }
    return res.substr(pos);
}

bool isLess(string a, string b) {
    if (a.size() == b.size()) return a < b;
    return a.size() < b.size();
}

string subStrings(string num1, string num2) {
    string res;
    if (isLess(num1, num2)) {
        res = sub(num2, num1);
        res.insert(0, "-");
    }
    else res = sub(num1, num2);
    return res;
}


int main() {
    string a, b, c;
    cin >> a >> b;
    cout << subStrings(a, b) << endl;
    return 0;
}


```

### [36进制加法](https://leetcode-cn.com/circle/discuss/I8NZUx/)

36进制由0-9，a-z，共36个字符表示。

要求按照加法规则计算出任意两个36进制正整数的和，如1b + 2x = 48 （解释：47+105=152）

要求：不允许使用先将36进制数字整体转为10进制，相加后再转回为36进制的做法

**题目分析：**

此题难度倒不是很大，实际上是415. 字符串相加的扩展。

LC415是十进制的大数相加，而本题是36进制的大数相加。

顺便提一嘴，我强烈推荐415题使用以下代码的写法，优雅简洁，不容易出Bug。

```java
string addStrings(string num1, string num2)
{
    int carry = 0;
    int i = num1.size() - 1, j = num2.size() - 1;
    string res;
    while (i >= 0 || j >= 0 || carry)
    {
        int x = i >= 0 ? num1[i] - '0' : 0;
        int y = j >= 0 ? num2[j] - '0' : 0;
        int temp = x + y + carry;
        res += '0' + temp % 10;
        carry = temp / 10;
        i--, j--;
    }
    reverse(res.begin(), res.end());
    return res;
}
若
```

掌握了415，那本题只需要注意将10变成36，以及36进制字符与数值的转换。这里，我使用了getChar(int n)和getInt(char ch)两个辅助函数来完成36进制字符与数值的转换。

**参考代码**

```java
#include <iostream>
#include <algorithm>
using namespace std;
class Solution {
public:
    char getChar(int n) {
        if(n <= 9) return n + '0';
        else return n - 10 + 'a'; 
    }
    int getInt(char ch) {
        if('0' <= ch && ch <='9') return ch - '0';
        else return ch - 'a' + 10;
    }
    string add36Strings(string num1, string num2) {
        int carry = 0;
        int i = num1.size()-1, j = num2.size()-1;
        string res;
        while(i >= 0 || j >= 0 || carry) {
            int x = i >= 0 ? getInt(num1[i]) : 0;
            int y = j >= 0 ? getInt(num2[j]) : 0;
            int temp = x + y + carry;
            res += getChar(temp % 36);
            carry = temp / 36;
            i -- , j --;
        }
        reverse(res.begin(),res.end());
        return res;
    }
};

int main() {
    Solution s;
    string a = "1b", b = "2x", c;
    c = s.add36Strings(a,b);
    cout << c << endl;
}

```

ASCII码的差值。'a'~'z'通过计算`ch - 'a' + 10`便对应10~35

### 大数相乘(Leetcode43 字符串相乘)

给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。

示例 1:

输入: num1 = "2", num2 = "3"
输出: "6"
示例 2:

输入: num1 = "123", num2 = "456"
输出: "56088"

```java
class Solution {
    public String multiply(String num1, String num2) {
        /**
        num1的第i位(高位从0开始)和num2的第j位相乘的结果在乘积中的位置是[i+j, i+j+1]
        例: 123 * 45,  123的第1位 2 和45的第0位 4 乘积 08 存放在结果的第[1, 2]位中
          index:    0 1 2 3 4  
              
                        1 2 3
                    *     4 5
                    ---------
                          1 5
                        1 0
                      0 5
                    ---------
                      0 6 1 5
                        1 2
                      0 8
                    0 4
                    ---------
                    0 5 5 3 5
        这样我们就可以单独都对每一位进行相乘计算把结果存入相应的index中        
        **/
        
        int n1 = num1.length()-1;
        int n2 = num2.length()-1;
        if(n1 < 0 || n2 < 0) return "";
        int[] mul = new int[n1+n2+2];
        
        for(int i = n1; i >= 0; --i) {
            for(int j = n2; j >= 0; --j) {
                int bitmul = (num1.charAt(i)-'0') * (num2.charAt(j)-'0');      
                bitmul += mul[i+j+1]; // 先加低位判断是否有新的进位
                
                mul[i+j] += bitmul / 10;
                mul[i+j+1] = bitmul % 10;
            }
        }
        
        StringBuilder sb = new StringBuilder();
        int i = 0;
        // 去掉前导0
        while(i < mul.length-1 && mul[i] == 0) 
            i++;
        for(; i < mul.length; ++i)
            sb.append(mul[i]);
        return sb.toString();
    }
}
```

### 面试题08.05 递归乘法

递归乘法。 写一个递归函数，不使用 * 运算符， 实现两个正整数的相乘。可以使用加号、减号、位移，但要吝啬一些。

示例1:

 输入：A = 1, B = 10
 输出：10
示例2:

 输入：A = 3, B = 4
 输出：12

**方法1：递归**

```java
public int multiply(int A, int B) {
    //保持A小于B
    if (A > B) {
        int T = A;
        A = B;
        B = T;
    }
    return dfs(A, B);
}

//A为小的因数
public int dfs(int A, int B) {
    if (A == 0) return 0;//为0的时候，结果为0
    if (A == 1) return B;//为1的时候，B本身
    if (A == 2) return B << 1;//B扩大一倍 *2
    return dfs(2, B) + dfs(A - 2, B);//大于2的情况，先拆分出2 两部分加起来
}
```

**方法2：移位操作**

```java
public int multiply(int A, int B) {
    //保持A小于B
    if (A > B) {
        int T = A;
        A = B;
        B = T;
    }
    int res = 0, i = 0;
    while (A > 0) {// 处理二进制
        if ((A & 1) == 1) {
            res += B << i;
        }
        A >>= 1;
        i++;
    }
    return res;
}
```

### [Leetcode29 两数相除](https://leetcode-cn.com/problems/divide-two-integers/)

给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。

返回被除数 dividend 除以除数 divisor 得到的商。

整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2

 

示例 1:

输入: dividend = 10, divisor = 3
输出: 3
解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
示例 2:

输入: dividend = 7, divisor = -3
输出: -2
解释: 7/-3 = truncate(-2.33333..) = -2

```java
class Solution {
       /**
     * 解题思路：这题是除法，所以先普及下除法术语
     * 商，公式是：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，是一种数学术语。
     * 在一个除法算式里，被除数、余数、除数和商的关系为：(被除数-余数)÷除数=商，记作：被除数÷除数=商...余数，
     * 进而推导得出：商×除数+余数=被除数。
     *
     * 要求商，我们首先想到的是减法，能被减多少次，那么商就为多少，但是明显减法的效率太低
     *
     * 那么我们可以用位移法，因为计算机在做位移时效率特别高，向左移1相当于乘以2，向右位移1相当于除以2
     *
     * 我们可以把一个dividend（被除数）先除以2^n，n最初为31，不断减小n去试探,当某个n满足dividend/2^n>=divisor时，
     *
     * 表示我们找到了一个足够大的数，这个数*divisor是不大于dividend的，所以我们就可以减去2^n个divisor，以此类推
     *
     * 我们可以以100/3为例
     *
     * 2^n是1，2，4，8...2^31这种数，当n为31时，这个数特别大，100/2^n是一个很小的数，肯定是小于3的，所以循环下来，
     *
     * 当n=5时，100/32=3, 刚好是大于等于3的，这时我们将100-32*3=4，也就是减去了32个3，接下来我们再处理4，同样手法可以再减去一个3
     *
     * 所以一共是减去了33个3，所以商就是33
     *
     * 这其中得处理一些特殊的数，比如divisor是不能为0的，Integer.MIN_VALUE和Integer.MAX_VALUE
     *
     */
    public int divide(int dividend, int divisor) {
        if (dividend == 0) {
            return 0;
        }
        if (dividend == Integer.MIN_VALUE && divisor == -1) {
            return Integer.MAX_VALUE;
        }
        boolean negative;
        negative = (dividend ^ divisor) <0;//用异或来计算是否符号相异
        long t = Math.abs((long) dividend);
        long d= Math.abs((long) divisor);
        int result = 0;
        for (int i=31; i>=0;i--) {
            if ((t>>i)>=d) {//找出足够大的数2^n*divisor
                result+=1<<i;//将结果加上2^n
                t-=d<<i;//将被除数减去2^n*divisor
            }
        }
        return negative ? -result : result;//符号相异取反
    }
}
```





### Leetcode66 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。

```java
class Solution {
    public int[] plusOne(int[] digits) {
           // 为防止超出界限
	    	int flag = 1;
	    	for(int i=digits.length-1;i>=0;i--) {
	    		if(digits[i]+flag>=10) {
	    			digits[i] = 0;
	    			flag = 1;
	    		}else {
	    			digits[i]  = digits[i] + flag;
	    			flag = 0;
	    		}
	    	}
	    	// 查看此时的flag
	    	if(flag!=0) {
	    		// 还有余数
	    		int[] new_digits = new int[digits.length+1];
	    		new_digits[0]    = 1;
	    		return new_digits;
	    	}else {
	    		return digits;
	    	}
    }
}
```

### [Leetcode628三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/submissions/)

给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

 

示例 1：

输入：nums = [1,2,3]
输出：6
示例 2：

输入：nums = [1,2,3,4]
输出：24
示例 3：

输入：nums = [-1,-2,-3]
输出：-6

```java
class Solution {
    public int maximumProduct(int[] nums) {
Arrays.sort(nums);
	    	int len = nums.length;
	    	int res = Math.max(nums[len-1]*nums[len-2]*nums[len-3], nums[0]*nums[1]*nums[len-1]);
	    	return res;
    }
}
```

**线性 扫描**

```java
class Solution {
    public int maximumProduct(int[] nums) {
        // 最小的和第二小的
        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;
        // 最大的、第二大的和第三大的
        int max1 = Integer.MIN_VALUE, max2 = Integer.MIN_VALUE, max3 = Integer.MIN_VALUE;

        for (int x : nums) {
            if (x < min1) {
                min2 = min1;
                min1 = x;
            } else if (x < min2) {
                min2 = x;
            }

            if (x > max1) {
                max3 = max2;
                max2 = max1;
                max1 = x;
            } else if (x > max2) {
                max3 = max2;
                max2 = x;
            } else if (x > max3) {
                max3 = x;
            }
        }

        return Math.max(min1 * min2 * max1, max1 * max2 * max3);
    }
}

```

### Leetcode592 分数加减运算


给定一个表示分数加减运算表达式的字符串，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即[最简分数](https://baike.baidu.com/item/最简分数)。 如果最终结果是一个整数，例如 `2`，你需要将它转换成分数形式，其分母为 `1`。所以在上述例子中, `2` 应该被转换为 `2/1`。

**示例 1:**

```
输入:"-1/2+1/2"
输出: "0/1"
```

 **示例 2:**

```
输入:"-1/2+1/2+1/3"
输出: "1/3"
```

**示例 3:**

```
输入:"1/3-1/2"
输出: "-1/6"
```

**示例 4:**

```
输入:"5/3+1/3"
输出: "2/1"
```

```java
public class Solution {
    public String fractionAddition(String expression) {
        List < Character > sign = new ArrayList < > ();
        for (int i = 1; i < expression.length(); i++) {
            if (expression.charAt(i) == '+' || expression.charAt(i) == '-')
                sign.add(expression.charAt(i));
        }
        List < Integer > num = new ArrayList < > ();
        List < Integer > den = new ArrayList < > ();
        for (String sub: expression.split("\\+")) {
            for (String subsub: sub.split("-")) {
                if (subsub.length() > 0) {
                    String[] fraction = subsub.split("/");
                    num.add(Integer.parseInt(fraction[0]));
                    den.add(Integer.parseInt(fraction[1]));
                }
            }
        }
        if (expression.charAt(0) == '-')
            num.set(0, -num.get(0));
        int lcm = 1;
        for (int x: den) {
            lcm = lcm_(lcm, x);
        }

        int res = lcm / den.get(0) * num.get(0);
        for (int i = 1; i < num.size(); i++) {
            if (sign.get(i - 1) == '+')
                res += lcm / den.get(i) * num.get(i);
            else
                res -= lcm / den.get(i) * num.get(i);
        }
        int g = gcd(Math.abs(res), Math.abs(lcm));
        return (res / g) + "/" + (lcm / g);
    }
    public int lcm_(int a, int b) {
        return a * b / gcd(a, b);
    }
    public int gcd(int a, int b) {
        while (b != 0) {
            int t = b;
            b = a % b;
            a = t;
        }
        return a;
    }
}


```

### Leetcode869 重新排列得到2的幂

给定正整数 N ，我们按任何顺序（包括原始顺序）将数字重新排序，注意其前导数字不能为零。

如果我们可以通过上述方式得到 2 的幂，返回 true；否则，返回 false。

 

示例 1：

输入：1
输出：true
示例 2：

输入：10
输出：false
示例 3：

输入：16
输出：true

```java
class Solution {
    public boolean reorderedPowerOf2(int N) {
        int[] A = count(N);
        for (int i = 0; i < 31; ++i)
            if (Arrays.equals(A, count(1 << i)))
                return true;
        return false;
    }

    // Returns the count of digits of N
    // Eg. N = 112223334, returns [0,2,3,3,1,0,0,0,0,0]
    public int[] count(int N) {
        int[] ans = new int[10];
        while (N > 0) {
            ans[N % 10]++;
            N /= 10;
        }
        return ans;
    }
}


```

### Leetcode67 二进制求和

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

 

示例 1:

输入: a = "11", b = "1"
输出: "100"
示例 2:

输入: a = "1010", b = "1011"
输出: "10101"

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuffer ans = new StringBuffer();

        int n = Math.max(a.length(), b.length()), carry = 0;
        for (int i = 0; i < n; ++i) {
            carry += i < a.length() ? (a.charAt(a.length() - 1 - i) - '0') : 0;
            carry += i < b.length() ? (b.charAt(b.length() - 1 - i) - '0') : 0;
            ans.append((char) (carry % 2 + '0'));
            carry /= 2;
        }

        if (carry > 0) {
            ans.append('1');
        }
        ans.reverse();

        return ans.toString();
    }
}


```

### [Leetcode371 两整数之和]

不使用运算符 + 和 - ，计算两整数 a 、b 之和。

示例 1:

输入: a = 1, b = 2
输出: 3
示例 2:

输入: a = -2, b = 3
输出: 1

```java
class Solution {
    public int getSum(int a, int b) {
                return b == 0 ? a : getSum(a^b,(a&b)<<1); 
    }
}
```

### Leetcode454 四数相加II

给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[l] = 0。

为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最终结果不会超过 231 - 1 。

例如:

输入:
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]

输出:
2

解释:
两个元组如下:
1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0

```java
class Solution {
    public int fourSumCount(int[] A, int[] B, int[] C, int[] D) {
        Map<Integer, Integer> countAB = new HashMap<Integer, Integer>();
        for (int u : A) {
            for (int v : B) {
                countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1);
            }
        }
        int ans = 0;
        for (int u : C) {
            for (int v : D) {
                if (countAB.containsKey(-u - v)) {
                    ans += countAB.get(-u - v);
                }
            }
        }
        return ans;
    }
}


```

### Leetcode844 比较含退格的字符串

给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

 

示例 1：

输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
示例 2：

输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
示例 3：



```java
class Solution {
    public boolean backspaceCompare(String S, String T) {
        Stack<Character> stackS = new Stack<>();
        Stack<Character> stackT = new Stack<>();
        char[] sArr = S.toCharArray(), tArr = T.toCharArray();
        for (int i = 0; i < sArr.length; i++) {
            if (sArr[i] == '#') {
                if (!stackS.isEmpty()) {
                    stackS.pop();
                }
            } else {
                stackS.push(sArr[i]);
            }
        }
        for (int i = 0; i < tArr.length; i++) {
            if (tArr[i] == '#') {
                if (!stackT.isEmpty()) {
                    stackT.pop();
                }
            } else {
                stackT.push(tArr[i]);
            }
        }
        while (!stackS.isEmpty() && !stackT.isEmpty()) {
            if (stackS.peek() != stackT.peek()) return false;
            stackS.pop();
            stackT.pop();
        }
        return stackS.isEmpty() && stackT.isEmpty();
    }

}
```

### Leetcode1283 使结果不超过阈值的最小除数

给你一个整数数组 nums 和一个正整数 threshold  ，你需要选择一个正整数作为除数，然后将数组里每个数都除以它，并对除法结果求和。

请你找出能够使上述结果小于等于阈值 threshold 的除数中 最小 的那个。

每个数除以除数后都向上取整，比方说 7/3 = 3 ， 10/2 = 5 。

题目保证一定有解。

 

示例 1：

输入：nums = [1,2,5,9], threshold = 6
输出：5
解释：如果除数为 1 ，我们可以得到和为 17 （1+2+5+9）。
如果除数为 4 ，我们可以得到和为 7 (1+1+2+3) 。如果除数为 5 ，和为 5 (1+1+1+2)。
示例 2：

输入：nums = [2,3,5,7,11], threshold = 11
输出：3

```java
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int left = 0;
        int right = 1000001;
        while (left + 1 < right) {
            int mid = (left + right) / 2;
            long sum = 0;
            for (int num : nums) {
                // 向上取整
                sum += (num + mid - 1) / mid;
            }
            if (sum > threshold) {
                left = mid;
            } else {
                right = mid;
            }
        }
        return right;
    }
}
```

### Leetocde974 和可被K整除的子数组

给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。

 

示例：

输入：A = [4,5,0,-2,-3,1], K = 5
输出：7
解释：
有 7 个子数组满足其元素之和可被 K = 5 整除：
[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]

```java
class Solution {
    public int subarraysDivByK(int[] nums, int k) {
        Map<Integer, Integer> record = new HashMap<Integer, Integer>();
        record.put(0, 1);
        int sum = 0, ans = 0;
        for (int elem : nums) {
            sum += elem;
            // 注意 Java 取模的特殊性，当被除数为负数时取模结果为负数，需要纠正
            int modulus = (sum % k + k) % k;
            int same = record.getOrDefault(modulus, 0);
            ans += same;
            record.put(modulus, same + 1);
        }
        return ans;
    }
}


```

### Leetcode600 不含连续1的非负整数

给定一个正整数 n，找出小于或等于 n 的非负整数中，其二进制表示不包含 连续的1 的个数。

示例 1:

输入: 5
输出: 5
解释: 
下面是带有相应二进制表示的非负整数<= 5：
0 : 0
1 : 1
2 : 10
3 : 11
4 : 100
5 : 101
其中，只有整数3违反规则（有两个连续的1），其他5个满足规则。

```java
public class Solution {
    public int findIntegers(int num) {
        int count = 0;
        for (int i = 0; i <= num; i++)
            if (check(i))
                count++;
        return count;
    }
    public boolean check(int n) {
        int i = 31;
        while (i > 0) {
            if ((n & (1 << i)) != 0 && (n & (1 << (i - 1))) != 0)
                return false;
            i--;
        }
        return true;
    }
}


```



## 优先级队列

### [5.Leetcode373 查找和最小的k对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

> 和之前几个题目思想很像，用一个数组来记录num1中每个元素在nums2中走了多远就可以，每次循环都是nums1和nums2加起来最小的nums1往前走一步

```java
var kSmallestPairs = function(nums1, nums2, k) {
    if (k > nums1.length * nums2.length ) {
        k = nums1.length * nums2.length
    }
    if (nums1.length == 0 || nums2.length == 0) {
        return [];
    }
    let steps = new Array(nums1.length);
    for (let i = 0; i < steps.length; i++) {
        steps[i] = 0;
    }
    let results = [];
    for (let i = 0; i < k; i++) {
        let min = Number.MAX_VALUE;
        let minStepIndex = 0;
        for (let j = 0; j < nums1.length; j++) {
            if (steps[j] < nums2.length && nums2[steps[j]] + nums1[j] < min) {
                min = nums2[steps[j]] + nums1[j];
                minStepIndex = j;
            }
        }
        results.push([nums1[minStepIndex], nums2[steps[minStepIndex]]]);
        steps[minStepIndex]++;
    }
    
    return results;
};
```

给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。

找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。

示例 1:

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
示例 2:

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        //构建数组对
        List<List<Integer>> res = new ArrayList<>();
        // 大顶堆
        PriorityQueue<int[]> queue = new PriorityQueue<>(k,((a,b)->compare(a,b)));
        // 开始
        for(int i:nums1){
            for(int j:nums2){
                int[] arr = new int[]{i,j};
                if(k>queue.size()){
                    queue.offer(arr);
                }else if(compare(arr,queue.peek())>0){
                    queue.poll();
                    queue.offer(arr);
                }
            }
        }
        // 结果
        while(!queue.isEmpty()){
            int[] poll = queue.poll();
            res.add(0,Arrays.asList(poll[0],poll[1]));
        }
        return res;
    }
    // 定义比较函数
    private int compare(int[] arr1,int[] arr2){
        return (arr2[0]+arr2[1])-(arr1[0]+arr1[1]);
    }
}
```

### 20.有序数组间相加和的topk问题

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组 

  按照降序输出 

  [要求] 

  时间复杂度为O(klog⁡k)O(k \log k)O(klogk)  

**输入描述:**

```
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
```

**输出描述:**

```
输出K个整数表示答案
```

示例1

**输入**

```
5 4
1 2 3 4 5
3 5 7 9 11
```

**输出**

```
16 15 14 14
```

```java
import java.util.*;
public class Code04_TopKSumCrossTwoArrays {

    public static class Node {
        int x;
        int y;
        int sum;
        public Node(int x, int y, int sum) {
            this.x = x;
            this.y = y;
            this.sum = sum;
        }
    }
    public static class MaxHeapComp implements Comparator<Node> {
        @Override
        public int compare(Node o1, Node o2) {
            return o2.sum - o1.sum;
        }
    }

    public static int[] topKSum(int[] arr1, int[] arr2, int topK) {
        if (arr1 == null || arr2 == null || topK < 1) return null;
        topK = Math.min(topK, arr1.length * arr2.length);
        int[] res = new int[topK];
        int resIndex = 0;
        // 建立大根堆
        PriorityQueue<Node> maxHeap = new PriorityQueue<>(new MaxHeapComp());
        boolean[][] visit = new boolean[arr1.length][arr2.length];
        int i1 = arr1.length - 1;
        int i2 = arr2.length - 1;
        // 初始化队列
        maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
        visit[i1][i2] = true;
        while (resIndex != topK) {
            Node curNode = maxHeap.poll();
            if (curNode == null) break;
            res[resIndex] = curNode.sum;
            i1 = curNode.x;
            i2 = curNode.y;
            if (i1 - 1 >= 0 && !visit[i1-1][i2]) {
                visit[i1-1][i2] = true;
                maxHeap.add(new Node(i1 - 1, i2, arr1[i1-1] + arr2[i2]));
            }
            if (i2 - 1 >= 0 && !visit[i1][i2-1]) {
                visit[i1][i2-1] = true;
                maxHeap.add(new Node(i1, i2-1, arr1[i1] + arr2[i2-1]));
            }
            resIndex++;
        }
        return res;
    }
    public static void main(String[] args) {
        int n, k;
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        k = sc.nextInt();
        int[] arr1 = new int[n];
        int[] arr2 = new int[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arr2[i] = sc.nextInt();
        }
        int[] res = topKSum(arr1, arr2, k);
        for (int i = 0; i < res.length; i++) {
            if (i == 0) System.out.print(res[i]);
            else System.out.print(" " + res[i]);
        }
        System.out.println();
    }
}

```



## 数值转换

### [NC116 把数字翻译成字符串](https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=117&&tqId=37840&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)-数字翻译成字符串

**描述**

有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。

现在给一串数字，返回有多少种可能的译码结果

**示例1**

输入：

```
"12"
```

复制

返回值：

```
2
```

复制

说明：

```
2种可能的译码结果（”ab” 或”l”）
```

**示例2**

输入：

```
"31717126241541717"
```

复制

返回值：

```
192
```



```java
import java.util.*;


public class Solution {
    /**
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    public int solve (String nums) {
        // write code here
        return dfs(nums.toCharArray(),0);
    }
    
    public int dfs(char[] nums,int start){
        //当start走到终点是
        if(start==nums.length){
            return 1;
        }
        //开始解码当字符为0的时候，0没对应的解码，所以直接返回0
        if(nums[start]=='0'){
            return 0;
        }
        //每次解码一次
        int res1 = dfs(nums,start+1);
        int res2 = 0;
        //如果当前字符等于1
        if( (start<nums.length-1)&&( nums[start]=='1' || (nums[start]=='2'&&nums[start+1]<='6')  )  ){
            res2 = dfs(nums,start+2);
        }
        return res1+res2;
        
        
    }
}
```



### [6.Leetcode012 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给你一个整数，将其转为罗马数字。

> 解题思路：两个数组即可

```JAVA
class Solution {
    public String intToRoman(int num) {
        String[] symbols = {"M" ,"CM","D","CD" ,"C",  "XC","L", "XL","X","IX","V","IV","I"};
        int[] numbers =    {1000, 900,500,400,100,90,50,40,10,9,5,4, 1};
        // 结果
        StringBuilder res = new StringBuilder();
        // 对其遍历
        for(int i=0;i<numbers.length;i++){
            // 临时值
            String symbol = symbols[i];
            int number = numbers[i];
            //判断
            while(num>=number){
                res.append(symbol);
                num -= number;
            }
            // 结束
            if(num==0){
                break;
            }
        }
        // 继续
        return res.toString();
    }
}
```



### [7.Leetcode013 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

> 解题思路：一个hashmap字典来解决

```java
class Solution {
    public int romanToInt(String s) {
        HashMap<String,Integer> dict = new HashMap<>();
        dict.put("M",1000);
        dict.put("CM",900);
        dict.put("D", 500);
        dict.put("CD",400);
        dict.put("C", 100);
        dict.put("XC",90);
        dict.put("L", 50);
        dict.put("XL",40);
        dict.put("X", 10);
        dict.put("IX",9);
        dict.put("V", 5);
        dict.put("IV",4);
        dict.put("I", 1);
        // 对其遍历
        int res = 0;
        int len = s.length();
        // 对其遍历
        for(int i=0;i<len;){
            // 判断两个字符
            if(i+1<len&&dict.containsKey(s.substring(i,i+2))){
                res += dict.get(s.substring(i,i+2));
                i += 2;
            }else{
                // 判断一个字符
                res += dict.get(s.substring(i,i+1));
                i++;
            }
        }
        return res;
    }
}
```

### 中文数字转阿拉伯数字

中文数字格式：一万三千五百四十一     

​      阿拉伯数字格式：13541     

​      中文数字中要分     单位     和     数字     分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。

```java
public class Solution{
   static char[] cnArr = {'零','一', '二', '三', '四', '五', '六', '七', '八', '九'};
   static char[] chArr = {'十', '百', '千', '万', '亿'};
public static int chineseNumToArabicNum(String chineseNum) {
    int result = 0;
    int temp = 1;//存放一个单位的数字如：十万
    int count = 0;//判断是否有表示单位的文字
    for (int i = 0; i < chineseNum.length(); i++) {
        boolean b = true;//判断是否是单位
        char c = chineseNum.charAt(i);
        for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
            if (c == cnArr[j]) {
                if (count != 0) {//添加下一个单位之前，先把上一个单位值添加到结果中
                    result += temp;
                    temp = 1;
                    count = 0;
                }
                // 下标+1，就是对应的值
                temp = j;
                b = false;
                break;
            }
        }
        if (b) {//单位{'十','百','千','万','亿'}
            for (int j = 0; j < chArr.length; j++) {
                if (c == chArr[j]) {
                    switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                    }
                    count++;
                }
            }
        }
        if (i == chineseNum.length() - 1) {//遍历到最后一个字符
            result += temp;
        }
    }
    return result;
}
}
```

```java
package cn.utstarcom.idpvoice.util;
 
/**
 * 工具类，用于将汉语的数字转换为阿拉伯数字
 * @author utsc1243
 * @date 2019年6月12日
 */
public class ChineseNumToArabicNumUtil {
	static char[] cnArr = new char [] {'一','二','三','四','五','六','七','八','九'};
	static char[] chArr = new char [] {'十','百','千','万','亿'};
	static String allChineseNum = "零一二三四五六七八九十百千万亿";
	
	/**
	 * 将汉字中的数字转换为阿拉伯数字
	 * @param chineseNum
	 * @return
	 */
	public static int chineseNumToArabicNum(String chineseNum) {
        int result = 0;
        int temp = 1;//存放一个单位的数字如：十万
        int count = 0;//判断是否有chArr
        for (int i = 0; i < chineseNum.length(); i++) {
            boolean b = true;//判断是否是chArr
            char c = chineseNum.charAt(i);
            for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
                if (c == cnArr[j]) {
                    if(0 != count){//添加下一个单位之前，先把上一个单位值添加到结果中
                        result += temp;
                        temp = 1;
                        count = 0;
                    }
                    // 下标+1，就是对应的值
                    temp = j + 1;
                    b = false;
                    break;
                }
            }
            if(b){//单位{'十','百','千','万','亿'}
                for (int j = 0; j < chArr.length; j++) {
                    if (c == chArr[j]) {
                        switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                        }
                        count++;
                    }
                }
            }
            if (i == chineseNum.length() - 1) {//遍历到最后一个字符
                result += temp;
            }
        }
        return result;
	}
	
	/**
	 * 将数字转换为中文数字， 这里只写到了万
	 * @param intInput
	 * @return
	 */
	public static String arabicNumToChineseNum(int intInput) {
		String si = String.valueOf(intInput);
		String sd = "";
		if (si.length() == 1) {
			if (intInput == 0) {
				return sd;
			}
			sd += cnArr[intInput - 1];
			return sd;
		} else if (si.length() == 2) {
			if (si.substring(0, 1).equals("1")) {
				sd += "十";
				if (intInput % 10 == 0) {
					return sd;
				}
			}
			else
				sd += (cnArr[intInput / 10 - 1] + "十");
			sd += arabicNumToChineseNum(intInput % 10);
		} else if (si.length() == 3) {
			sd += (cnArr[intInput / 100 - 1] + "百");
			if (String.valueOf(intInput % 100).length() < 2) {
				if (intInput % 100 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 100);
		} else if (si.length() == 4) {
			sd += (cnArr[intInput / 1000 - 1] + "千");
			if (String.valueOf(intInput % 1000).length() < 3) {
				if (intInput % 1000 == 0) {
					return sd;
				}			
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 1000);
		} else if (si.length() == 5) {
			sd += (cnArr[intInput / 10000 - 1] + "万");
			if (String.valueOf(intInput % 10000).length() < 4) {
				if (intInput % 10000 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 10000);
		}
 
		return sd;
	}
 
	/**
	 * 判断传入的字符串是否全是汉字数字
	 * @param chineseStr
	 * @return
	 */
	public static boolean isChineseNum(String chineseStr) {
		char [] ch = chineseStr.toCharArray();
		for (char c : ch) {
			if (!allChineseNum.contains(String.valueOf(c))) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 判断数字字符串是否是整数字符串
	 * @param str
	 * @return
	 */
	public static boolean isNum(String str) {
		String reg = "[0-9]+";
		return str.matches(reg);
	}
	
	public static void main(String[] args) {
		System.out.println(arabicNumToChineseNum(39999));
	}
}
```



## 完全平方数

### [Leetcode367 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

 

示例 1：

输入：num = 16
输出：true
示例 2：

输入：num = 14
输出：false

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        // 实现sqrt
        long  res = num;
        while(res*res>num){
            res = (res+num/res)/2;
        }
        return (int)res*(int)res==num;
    }
}
```

### [动态规划-Leetcode279 最少的完全平方数](https://leetcode-cn.com/problems/perfect-squares/)

给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。

给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
示例 2：

输入：n = 13
输出：2
解释：13 = 4 + 9

```java
class Solution {
    public int numSquares(int n) {
        // 动态规划 初始化 转移方程
        int[] dp = new int[n+1];
        for(int  i=1;i<=n;i++){
            // 最坏的情况下
            dp[i] = i;
            // 转移方程
            for(int j=1;i-j*j>=0;j++){
                dp[i] = Math.min(dp[i],dp[i-j*j]+1);
            }
        }
        return dp[n];
    }
}
```

## 丑数

### 1.Leetcode263丑数

**描述**

把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

**示例1**

输入：

```
7
```

复制

返回值：

```
8
```

```java
public class Solution {
    public int GetUglyNumber_Solution(int index) {
        if(index<=0){
            return 0;
        }
        int[] dp = new int[index+1];
        dp[1] = 1;
        int p2 = 1, p3 =1, p5=1;
        for(int i=2;i<=index;i++){
            int num2 = 2*dp[p2], num3=3*dp[p3], num5=5*dp[p5];
            dp[i] = Math.min(num2,Math.min(num3,num5));
            if(dp[i]==num2){
                p2++;
            }
            if(dp[i]==num3){
                p3++;
            }
            if(dp[i]==num5){
                p5++;
            }
        }
        return dp[index];
    }
}
```

### 2.[Leetcode264 丑数II](https://leetcode-cn.com/problems/ugly-number-ii/)

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 

示例 1：

输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
示例 2：

输入：n = 1
输出：1
解释：1 通常被视为丑数。

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        int p2 = 1, p3 = 1, p5 = 1;
        for(int i=2;i<=n;i++){
            int num2 = dp[p2]*2, num3 = dp[p3]*3, num5 = dp[p5]*5;
            dp[i] = Math.min(Math.min(num2,num3),num5);
            if(dp[i]==num2){
                p2++;
            }
            if(dp[i]==num3){
                p3++;
            }
            if(dp[i]==num5){
                p5++;
            }
        }
        return dp[n];
    }
}
```

### 3.[Leetcode1201 丑数III](https://leetcode-cn.com/problems/ugly-number-iii/)

给你四个整数：n 、a 、b 、c ，请你设计一个算法来找出第 n 个丑数。

丑数是可以被 a 或 b 或 c 整除的 正整数 。

 

示例 1：

输入：n = 3, a = 2, b = 3, c = 5
输出：4
解释：丑数序列为 2, 3, 4, 5, 6, 8, 9, 10... 其中第 3 个是 4。
示例 2：

输入：n = 4, a = 2, b = 3, c = 4
输出：6
解释：丑数序列为 2, 3, 4, 6, 8, 9, 10, 12... 其中第 4 个是 6。

```java
class Solution {
    public int nthUglyNumber(int n, int a, int b, int c) {
        if (n < 1 || a < 1 || b < 1 || c < 1) throw new IllegalArgumentException("invalid param");
        
        // 两两组合的最小公倍数
        long lcmAB = lcm(a, b);
        long lcmAC = lcm(a, c);
        long lcmBC = lcm(b, c);
        // 三个数的最小公倍数
        long lcm = lcm(lcmAB, c);
        
        // lcm之内的数字数目，即一个周期内的元素数
        long m = lcm / a + lcm / b + lcm / c - lcm / lcmAB - lcm / lcmAC - lcm / lcmBC + 1;

        long epoch = n / m;
        long r = n % m;
        long result = epoch * lcm;
		
        if (r > 0) {
            // 二分查找，范围缩小为1～lcm
            long left = 1, right = lcm;
            while (left < right) {
                long mid = left + (right - left) / 2;
                long count = mid / a + mid / b + mid / c - mid / lcmAB - mid / lcmAC - mid / lcmBC + mid / lcm;
                if (count >= r) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            }
            // 最后left就是要查找的值
            result += left;
        }

        return (int)result;
    }
    
    // 最小公倍数
    private long lcm(long a, long b) {
        return a * b / gcd(a, b);
    }
    
    // 最大公因数
    private long gcd(long x, long y) {
        if (x == 0) return y;
        return gcd(y % x, x);
    }
}
```

### [4.Leetcode313 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。

给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。

题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。

 

示例 1：

输入：n = 12, primes = [2,7,13,19]
输出：32 
解释：给定长度为 4 的质数数组 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。
示例 2：

输入：n = 1, primes = [2,3,5]
输出：1
解释：1 不含质因数，因此它的所有质因数都在质数数组 primes = [2,3,5] 中。

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<Long>queue=new PriorityQueue<>();
        long res=1;
        for(int i=1;i<n;i++){
            for(int prime:primes){
                queue.add(prime*res);
            }
            res=queue.poll();
            while(!queue.isEmpty()&&res==queue.peek()) queue.poll();
        }
        return (int)res;
        
    }
}
```

### [5.Leetcode507 完美数](https://leetcode-cn.com/problems/perfect-number/)

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true，否则返回 false

 

示例 1：

输入：28
输出：True
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
示例 2：

输入：num = 6
输出：true

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
         if (num == 1) {
            return false;
        }
        //第一个正因子
        int sum = 1;
        for (int i = 2; i * i <= num; i++) {
            //找到正因子
            if (num % i == 0) {
                //相加
                sum += i;
                //将数字相除
                if (i * i != num) {
                    sum += num / i;
                }

            }
        }
        return sum == num;
    }
}
```

### [6.Leetcode1291 顺次数](https://leetcode-cn.com/problems/sequential-digits/)

我们定义「顺次数」为：每一位上的数字都比前一位上的数字大 1 的整数。

请你返回由 [low, high] 范围内所有顺次数组成的 有序 列表（从小到大排序）。

 

示例 1：

输出：low = 100, high = 300
输出：[123,234]
示例 2：

输出：low = 1000, high = 13000
输出：[1234,2345,3456,4567,5678,6789,12345]

```java
class Solution {
    public List<Integer> sequentialDigits(int low, int high) {
        List<Integer> res = new LinkedList<>();
        //顺次数第一位(1~9);遍历以i开头的所有顺次数
        for (int i = 1; i <= 9; i++) {
            int num = i;
            //顺次数其他位;其他位都比上一位多1,使用j++
            for (int j = i + 1; j <= 9; j++) {
                //因为是尾部添加，所以之前的数字要扩大十倍
                num = num * 10 + j;
                //如果这个顺次数在范围内，加入结果集
                if (num >= low && num <= high) {
                    res.add(num);
                }
            }
        }
        //调用集合工具包排序方法进行排序
        Collections.sort(res);
        return res;
    }
}
```

### [Leetcode202 快乐数](https://leetcode-cn.com/problems/happy-number/)

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」定义为：

对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
如果 可以变为  1，那么这个数就是快乐数。
如果 n 是快乐数就返回 true ；不是，则返回 false 。

 

示例 1：

输入：19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1

```java
class Solution {
    public int bitSqureSum(int n){
        int sum = 0;
        while(n>0){
            int bit = n%10;
            sum += bit*bit;
            n = n/10;
        }
        return sum;
    }

    public boolean isHappy(int n) {
        int slow = n;
        int fast = n;
        do{
            slow = bitSqureSum(slow);
            fast = bitSqureSum(fast);
            fast = bitSqureSum(fast);

        }while(slow!=fast);
        return slow==1;
    }
}
```



## 计算器

### [10.Leetcode面试题16.26 计算器(+ - x /)](https://leetcode-cn.com/problems/calculator-lcci/)

给定一个包含正整数、加(+)、减(-)、乘(*)、除(/)的算数表达式(括号除外)，计算其结果。

表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格  。 整数除法仅保留整数部分。

示例 1:

输入: "3+2*2"
输出: 7
示例 2:

输入: " 3/2 "
输出: 1
示例 3:

输入: " 3+5 / 2 "
输出: 5

> 单独一个栈

```java
class Solution {
    public int calculate(String s) {
        // 用栈来辅助
        Stack<Integer> stack = new Stack<>();
        // 符号 默认是整数
        char preSign = '+';
        // 数字
        int num = 0;
        // 对其遍历
        int len = s.length();
        // 对其循环遍历
        for(int i=0;i<len;i++){
            //判断是否是整数
            if(Character.isDigit(s.charAt(i))){
                num =  num*10 + s.charAt(i)-'0';
            }
            // 判断不是数字且不空格那就是新符号  或者到最后了
            if(!Character.isDigit(s.charAt(i))&&s.charAt(i)!=' ' || i==len-1){
                switch(preSign){
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop()*num);
                        break;
                    default:
                        stack.push(stack.pop()/num);
                }
                // 更新
                preSign = s.charAt(i);
                num = 0;
            }
        }
        // 结果
        int res = 0;
        while(!stack.isEmpty()){
            res += stack.pop();
        }
        return res;
    }
}
```

### [11.Leetcode224 基本计算器( + - ( ) ) ](https://leetcode-cn.com/problems/basic-calculator/)

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

 

示例 1：

输入：s = "1 + 1"
输出：2
示例 2：

输入：s = " 2-1 + 2 "
输出：3
示例 3：

输入：s = "(1+(4+5+2)-3)+(6+8)"
输出：23

```java
class Solution {
    public int calculate(String s) {
        // 一个栈来存储当前符号
        Stack<Integer> sign = new Stack<>();
        sign.push(1); //默认是正

        // 结果
        int res = 0;
        int num =  0;
        int op = 1;
        // 遍历
        for(char ch:s.toCharArray()){
            if(ch>='0'&&ch<='9'){
                num = num*10 + (ch-'0');
                continue;
            }
            // 计算一个运算符
            res += op*num;
            num = 0;

            // 栈中的
            if(ch=='+'){
                op = sign.peek();
            }else if(ch=='-'){
                op = -sign.peek();
            }else if(ch=='('){
                sign.push(op);
            }else if(ch==')'){
                sign.pop();
            }
        }
        res += op*num;
        return res;
    }
}
```

### [12.Leetcode991 坏了的计算器](https://leetcode-cn.com/problems/broken-calculator/)-（整数转换）

在显示着数字的坏计算器上，我们可以执行以下两种操作：

双倍（Double）：将显示屏上的数字乘 2；
递减（Decrement）：将显示屏上的数字减 1 。
最初，计算器显示数字 X。

返回显示数字 Y 所需的最小操作数。

 

示例 1：

输入：X = 2, Y = 3
输出：2
解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.
示例 2：

输入：X = 5, Y = 8
输出：2
解释：先递减，再双倍 {5 -> 4 -> 8}.
示例 3：

输入：X = 3, Y = 10
输出：3
解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.

> 解题思路：逆向思维，y可以加1或者除以2，让y尽可能除以2，最快的接近x

```java
class Solution {
    // 逆向思维，y可以加1或者除以2，让y尽可能除以2，最快的接近x
    public int brokenCalc(int x, int y) {
        int result = 0;
        while(x<y){
            //判断
            if(y%2==0){
                y/=2;
                result++;
            }else{
                y=(y+1)/2;
                result+=2;
            }
        }
        //判断
        return result+x-y;
    }
}
```

### 0.一个数转换另一个数(四个操作)



```java
package com.yao;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Scanner;

public class Main2 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int T = in.nextInt();
        for (int i = 0; i < T; i++) {
            int P = in.nextInt();
            int Q = in.nextInt();
            int res = bfs(P,Q);
            System.out.println(res);
        }
    }
    private static int bfs(int P, int Q){
        if(P==Q) return 0;
        LinkedList<Integer> list = new LinkedList<>();
        HashSet<Integer> ins = new HashSet<>();
        list.add(P);
        ins.add(P);
        int deep=0;
        while (!list.isEmpty()){
            deep++;
            int size = list.size();
            for(int i=0;i<size;++i){
                int v = list.pollFirst();
                if(v+1==Q||v-2==Q||v*2==Q||v-1==Q) return deep;
                if(!ins.contains(v+1)&&v<Q){
                    list.addLast(v+1);
                    ins.add(v+1);
                }
                if(!ins.contains(v-1)){
                    list.addLast(v-1);
                    ins.add(v-1);
                }
                if(!ins.contains(v-2)){
                    list.addLast(v-2);
                    ins.add(v-2);
                }
                if(!ins.contains(v*2)&&v<Q){
                    list.addLast(v*2);
                    ins.add(v*2);
                }
            }
        }
        return -1;
    }
}
```



### 0.计算器

中序遍历转后序遍历

```java
import java.util.*;

/**
中缀表达式转后缀表达式的方法：
1.遇到操作数：直接输出（添加到后缀表达式中）
2.栈为空时，遇到运算符，直接入栈
3.遇到左括号：将其入栈
4.遇到右括号：执行出栈操作，并将出栈的元素输出，直到弹出栈的是左括号，左括号不输出。
5.遇到其他运算符：加减乘除：弹出所有优先级大于或者等于该运算符的栈顶元素【栈内的栈顶运算符>=遇到的运算符，就弹出】，然后将该运算符入栈
6.最终将栈中的元素依次出栈，输出。
后缀表达式的计算
用栈存放每个数字，每当便利到运算符时，弹出栈顶的两个元素，用第二个栈顶元素操作第一个
*/
import java.util.*;
import java.util.stream.Collectors;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 返回表达式的值
     * @param s string字符串 待计算的表达式
     * @return int整型
     */
    public int solve (String s) {
        // write code here
           // write code here
        String rpn=toSuffix(s);
        return getRPNval(rpn);
    }
    public int getRPNval(String equation){
        Stack<Integer> stack=new Stack<Integer>();
        String [] rpnString = equation.split(",");
        int a,b;
        for(int i=0;i<rpnString.length;i++){
            String c=rpnString[i];
            if(c.equals("+")){
                a=stack.pop();
                b=stack.pop();
                stack.add(b+a);
            }
            else if(c.equals("-")){
                a=stack.pop();
                b=stack.pop();
                stack.add(b-a);
            }
            else if(c.equals("*")){
                a=stack.pop();
                b=stack.pop();
                stack.add(b*a);
            }
            else if(c.equals("/")){
                a=stack.pop();
                b=stack.pop();
                stack.add(b/a);
            }
            else{
                 stack.add(Integer.parseInt(c));
            }
        }
        return stack.peek();
    }
     /**
     * 将  中缀表达式  转化为  后缀表达式
     */
    public String toSuffix(String infix){
        Map<Character, Integer> basic = new HashMap<Character, Integer>();
        basic.put('-', 1);
        basic.put('+', 1);
        basic.put('*', 2);
        basic.put('/', 2);
        basic.put('(', 0);//在运算中  （）的优先级最高，但是此处因程序中需要 故设置为0
 
        List<String> queue = new ArrayList<String>();                                   
        //定义队列  用于存储 数字  以及最后的  后缀表达式
        List<Character> stack = new ArrayList<Character>();                            
        //定义栈    用于存储  运算符  最后stack中会被 弹空
 
        char[] charArr = infix.trim().toCharArray();                                   
        //字符数组  用于拆分数字或符号
        String standard = "*/+-()";                                                       
        //判定标准 将表达式中会出现的运算符写出来
        char ch = '&';                                                                   
        //在循环中用来保存 字符数组的当前循环变量的  这里仅仅是初始化一个值  没有意义
        int len = 0;                                                                   
        //用于记录字符长度 【例如100*2,则记录的len为3 到时候截取字符串的前三位就是数字】
        for (int i = 0; i < charArr.length; i++) {                                       
            //开始迭代
 
            ch = charArr[i];                                                           
            //保存当前迭代变量
            if(Character.isDigit(ch)) {                                                   
                //如果当前变量为 数字
                len++;
            }else if(Character.isLetter(ch)) {                                           
                //如果当前变量为  字母
                len++;
            }else if(ch == '.'){                                                       
                //如果当前变量为  .  会出现在小数里面
                len++;
            }else if(Character.isSpaceChar(ch)) {                                       
                //如果当前变量为 空格  支持表达式中有空格出现
                if(len > 0) {                                                           
                     //若为空格 代表 一段结束 ，就可以往队列中  存入了  【例如100 * 2  100后面有空格 就可以将空格之前的存入队列了】
                    queue.add(String.valueOf(Arrays.copyOfRange(charArr, i - len, i)));   
                    //往 队列存入 截取的 字符串
                    len = 0;                                                           
                    //长度置空
                }
                continue;                                                               
                //如果空格出现，则一段结束  跳出本次循环
            }else if(standard.indexOf(ch) != -1) {                                       
                //如果是上面标准中的 任意一个符号
                if(len > 0) {                                                           
                    //长度也有
                    queue.add(String.valueOf(Arrays.copyOfRange(charArr, i - len, i)));   
                    //说明符号之前的可以截取下来做数字
                    len = 0;                                                           
                    //长度置空
                }
                if(ch == '(') {                                                           
                    //如果是左括号
                    stack.add(ch);                                                       
                    //将左括号 放入栈中
                    continue;                                                           
                    //跳出本次循环  继续找下一个位置
                }
                if (!stack.isEmpty()) {                                                   
                    //如果栈不为empty
                    int size = stack.size() - 1;                                       
                    //获取栈的大小-1  即代表栈最后一个元素的下标
                    boolean flag = false;                                               
                    //设置标志位
                    while (size >= 0 && ch == ')' && stack.get(size) != '(') {           
                        //若当前ch为右括号，则 栈里元素从栈顶一直弹出，直到弹出到 左括号
                        queue.add(String.valueOf(stack.remove(size)));                   
                        //注意此处条件：ch并未入栈，所以并未插入队列中；
                        //同样直到找到左括号的时候，循环结束了，所以左括号也不会放入队列中
                        //【也就是：后缀表达式中不会出现括号】
                        size--;                                                           
                        //size-- 保证下标永远在栈最后一个元素【栈中概念：指针永远指在栈顶元素】
                        flag = true;                                                   
                        //设置标志位为true  表明一直在取（）中的元素
                    }
                    while (size>=0 && !flag && basic.get(stack.get(size)) >= basic.get(ch)){
                        //若取得不是（）内的元素，并且当前栈顶元素的优先级>=对比元素 那就出栈插入队列
                        queue.add(String.valueOf(stack.remove(size)));                   
                        //同样  此处也是remove()方法，既能得到要获取的元素，也能将栈中元素移除掉
                        size--;
                    }
                }
                if(ch != ')') {                                                           
                    //若当前元素不是右括号
                    stack.add(ch);                                                       
                    //就要保证这个符号 入栈
                } else {                                                               
                    //否则就要出栈 栈内符号
                    stack.remove(stack.size() - 1);
                }
            }
            if(i == charArr.length - 1) {                                               
                //如果已经走到了  中缀表达式的最后一位
                if(len > 0) {                                                           
                    //如果len>0  就截取数字
                    queue.add(String.valueOf(Arrays.copyOfRange(charArr, i - len+1, i+1)));
                }
                int size = stack.size() - 1;                                           
                //size表示栈内最后一个元素下标
                while (size >= 0) {                                                       
                    //一直将栈内  符号全部出栈 并且加入队列中 
                    //【最终的后缀表达式是存放在队列中的，而栈内最后会被弹空】
                    queue.add(String.valueOf(stack.remove(size)));
                    size--;
                }
            }
 
        }
        return queue.stream().collect(Collectors.joining(","));                           
        //将队列中元素以,分割 返回字符串
    }
}
```

### Leetcode241 为运算表达式设计优先级

给定一个含有数字和运算符的字符串，为表达式添加括号，改变其运算优先级以求出不同的结果。你需要给出所有可能的组合的结果。有效的运算符号包含 +, - 以及 * 。

示例 1:

输入: "2-1-1"
输出: [0, 2]
解释: 
((2-1)-1) = 0 
(2-(1-1)) = 2
示例 2:

输入: "2*3-4*5"
输出: [-34, -14, -10, -10, 10]
解释: 
(2*(3-(4*5))) = -34 
((2*3)-(4*5)) = -14 
((2*(3-4))*5) = -10 
(2*((3-4)*5)) = -10 
(((2*3)-4)*5) = 10

```java
class Solution {
     Map<String, List<Integer>> map = new HashMap<>();
    
    public List<Integer> diffWaysToCompute(String input) {
        
        if (map.containsKey(input))
            return map.get(input);
        
        List<Integer> res = new LinkedList<>();
        
        for (int i = 0; i < input.length(); i++) {
            
            char ch = input.charAt(i);
            if (ch == '+' || ch == '-' || ch == '*') {
                
                List<Integer> left = diffWaysToCompute(input.substring(0, i));
                List<Integer> right = diffWaysToCompute(input.substring(i + 1));
                
                for (int l : left) {
                    
                    for (int r : right) {
                        
                        if (ch == '+')
                            res.add(l + r);
                        else if (ch == '-')
                            res.add(l - r);
                        else
                            res.add(l * r);
                    }
                }
            }
        }
        if (res.size() == 0)
            res.add(Integer.parseInt(input));
        
        map.put(input, res);
        
        return res;
    }
}
```

### Leetcode679 24点游戏

你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。

示例 1:

输入: [4, 1, 8, 7]
输出: True
解释: (8-4) * (7-1) = 24
示例 2:

输入: [1, 2, 1, 2]
输出: False

```java
class Solution {
    static final int TARGET = 24;
    static final double EPSILON = 1e-6;
    static final int ADD = 0, MULTIPLY = 1, SUBTRACT = 2, DIVIDE = 3;

    public boolean judgePoint24(int[] nums) {
        List<Double> list = new ArrayList<Double>();
        for (int num : nums) {
            list.add((double) num);
        }
        return solve(list);
    }

    public boolean solve(List<Double> list) {
        if (list.size() == 0) {
            return false;
        }
        if (list.size() == 1) {
            return Math.abs(list.get(0) - TARGET) < EPSILON;
        }
        int size = list.size();
        for (int i = 0; i < size; i++) {
            for (int j = 0; j < size; j++) {
                if (i != j) {
                    List<Double> list2 = new ArrayList<Double>();
                    for (int k = 0; k < size; k++) {
                        if (k != i && k != j) {
                            list2.add(list.get(k));
                        }
                    }
                    for (int k = 0; k < 4; k++) {
                        if (k < 2 && i > j) {
                            continue;
                        }
                        if (k == ADD) {
                            list2.add(list.get(i) + list.get(j));
                        } else if (k == MULTIPLY) {
                            list2.add(list.get(i) * list.get(j));
                        } else if (k == SUBTRACT) {
                            list2.add(list.get(i) - list.get(j));
                        } else if (k == DIVIDE) {
                            if (Math.abs(list.get(j)) < EPSILON) {
                                continue;
                            } else {
                                list2.add(list.get(i) / list.get(j));
                            }
                        }
                        if (solve(list2)) {
                            return true;
                        }
                        list2.remove(list2.size() - 1);
                    }
                }
            }
        }
        return false;
    }
}

```





## 前k个数的应用（有序矩阵的查找，K）

### [Leetcode395 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

 

示例 1：

输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：

输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int ret = 0;
        int n = s.length();
        for (int t = 1; t <= 26; t++) {
            int l = 0, r = 0;
            int[] cnt = new int[26];
            int tot = 0;
            int less = 0;
            while (r < n) {
                cnt[s.charAt(r) - 'a']++;
                if (cnt[s.charAt(r) - 'a'] == 1) {
                    tot++;
                    less++;
                }
                if (cnt[s.charAt(r) - 'a'] == k) {
                    less--;
                }

                while (tot > t) {
                    cnt[s.charAt(l) - 'a']--;
                    if (cnt[s.charAt(l) - 'a'] == k - 1) {
                        less++;
                    }
                    if (cnt[s.charAt(l) - 'a'] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                if (less == 0) {
                    ret = Math.max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
}


```



### [1.Leetcode木头切割](https://leetcode-cn.com/circle/discuss/LV19z5/)（二分法，对有序的长度遍历）

给定长度为n的数组，每个元素代表一个木头的长度，木头可以任意截断，从这堆木头中截出至少k个相同长度为m的木块。已知k，求max(m)。

ps: 截断的长度必须是整数

输入两行，第一行n, k，第二行为数组序列。输出最大值。

输入
5 5
4 7 2 10 5
输出
4
解释：如图，最多可以把它分成5段长度为4的木头

**（1）暴力求解**

大概思路就是从1遍历到木棍最长的长度，每次遍历的长度作为m，如果可以将所有木头截出来k个长度为m的木块，则更新最大值，最后输出最大值即可。可以通过下面的伪代码片段辅助理解：

```java
// input n, k;
int maxV = max(a[0 ~ n - 1]);
int res = 0;
int m = 1;
while (m <= maxV)
{
    int cnt = 0;
    for (int i = 0; i < n; i ++ ) cnt += a[i] / m;
    if (cnt >= k) res = max(res, m);  // 如果当前可以截出来超过k段，就更新结果
    m ++;
}

cout << res << endl;
```

时间复杂度也很容易看出来是O(n * len), len为木头中最大的长度。容易想到遍历长度时可以从大到小遍历，if (cnt >= k)成立，则该值即为最终结果，可直接break，但最坏时间复杂度没变。

**（2）二分法**

 方法一在[1,max]寻找最大长度时是顺序遍历，由于其有序，我们可借助二分来快速检出结果。如果能截出来k个长度为x的木块，说明答案肯定 >= x，则接下来只需在[x,max]中找m最大满足条件的长度。反之则说明答案 < x，则在[1,x-1]中寻找结果。这样我们每次可以舍弃1/2的情况，因此使用二分的时间复杂度是O(n * log Len)

```java
#include <iostream>
using namespace std;

const int N = 100010;
int a[N];
int n, k;

int check(int mid)
{
    int res = 0;
    for (int i = 0; i < n; i ++ ) res += a[i] / mid;
    return res;
}

int main()
{
    cin >> n >> k;
    int l = 1, r = -1;
    
    for (int i = 0; i < n; i ++ )
    {
        cin >> a[i];
        r = max(r, a[i]);
    }
    
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid) >= k) l = mid;
        else r = mid - 1;
    }
    
    cout << l << endl;
    return 0;
}
```

**浮点数二分法**

```java
#include <iostream>
#include <cmath>
using namespace std;

const int N = 1e5 + 10;
double a[N];
int n, k;
double eps = 1e-6;

bool check(double l) {
    int cnt = 0;
    for(int i = 0; i < n; i ++) {
        cnt += a[i] / l;
    }    
    return cnt >= k;
}

int main() {
    
    double l = 0, r = -1, mid;
    cin >> n >> k;
    
    for(int i = 0; i < n; i ++) {
        cin >> a[i];
        r = max(r,a[i]);
    }
    
    while( r - l > eps) {
        mid = (l + r) / 2;
        if(check(mid)) l = mid;
        else r = mid;
    }
    printf("%.2lf\n", l);
    
    return 0;
}

```

### [Leetcode变形题1.最小化去加油站的最大距离Minimize Max Distance to Gas Station]

On a horizontal number line, we have gas stations at positions `stations[0], stations[1], ..., stations[N-1]`, where `N = stations.length`.

Now, we add `K` more gas stations so that D, the maximum distance between adjacent gas stations, is minimized.

Return the smallest possible value of D.

Example:

```
Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9
Output: 0.500000
```

Note:

1. `stations.length` will be an integer in range `[10, 2000]`.
2. `stations[i]` will be an integer in range `[0, 10^8]`.
3. `K` will be an integer in range `[1, 10^6]`.
4. Answers within `10^-6` of the true value will be accepted as correct.

思路：首先如何使得每个station之间的最大距离最小，比如：两个station为[1, 9]，间隔为8。要插入一个station使得最大距离最小，插入后应该为[1, 5, 9]，最大间隔为4。如果插入后为[1, 6, 9], [1, 3, 9]，它们的最大间隔分别为5， 6，不是最小。可以看出，**对于插入k个station使得最大间隔最小的唯一办法是均分。**

一种贪心的做法是，找到最大的gap，插入1个station，依此类推，但很遗憾，这种贪心策略是错误的。问题的难点在于我们无法确定到底哪两个station之间需要插入station，插入几个station也无法得知。用DP会内存超标MLE，用堆会时间超标TLE。

换个思路，如果假设知道了答案会怎么样？因为知道了最大间隔，所以如果目前的两个station之间的gap没有符合最大间隔的约束，就必须添加新的station来让它们符合最大间隔的约束，这样对于每个gap能够求得需要添加station的个数。如果需求数<=K，说明还可以进一步减小最大间隔，直到需求数>K。

```c++
class Solution {
public:
    double minmaxGasDist(vector<int>& stations, int K) {
        double left = 0, right = 1e8;
        while (right - left > 1e-6) {
            double mid = left + (right - left) / 2;
            int cnt = 0, n = stations.size();
            for (int i = 0; i < n - 1; ++i) {
                cnt += (stations[i + 1] - stations[i]) / mid;
            }
            if (cnt <= K) right = mid;
            else left = mid;
        }
        return left;
    }
};
```

**题目描述**
在一个水平直线上，有N个加油站，位置分别在stations[0], stations[1], …, stations[N-1]。现在可以添加K个加油站到直线上任意位置，求添加K个加油站后，加油站的最小的最大距离是多少。

样例
Input: stations = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], K = 9
Output: 0.500000
算法1
二分法 O(nlogM)O(nlogM) M为二分的范围
对添加K个加油站后最小的最大距离进行二分，二分的范围为start=0, end=10^9。如果添加K个加油站后，加油站之间的最大距离能减小到x，则结果的范围为[x, end]；否则为[start, x]

时间复杂度分析：O(nlogM)O(nlogM)，二分的复杂度为logM，判断当前最小的最大距离是否合法的复杂度为n

Java 代码

```java
class Solution {
    public double minmaxGasDist(int[] stations, int K) {
        double s=0, e=10e9;
        while(e-s>1e-8) {
            double mid = (s+e)/2;
            if(checkMin(stations, mid, K)<0) s=mid;
            else e=mid;
        }
        return s;
    }


    private int checkMin(int[] stations, double dist, int k) {
        for(int i=1; i<stations.length; i++) {
            double gap = (double)(stations[i] - stations[i-1]);
            if(gap>dist) {
                k-=(int)(gap/dist);
                if(gap%dist==0) k--;
            }
        }
        return k;
    }

}


```

### [Leetcode719 找出第k小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)

给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。

示例 1:

输入：
nums = [1,3,1]
k = 1
输出：0 
解释：
所有数对如下：
(1,3) -> 2
(1,1) -> 0
(3,1) -> 2
因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。

```java
class Solution {
    public int smallestDistancePair(int[] nums, int k) {
        // 1.排序
        Arrays.sort(nums);
        // 2.二分法
        int len = nums.length-1;
        int l = 0;
        int r = nums[len]-nums[0];
        while(l<r){
            int mid = l + ((r-l)>>1);
            int count = 0;
            int left = 0;
            for(int right =0;right<=len;right++){
                while(nums[right]-nums[left]>mid){
                    left++;
                }
                count += right-left;
            }
            if(count>=k){
                r = mid;
            }else{
                l = mid+1;
            }
        }
        return l;
    }
}
```

### [Leetcode378有序矩阵中第k小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/)

给你一个 n x n 矩阵 matrix ，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。
请注意，它是 排序后 的第 k 小元素，而不是第 k 个 不同 的元素。

 

示例 1：

输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8
输出：13
解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13
示例 2：

输入：matrix = [[-5]], k = 1
输出：-5

```java
class Solution {
    public int kthSmallest(int[][] matrix, int k) {
        int row = matrix.length;
        int col = matrix[0].length;
        int left = matrix[0][0];
        int right = matrix[row-1][col-1];
        while(left<right){
            int mid = left+((right-left)>>1);
            //找出二维矩阵中<=mid的元素个数总个数
            int count = findNotBiggerThanMid(matrix,mid,row,col);
            if(count<k){
                //第k小的数在右半部分
                left = mid+1;
            }else{
                right = mid;
            }
        }
        return left;
    }
    public int findNotBiggerThanMid(int[][] matrix,int mid,int row,int col){
        //以列为单位，找到每一列最后一个<=mid的数即知道每一列有多少个数<=mid
        int i = row-1;
        int j = 0;
        int count = 0;
        while(i>=0&&j<col){
            if(matrix[i][j]<=mid){
                //第j列有i+1个元素<=mid
                count += i+1;
                j++;
            }else{
                //第j列目前的数大于mid，需要继续在当前列往上找
                i--;
            }
        }
        return count;
    }

}
```



### 2.Leetcode668 乘法表中第k小的数

几乎每一个人都用 乘法表。但是你能在乘法表中快速找到第k小的数字吗？

给定高度m 、宽度n 的一张 m * n的乘法表，以及正整数k，你需要返回表中第k 小的数字。

例 1：

输入: m = 3, n = 3, k = 5
输出: 3
解释: 
乘法表:
1	2	3
2	4	6
3	6	9

第5小的数字是 3 (1, 2, 2, 3, 3).
例 2：

输入: m = 2, n = 3, k = 6
输出: 6
解释: 
乘法表:
1	2	3
2	4	6

第6小的数字是 6 (1, 2, 2, 3, 4, 6).

```java
class Solution {
 public:
     int findKthNumber(int m, int n, int k) {
         int left = 1, right = m * n;
         while (left < right) {
             int mid = left + (right - left) / 2, cnt = 0;
             for (int i = 1; i <= m; ++i) {
                 cnt += (mid > n * i) ? n : (mid / i);
             }
             if (cnt < k) left = mid + 1;
             else right = mid;
         }
         return right;
     }
 };
```





```java
class Solution {
    public int findKthNumber(int m, int n, int k) {
        int low = 1;
        int high = m*n+1;
        while(low<high){
            int mid = (low+high)/2;
            int cnt = smallNumCount(mid,m,n);
            if(cnt>=k){
                high = mid;
            }else{
                low = mid+1;
            }
        }
        return low;
    }

    // 在m，n的乘法表中，寻找不大于num的元素个数
    public int smallNumCount(int num,int m,int n){
        int count = 0;
        for(int i=1;i<=m;i++){
            count += Math.min(num/i,n);
        }
        return count;
    }
}
```

### 面试题10.09 排序矩阵查找

给定M×N矩阵，每一行、每一列都按升序排列，请编写代码找出某元素。

示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false

```java
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix.length<1) return false;
        int x = matrix.length-1;
        int y = 0;
        int length =matrix[0].length;
        while(x>=0&& y<length){
            //存在返回true
            if(matrix[x][y] == target) return true;
            //小于目标值右移
            else if(matrix[x][y] < target) y++;
            //大于目标值上移
            else if(matrix[x][y] > target) x--;
        }
        return false;
    }
}


```





## 数组、数字去除重复

### [1.Leetcode316去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。

注意：该题与 1081 https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters 相同

 

示例 1：

输入：s = "bcabc"
输出："abc"
示例 2：

输入：s = "cbacdcbc"
输出："acdb"

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        // 统计最后出现的索引
        int[] dict = new int[26];
        // 对字符串进行转换
        char[] arr = s.toCharArray();
        // 统计
        for(int i=0;i<arr.length;i++){
            dict[arr[i]-'a'] = i; // 记录最后出现的索引
        }

        // 记录是否已加入栈
        boolean[] visited = new boolean[26];
        Stack<Character> stack = new Stack<>();
        // 对其遍历
        for(int i=0;i<arr.length;i++){
            //如果已加入
            if(visited[arr[i]-'a']){
                continue;
            }

            // 如果还有
            while(!stack.isEmpty()&&stack.peek()>arr[i]&&dict[stack.peek()-'a']>i){
                Character temp = stack.pop();
                visited[temp-'a'] = false;
            }
            //加入栈中
            stack.push(arr[i]);
            visited[arr[i]-'a'] = true;
        } 

        // 结果
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()){
            sb.append(stack.pop());
        }
        return sb.reverse().toString();
    }
}
```

### [2.Leetcode拼接数](https://leetcode-cn.com/problems/create-maximum-number/)

给定长度分别为 m 和 n 的两个数组，其元素由 0-9 构成，表示两个自然数各位上的数字。现在从这两个数组中选出 k (k <= m + n) 个数字拼接成一个新的数，要求从同一个数组中取出的数字保持其在原数组中的相对顺序。

求满足该条件的最大数。结果返回一个表示该最大数的长度为 k 的数组。

说明: 请尽可能地优化你算法的时间和空间复杂度。

示例 1:

输入:
nums1 = [3, 4, 6, 5]
nums2 = [9, 1, 2, 5, 8, 3]
k = 5
输出:
[9, 8, 6, 5, 3]

```java
class Solution {
    public int[] maxNumber(int[] nums1, int[] nums2, int k) {
        int m = nums1.length, n = nums2.length;
        int[] maxSubsequence = new int[k];
        int start = Math.max(0, k - n), end = Math.min(k, m);
        for (int i = start; i <= end; i++) {
            int[] subsequence1 = maxSubsequence(nums1, i);
            int[] subsequence2 = maxSubsequence(nums2, k - i);
            int[] curMaxSubsequence = merge(subsequence1, subsequence2);
            if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {
                System.arraycopy(curMaxSubsequence, 0, maxSubsequence, 0, k);
            }
        }
        return maxSubsequence;
    }

    public int[] maxSubsequence(int[] nums, int k) {
        int length = nums.length;
        int[] stack = new int[k];
        int top = -1;
        int remain = length - k;
        for (int i = 0; i < length; i++) {
            int num = nums[i];
            while (top >= 0 && stack[top] < num && remain > 0) {
                top--;
                remain--;
            }
            if (top < k - 1) {
                stack[++top] = num;
            } else {
                remain--;
            }
        }
        return stack;
    }

    public int[] merge(int[] subsequence1, int[] subsequence2) {
        int x = subsequence1.length, y = subsequence2.length;
        if (x == 0) {
            return subsequence2;
        }
        if (y == 0) {
            return subsequence1;
        }
        int mergeLength = x + y;
        int[] merged = new int[mergeLength];
        int index1 = 0, index2 = 0;
        for (int i = 0; i < mergeLength; i++) {
            if (compare(subsequence1, index1, subsequence2, index2) > 0) {
                merged[i] = subsequence1[index1++];
            } else {
                merged[i] = subsequence2[index2++];
            }
        }
        return merged;
    }

    public int compare(int[] subsequence1, int index1, int[] subsequence2, int index2) {
        int x = subsequence1.length, y = subsequence2.length;
        while (index1 < x && index2 < y) {
            int difference = subsequence1[index1] - subsequence2[index2];
            if (difference != 0) {
                return difference;
            }
            index1++;
            index2++;
        }
        return (x - index1) - (y - index2);
    }
}

```

### [3.Leetcode40 移掉K位数字](https://leetcode-cn.com/problems/remove-k-digits/)

给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。


示例 1 ：

输入：num = "1432219", k = 3
输出："1219"
解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。
示例 2 ：

输入：num = "10200", k = 1
输出："200"
解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。
示例 3 ：

输入：num = "10", k = 2
输出："0"
解释：从原数字移除所有的数字，剩余为空就是 0 。

```java
class Solution {
    public String removeKdigits(String num, int k) {
        Deque<Character> deque = new LinkedList<Character>();
        int length = num.length();
        for (int i = 0; i < length; ++i) {
            char digit = num.charAt(i);
            while (!deque.isEmpty() && k > 0 && deque.peekLast() > digit) {
                deque.pollLast();
                k--;
            }
            deque.offerLast(digit);
        }
        
        for (int i = 0; i < k; ++i) {
            deque.pollLast();
        }
        
        StringBuilder ret = new StringBuilder();
        boolean leadingZero = true;
        while (!deque.isEmpty()) {
            char digit = deque.pollFirst();
            if (leadingZero && digit == '0') {
                continue;
            }
            leadingZero = false;
            ret.append(digit);
        }
        return ret.length() == 0 ? "0" : ret.toString();
    }
}
```

### [4.Leetcode1081 不同字符的最小子序列](https://leetcode-cn.com/problems/smallest-subsequence-of-distinct-characters/)

返回 s 字典序最小的子序列，该子序列包含 s 的所有不同字符，且只包含一次。

注意：该题与 316 https://leetcode.com/problems/remove-duplicate-letters/ 相同

 

示例 1：

输入：s = "bcabc"
输出："abc"
示例 2：

输入：s = "cbacdcbc"
输出："acdb"

```java
class Solution {
    public String smallestSubsequence(String s) {
        boolean[] vis = new boolean[26];
        int[] num = new int[26];
        for (int i = 0; i < s.length(); i++) {
            num[s.charAt(i) - 'a']++;
        }

        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (!vis[ch - 'a']) {
                while (sb.length() > 0 && sb.charAt(sb.length() - 1) > ch) {
                    if (num[sb.charAt(sb.length() - 1) - 'a'] > 0) {
                        vis[sb.charAt(sb.length() - 1) - 'a'] = false;
                        sb.deleteCharAt(sb.length() - 1);
                    } else {
                        break;
                    }
                }
                vis[ch - 'a'] = true;
                sb.append(ch);
            }
            num[ch - 'a'] -= 1;
        }
        return sb.toString();
    }
}

```

### Leetcode698 划分成k个相等的子集


给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

**示例 1：**

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```



**动态规划**

```java
class Solution {

    public boolean canPartitionKSubsets(int[] nums, int k) {
        if (k == 1) {
            return true;
        }

        int len = nums.length;
        Arrays.sort(nums);
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % k != 0) {
            return false;
        }
        int target = sum / k;
        if (nums[len - 1] > target) {
            return false;
        }

        int size = 1 << len;
        boolean[] dp = new boolean[size];
        dp[0] = true;
        int[] currentSum = new int[size];
        for (int i = 0; i < size; i++) {
            // 总是基于 dp[i] = true 的前提下进行状态转移
            if (!dp[i]) {
                continue;
            }

            // 基于当前状态，添加一个数以后
            for (int j = 0; j < len; j++) {
                if ((i & (1 << j)) != 0) {
                    continue;
                }
                int next = i | (1 << j);
                if (dp[next]) {
                    continue;
                }
                if ((currentSum[i] % target) + nums[j] <= target) {
                    currentSum[next] = currentSum[i] + nums[j];
                    dp[next] = true;
                } else {
                    // 由于数组已经排好序，如果 (currentSum[i] % target) + nums[j] > target，剩下的数就没有必要枚举
                    break;
                }
            }
        }
        return dp[size - 1];
    }
}


```



**回溯+剪枝**

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum=0;
        boolean[] used=new boolean[nums.length];
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++)
        {
            sum+=nums[i];
        }
        if(sum%k!=0)
            return false;
        int target=sum/k;
        if(nums[nums.length-1]>target)
            return false;
        return dfs(nums,nums.length-1,target,0,k,used);
    }

    public static boolean dfs(int[] nums,int begin,int target,int curSum,int k,boolean[] used)
    {
        //剪枝1
        if(k==1)
            return true;
        if(curSum==target)
            return dfs(nums,nums.length-1,target,0,k-1,used);//找到了一个组合,还有k-1个.
        //剪枝4
        for(int i=begin;i>=0;i--)
        {
            //使用过的元素就不能再使用了
            if(used[i])
                continue;
            //剪枝2
            if(curSum+nums[i]>target)
                continue;
            used[i]=true;//添加元素nums[i]
            if(dfs(nums,i-1,target,curSum+nums[i],k,used))
                return true;//如果添加这个元素后，完成了题目要求，就return true.
            used[i]=false;//回溯
            while(i>0&&nums[i-1]==nums[i])//剪枝3
                i--;
        }
        return false;
    }
}

```

### Leetcode1574 删除最短的子数组使剩余数组有序

给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。

一个子数组指的是原数组中连续的一个子序列。

请你返回满足题目要求的最短子数组的长度。

 

示例 1：

输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
示例 2：

输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。

```java
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
        int n = arr.length;
        int left = 0;
        while (left + 1 < n && arr[left] <= arr[left+1]) {
            left++;
        }
        // [0...left]有序
        if (left == n - 1) {
            return 0;
        }
        // [right...n-1]有序
        int right = n - 1;
        while (right > 0 && arr[right - 1] <= arr[right]) {
            right--;
        }
        
        // 完全删除一边[left+1, n-1], 或者[0...right - 1]
        int result = Math.min(n - left - 1, right);

        // 左边和右边各保留一部分
        int i = 0, j = right;
        
        while (i <= left && j <= n - 1) {
            if (arr[i] <= arr[j]) {
                // [0...i] 和 [j...n-1] 有序, 删除 [i+1...j-1]
                result = Math.min(result, j - i - 1);
                i++;
            } else {
                // 小的+1
                j++;
            }
        }
        return result;
    }
}

```

## 数组合并

### [NC37 合并区间](https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=188&&tqId=38609&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给出一组区间，请合并所有重叠的区间。

请保证合并后的区间按区间起点升序排列。

**示例1**

输入：

```
[[10,30],[20,60],[80,100],[150,180]]
```

复制

返回值：

```
[[10,60],[80,100],[150,180]]
```

```java
/**
 * Definition for an interval.
 * public class Interval {
 *     int start;
 *     int end;
 *     Interval() { start = 0; end = 0; }
 *     Interval(int s, int e) { start = s; end = e; }
 * }
 */
import java.util.*;
public class Solution {
    public ArrayList<Interval> merge(ArrayList<Interval> intervals) {
        ArrayList<Interval> res = new ArrayList<>();
        //1.先排序
        Collections.sort(intervals,(a,b)->(a.start-b.start));
        //2.添加
        for(Interval interval:intervals){
            if(res.isEmpty() || res.get(res.size()-1).end<interval.start){
                res.add(interval);
            }else{
                res.get(res.size()-1).end = Math.max(res.get(res.size()-1).end,interval.end);
            }
        }
        return res;
    }
}
```

### Leetcode1000 合并石头的最低成本

有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。

每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。

找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。

 

示例 1：

输入：stones = [3,2,4,1], K = 2
输出：20
解释：
从 [3, 2, 4, 1] 开始。
合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。
合并 [4, 1]，成本为 5，剩下 [5, 5]。
合并 [5, 5]，成本为 10，剩下 [10]。
总成本 20，这是可能的最小值。

```java
class Solution {
    // 不用Integer.MAX_VALUE,因为Integer.MAX_VALUE + 正数 会溢出变为负数
    private int MAX_VALUE = 99999999; 
    public int mergeStones(int[] stones, int k) {
        int n = stones.length;
        if ((n - 1) % (k - 1) != 0) return -1;
        int[][][] dp = new int[n + 1][n + 1][k + 1];
        int[] sum = new int[n + 1];
        for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + stones[i - 1];
        for (int i = 1; i <= n; ++i) {
            for (int j = i; j <= n; ++j) {
                for (int m = 2; m <= k; ++m) dp[i][j][m] = MAX_VALUE;
            }
            dp[i][i][1] = 0;
        }
        for (int len = 2; len <= n; ++len) { // 枚举区间长度
            for (int i = 1; i + len - 1 <= n; ++i) { // 枚举区间起点
                int j = i + len - 1;
                for (int m = 2; m <= k; ++m) { // 枚举堆数
                    for (int p = i; p < j; p += k - 1) {  // 枚举分界点
                        dp[i][j][m] = Math.min(dp[i][j][m], dp[i][p][1] + dp[p + 1][j][m - 1]);
                    }
                }
                dp[i][j][1] = dp[i][j][k] + sum[j] - sum[i - 1];
            }
        }
        return dp[1][n][1];
    }
}

```





## 数组、串拆分 分割以及串联以及删除

### Leetcode698 划分成k个相等的子集


给定一个整数数组 `nums` 和一个正整数 `k`，找出是否有可能把这个数组分成 `k` 个非空子集，其总和都相等。

**示例 1：**

```
输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4
输出： True
说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。
```



**动态规划**

```java
class Solution {

    public boolean canPartitionKSubsets(int[] nums, int k) {
        if (k == 1) {
            return true;
        }

        int len = nums.length;
        Arrays.sort(nums);
        int sum = 0;
        for (int num : nums) {
            sum += num;
        }
        if (sum % k != 0) {
            return false;
        }
        int target = sum / k;
        if (nums[len - 1] > target) {
            return false;
        }

        int size = 1 << len;
        boolean[] dp = new boolean[size];
        dp[0] = true;
        int[] currentSum = new int[size];
        for (int i = 0; i < size; i++) {
            // 总是基于 dp[i] = true 的前提下进行状态转移
            if (!dp[i]) {
                continue;
            }

            // 基于当前状态，添加一个数以后
            for (int j = 0; j < len; j++) {
                if ((i & (1 << j)) != 0) {
                    continue;
                }
                int next = i | (1 << j);
                if (dp[next]) {
                    continue;
                }
                if ((currentSum[i] % target) + nums[j] <= target) {
                    currentSum[next] = currentSum[i] + nums[j];
                    dp[next] = true;
                } else {
                    // 由于数组已经排好序，如果 (currentSum[i] % target) + nums[j] > target，剩下的数就没有必要枚举
                    break;
                }
            }
        }
        return dp[size - 1];
    }
}


```



**回溯+剪枝**

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum=0;
        boolean[] used=new boolean[nums.length];
        Arrays.sort(nums);
        for(int i=0;i<nums.length;i++)
        {
            sum+=nums[i];
        }
        if(sum%k!=0)
            return false;
        int target=sum/k;
        if(nums[nums.length-1]>target)
            return false;
        return dfs(nums,nums.length-1,target,0,k,used);
    }

    public static boolean dfs(int[] nums,int begin,int target,int curSum,int k,boolean[] used)
    {
        //剪枝1
        if(k==1)
            return true;
        if(curSum==target)
            return dfs(nums,nums.length-1,target,0,k-1,used);//找到了一个组合,还有k-1个.
        //剪枝4
        for(int i=begin;i>=0;i--)
        {
            //使用过的元素就不能再使用了
            if(used[i])
                continue;
            //剪枝2
            if(curSum+nums[i]>target)
                continue;
            used[i]=true;//添加元素nums[i]
            if(dfs(nums,i-1,target,curSum+nums[i],k,used))
                return true;//如果添加这个元素后，完成了题目要求，就return true.
            used[i]=false;//回溯
            while(i>0&&nums[i-1]==nums[i])//剪枝3
                i--;
        }
        return false;
    }
}

```







### Leetcode1574 删除最短的子数组使剩余数组有序

给你一个整数数组 arr ，请你删除一个子数组（可以为空），使得 arr 中剩下的元素是 非递减 的。

一个子数组指的是原数组中连续的一个子序列。

请你返回满足题目要求的最短子数组的长度。

 

示例 1：

输入：arr = [1,2,3,10,4,2,3,5]
输出：3
解释：我们需要删除的最短子数组是 [10,4,2] ，长度为 3 。剩余元素形成非递减数组 [1,2,3,3,5] 。
另一个正确的解为删除子数组 [3,10,4] 。
示例 2：

输入：arr = [5,4,3,2,1]
输出：4
解释：由于数组是严格递减的，我们只能保留一个元素。所以我们需要删除长度为 4 的子数组，要么删除 [5,4,3,2]，要么删除 [4,3,2,1]。

```java
class Solution {
    public int findLengthOfShortestSubarray(int[] arr) {
        int n = arr.length;
        int left = 0;
        while (left + 1 < n && arr[left] <= arr[left+1]) {
            left++;
        }
        // [0...left]有序
        if (left == n - 1) {
            return 0;
        }
        // [right...n-1]有序
        int right = n - 1;
        while (right > 0 && arr[right - 1] <= arr[right]) {
            right--;
        }
        
        // 完全删除一边[left+1, n-1], 或者[0...right - 1]
        int result = Math.min(n - left - 1, right);

        // 左边和右边各保留一部分
        int i = 0, j = right;
        
        while (i <= left && j <= n - 1) {
            if (arr[i] <= arr[j]) {
                // [0...i] 和 [j...n-1] 有序, 删除 [i+1...j-1]
                result = Math.min(result, j - i - 1);
                i++;
            } else {
                // 小的+1
                j++;
            }
        }
        return result;
    }
}

```

### [Leetcode30串联所有单词的子串]

给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。

注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。

 

示例 1：

输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。
示例 2：

输入：s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"]
输出：[]

```java
class Solution {
    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<>();
        if (s == null || s.length() == 0 || words == null || words.length == 0) return res;
        HashMap<String, Integer> map = new HashMap<>();
        int one_word = words[0].length();
        int word_num = words.length;
        int all_len = one_word * word_num;
        for (String word : words) {
            map.put(word, map.getOrDefault(word, 0) + 1);
        }
        for (int i = 0; i < s.length() - all_len + 1; i++) {
            String tmp = s.substring(i, i + all_len);
            HashMap<String, Integer> tmp_map = new HashMap<>();
            for (int j = 0; j < all_len; j += one_word) {
                String w = tmp.substring(j, j + one_word);
                tmp_map.put(w, tmp_map.getOrDefault(w, 0) + 1);
            }
            if (map.equals(tmp_map)) res.add(i);
        }
        return res;
    }
}

```

### [Leetcode410 分割数组对的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)-(各自和的最大值最小)

给定一个非负整数数组 nums 和一个整数 m ，你需要将这个数组分成 m 个非空的连续子数组。

设计一个算法使得这 m 个子数组各自和的最大值最小。

 

示例 1：

输入：nums = [7,2,5,10,8], m = 2
输出：18
解释：
一共有四种方法将 nums 分割为 2 个子数组。 其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。
因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。
示例 2：

输入：nums = [1,2,3,4,5], m = 2
输出：9
示例 3：

输入：nums = [1,4,4], m = 3
输出：4

> 动态规划

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        int n = nums.length;
        int[][] f = new int[n + 1][m + 1];
        for (int i = 0; i <= n; i++) {
            Arrays.fill(f[i], Integer.MAX_VALUE);
        }
        int[] sub = new int[n + 1];
        for (int i = 0; i < n; i++) {
            sub[i + 1] = sub[i] + nums[i];
        }
        f[0][0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= Math.min(i, m); j++) {
                for (int k = 0; k < i; k++) {
                    f[i][j] = Math.min(f[i][j], Math.max(f[k][j - 1], sub[i] - sub[k]));
                }
            }
        }
        return f[n][m];
    }
}


```

### [Leetcode343 整数拆分](https://leetcode-cn.com/problems/integer-break/)

给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

**动态规划**

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n + 1];
        for (int i = 2; i <= n; i++) {
            int curMax = 0;
            for (int j = 1; j < i; j++) {
                curMax = Math.max(curMax, Math.max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = curMax;
        }
        return dp[n];
    }
}


```

### [Leetcode1024 视频拼接](https://leetcode-cn.com/problems/video-stitching/)

所重叠，也可能长度不一。

视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。

我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。

 

示例 1：

输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
输出：3
解释：
我们选中 [0,2], [8,10], [1,9] 这三个片段。
然后，按下面的方案重制比赛片段：
将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。
现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。

**动态规划**

```java
class Solution {
    public int videoStitching(int[][] clips, int time) {
        int[] dp = new int[time + 1];
        Arrays.fill(dp, Integer.MAX_VALUE - 1);
        dp[0] = 0;
        for (int i = 1; i <= time; i++) {
            for (int[] clip : clips) {
                if (clip[0] < i && i <= clip[1]) {
                    dp[i] = Math.min(dp[i], dp[clip[0]] + 1);
                }
            }
        }
        return dp[time] == Integer.MAX_VALUE - 1 ? -1 : dp[time];
    }
}

```

### [Leetcode131 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/)

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

 

示例 1：

输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
示例 2：

输入：s = "a"
输出：[["a"]]

**回溯+动态规划**

```java
class Solution {
    boolean[][] f;
    List<List<String>> ret = new ArrayList<List<String>>();
    List<String> ans = new ArrayList<String>();
    int n;

    public List<List<String>> partition(String s) {
        n = s.length();
        f = new boolean[n][n];
        for (int i = 0; i < n; ++i) {
            Arrays.fill(f[i], true);
        }

        for (int i = n - 1; i >= 0; --i) {
            for (int j = i + 1; j < n; ++j) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }

        dfs(s, 0);
        return ret;
    }

    public void dfs(String s, int i) {
        if (i == n) {
            ret.add(new ArrayList<String>(ans));
            return;
        }
        for (int j = i; j < n; ++j) {
            if (f[i][j]) {
                ans.add(s.substring(i, j + 1));
                dfs(s, j + 1);
                ans.remove(ans.size() - 1);
            }
        }
    }
}

```

### Leetcode97 交错字符串

给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的。

两个字符串 s 和 t 交错 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：

s = s1 + s2 + ... + sn
t = t1 + t2 + ... + tm
|n - m| <= 1
交错 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...
提示：a + b 意味着字符串 a 和 b 连接。

 ![img](https://assets.leetcode.com/uploads/2020/09/02/interleave.jpg)

示例 1：


输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
输出：true

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n = s1.length(), m = s2.length(), t = s3.length();

        if (n + m != t) {
            return false;
        }

        boolean[][] f = new boolean[n + 1][m + 1];

        f[0][0] = true;
        for (int i = 0; i <= n; ++i) {
            for (int j = 0; j <= m; ++j) {
                int p = i + j - 1;
                if (i > 0) {
                    f[i][j] = f[i][j] || (f[i - 1][j] && s1.charAt(i - 1) == s3.charAt(p));
                }
                if (j > 0) {
                    f[i][j] = f[i][j] || (f[i][j - 1] && s2.charAt(j - 1) == s3.charAt(p));
                }
            }
        }

        return f[n][m];
    }
}


```

### Leetcode413 等差数列划分

如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。

子数组 是数组中的一个连续序列。

 

示例 1：

输入：nums = [1,2,3,4]
输出：3
解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
示例 2：

输入：nums = [1]
输出：0

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        if (A == null || A.length <= 2)
            return 0;
        int res = 0;
        int add = 0;
        for (int i = 2; i < A.length; i++){
            if (A[i - 1] - A[i] == A[i - 2] - A[i - 1]){
                res += ++add;
            }else{
                add = 0;
            }
        }
        return res;
    }
}
```

### Leetcode1278 分割回文串III

给你一个由小写字母组成的字符串 s，和一个整数 k。

请你按下面的要求分割字符串：

首先，你可以将 s 中的部分字符修改为其他的小写英文字母。
接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。
请返回以这种方式分割字符串所需修改的最少字符数。

 

示例 1：

输入：s = "abc", k = 2
输出：1
解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。
示例 2：

输入：s = "aabbc", k = 3
输出：0
解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。

```java
class Solution {
    public int palindromePartition(String s, int K) {

        int len = s.length();
        // cache[i][j] 表示 s 中索引 i 到 j 构成回文串的最小步数
        int[][] cache = new int[len][len];
        // 填充
        for (int i = len-1; i > 0; i--) {
            for (int j = i-1; j < len-1; j++) {
                // 状态转移
                cache[i-1][j+1] = cache[i][j] + (s.charAt(i-1) == s.charAt(j+1) ? 0 : 1);
            }
        }
        // dp[i][k] 表示划分为 k 个时，s 中 0~i 构成回文串的所需最小步数
        int[][] dp = new int[len][K];
        // 初始化
        for (int i = 1; i < len; i++) {
            dp[i][0] = cache[0][i];
        }

        for (int i = 1; i < len; i++) {
            for (int k = 1; k < K; k++) {
                 // 初始化
                dp[i][k] = Integer.MAX_VALUE;
                for (int j = i; j >= k; j--) {
                    // 状态转移
                    dp[i][k] = Math.min(dp[i][k], dp[j-1][k-1] + cache[j][i]);
                }
            }
        }

        return dp[len-1][K-1];
    }
}
```



## 双数组 双子序列拆分、匹配

### [Leetcode139 单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：

输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

**动态规划**

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 单词拆分 最外层是j
        // 用hashset来存储
        int n = s.length();
        HashSet<String> dict = new HashSet<>(wordDict);
        // 动态规划
        boolean[] dp = new boolean[n+1];
        // 开始
        dp[0] = true;
        // 转移方程
        for(int j=1;j<=n;j++){
            for(int i=0;i<j;i++){
                if(dp[i]&&dict.contains(s.substring(i,j))){
                    dp[j] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

### [Leetcode140 单词拆分II](https://leetcode-cn.com/problems/word-break-ii/)

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：

输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。

```java
class Solution {
    // 单词拆分
    // 结果存储
    List<String> res = new ArrayList<>();
    public List<String> wordBreak(String s, List<String> wordDict) {
        // 每一次的临时结果
        List<String> path = new ArrayList<>();
        // 将其转换为数组
        char[] arr = s.toCharArray();
        //  dfs算法
        dfs(arr,0,wordDict,path);
        return res;
    }
    //  dfs回溯算法
    public void dfs(char[] arr,int index, List<String> wordDict,List<String> path){
        // 如果遍历到最后了
        if(index==arr.length){
            // 将结果添加进来
            StringBuilder temp = new StringBuilder();
            // 对其遍历
            for(String word:path){
                temp.append(word);
                temp.append(" ");
            }
            res.add(temp.toString().substring(0,temp.length()-1));
        }
        // 递归结束条件
        if(index>arr.length){
            return;
        }
        // 选择状态
        for(String word:wordDict){
            // 当前单词的长度
            int len = word.length();
            // 判断是否相等
            if(index+len<=arr.length&&new String(arr,index,len).equals(word)){
                // 符合条件相等
                path.add(word);
                dfs(arr,index+len,wordDict,path);
                path.remove(path.size()-1);

            }
        }


    }
}
```





### [Leetcode115 不同的子序列](https://leetcode-cn.com/problems/distinct-subsequences/)

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）

题目数据保证答案符合 32 位带符号整数范围。

 

示例 1：

输入：s = "rabbbit", t = "rabbit"
输出：3
解释：
如下图所示, 有 3 种可以从 s 中得到 "rabbit" 的方案。
rabbbit
rabbbit
rabbbit
示例 2：

输入：s = "babgbag", t = "bag"
输出：5
解释：
如下图所示, 有 5 种可以从 s 中得到 "bag" 的方案。 
babgbag
babgbag
babgbag
babgbag
babgbag

**动态规划**

```java
class Solution {
    public int numDistinct(String s, String t) {
        int m = s.length(), n = t.length();
        if (m < n) {
            return 0;
        }
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i <= m; i++) {
            dp[i][n] = 1;
        }
        for (int i = m - 1; i >= 0; i--) {
            char sChar = s.charAt(i);
            for (int j = n - 1; j >= 0; j--) {
                char tChar = t.charAt(j);
                if (sChar == tChar) {
                    dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];
                } else {
                    dp[i][j] = dp[i + 1][j];
                }
            }
        }
        return dp[0][0];
    }
}

```

### [Leetcode269 火星词典]

现有一种使用英语字母的火星语言，这门语言的字母顺序与英语顺序不同。

给你一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序 。

请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 "" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。

字符串 s 字典顺序小于 字符串 t 有两种情况：

在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。
如果前面 min(s.length, t.length) 字母都相同，那么 s.length < t.length 时，s 的字典顺序也小于 t 。


示例 1：

输入：words = ["wrt","wrf","er","ett","rftt"]
输出："wertf"
示例 2：

输入：words = ["z","x"]
输出："zx"

```java
class Solution {

    private static final int WHITE = 0;
    private static final int GRAY = 1;
    private static final int BLACK = 2;

    public String alienOrder(String[] words) {
        if(words.length < 1) {
            return "";
        }

        int vertexCount = 26;

        //顶点数值-字母映射
        Character[] vertecies = new Character[vertexCount];

        //初始化并构建邻接表
        List<HashSet<Integer>> adjacencyList = new ArrayList<>();
        for(int i = 0; i < vertexCount; i++) {
            adjacencyList.add(new HashSet<Integer>());
        }

        for(int n = 0; n < words.length; n++) {
            String word1 = words[n];
            String word2 = n+1 < words.length ? words[n+1] : null;

            //如果前一个单词完全以后一个单词开头且不是同一个单词，那么顺序是不合法的
            //如{"abc", "ab"}是不合法的，但是{"ab", "abc"}与{"abc" , "abc"}是合法的
            if(word2 != null && !word1.equals(word2) && word1.startsWith(word2)) {
                return "";
            }
            String word1Prefix = ""; //单词1前缀
            String word2Prefix = ""; //单词2前缀
            int i = 0;
            int word1Length = word1.length();
            int word2Length = word2 != null ? word2.length() : 0;
            while(i < Math.max(word1Length, word2Length)) {
                int vertex1 = -1;
                if(i < word1Length) {
                    char char1 = word1.charAt(i);
                    vertex1 = char1 - 'a';
                    if(vertecies[vertex1] == null) {
                        //新顶点
                        vertecies[vertex1] = char1;
                    }
                }

                int vertex2 = -1;
                if(i < word2Length) {
                    char char2 = word2.charAt(i);
                    vertex2 = char2 - 'a';
                    if(vertecies[vertex2] == null) {
                        //新顶点
                        vertecies[vertex2] = char2;
                    }
                }
                
                if(vertex1 >=0 && vertex2>=0 
                && vertex1 != vertex2 && word1Prefix.equals(word2Prefix)) {
                    adjacencyList.get(vertex1).add(vertex2);
                }
                i++;
                if(i < word1Length) {
                    word1Prefix = word1.substring(0, i);
                }
                if(i < word2Length) {
                    word2Prefix = word2.substring(0, i);
                }
                
            }
        }

        //拓扑排序
        Deque<Integer> stack = new LinkedList<>();
        int[] color = new int[vertexCount];
        for(int v = 0; v < vertexCount; v++) {
            if(color[v] == WHITE && dfsTopoSort(adjacencyList, color, v, stack)) {
                return "";
            }
        }
        StringBuilder sb = new StringBuilder();
        while(!stack.isEmpty()) {
            Character c = vertecies[stack.pop()];
            if(c != null){
                sb.append(c);
            }
        }
        return sb.toString();
    }


    private boolean dfsTopoSort(List<HashSet<Integer>> adjacencyList, int[] color, int v, Deque<Integer> stack) {
        color[v] = GRAY;
        for(int w : adjacencyList.get(v)) {
            if(color[w] == GRAY) {
                return true;
            }
            if(color[w] == WHITE && dfsTopoSort(adjacencyList, color, w, stack)) {
                return true;
            }
        }
        color[v] = BLACK;
        stack.push(v);
        return false;
    }
}


```

### Leetcode859 亲密字符串

给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。

交换字母的定义是取两个下标 i 和 j （下标从 0 开始），只要 i!=j 就交换 A[i] 和 A[j] 处的字符。例如，在 "abcd" 中交换下标 0 和下标 2 的元素可以生成 "cbad" 。

 

示例 1：

输入： A = "ab", B = "ba"
输出： true
解释： 你可以交换 A[0] = 'a' 和 A[1] = 'b' 生成 "ba"，此时 A 和 B 相等。
示例 2：

输入： A = "ab", B = "ab"
输出： false
解释： 你只能交换 A[0] = 'a' 和 A[1] = 'b' 生成 "ba"，此时 A 和 B 不相等。

```java
/**
字符串长度不相等, 直接返回false
字符串相等的时候, 只要有重复的元素就返回true
A, B字符串有不相等的两个地方, 需要查看它们交换后是否相等即可.
 */
class Solution {
    public boolean buddyStrings(String A, String B) {
        if (A.length() != B.length()) return false;
        if (A.equals(B)) {
            int[] count = new int[26];
            for (int i = 0; i < A.length(); ++i)
                count[A.charAt(i) - 'a']++;

            for (int c: count)
                if (c > 1) return true;
            return false;
        } else {
            int first = -1, second = -1;
            for (int i = 0; i < A.length(); ++i) {
                if (A.charAt(i) != B.charAt(i)) {
                    if (first == -1)
                        first = i;
                    else if (second == -1)
                        second = i;
                    else
                        return false;
                }
            }

            return (second != -1 && A.charAt(first) == B.charAt(second) &&
                    A.charAt(second) == B.charAt(first));
        }
    }
}

```

### Leetcode1397 找到所有好字符串

给你两个长度为 n 的字符串 s1 和 s2 ，以及一个字符串 evil 。请你返回 好字符串 的数目。

好字符串 的定义为：它的长度为 n ，字典序大于等于 s1 ，字典序小于等于 s2 ，且不包含 evil 为子字符串。

由于答案可能很大，请你返回答案对 10^9 + 7 取余的结果。

 

示例 1：

输入：n = 2, s1 = "aa", s2 = "da", evil = "b"
输出：51 
解释：总共有 25 个以 'a' 开头的好字符串："aa"，"ac"，"ad"，...，"az"。还有 25 个以 'c' 开头的好字符串："ca"，"cc"，"cd"，...，"cz"。最后，还有一个以 'd' 开头的好字符串："da"。

```java
class Solution {
    int[] fail;
    // 这是存储动态规划结果的数组
    // 维度从左到右分别为 pos, stats, bound
    int[][][] f;
    // int f[500][50][4];
    // 这是存储转移函数结果的数组
    // 两个维度分别为 stats 和 d
    int[][] trans;
    static final int MOD = 1000000007;
    String s1, s2, evil;

    public int findGoodStrings(int n, String s1, String s2, String evil) {
        this.s1 = s1;
        this.s2 = s2;
        this.evil = evil;

        int m = evil.length();
        fail = new int[m];
        // 这是 KMP 算法的一部分
        // 把「evil」看作模式串，得到它的 fail[] 数组
        for (int i = 1; i < m; ++i) {
            int j = fail[i - 1];
            while (j != 0 && evil.charAt(j) != evil.charAt(i)) {
                j = fail[j - 1];
            }
            if (evil.charAt(j) == evil.charAt(i)) {
                fail[i] = j + 1;
            }
        }
        // 将未搜索过的动态规划状态置为 -1
        f = new int[n][m][4];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                Arrays.fill(f[i][j], -1);
            }
        }
        // 将未计算过的转移函数置为 -1
        trans = new int[m][26];
        for (int i = 0; i < m; ++i) {
            Arrays.fill(trans[i], -1);
        }
        // 答案即为 f[0][0][3]
        return dfs(0, 0, 3);
    }

    // 这是用来进行记忆化搜索的函数
    // 输入为 pos, stats 和 bound
    // 输出为 f[pos][stats][bound]
    public int dfs(int pos, int stats, int bound) {
        // 如果匹配到了 evil 的末尾
        // 说明字符串不满足要求了
        // 返回 0
        if (stats == evil.length()) {
            return 0;
        }
        // 如果匹配到了上下界的末尾
        // 说明找到了一个满足要求的字符串
        // 返回 1
        if (pos == s1.length()) {
            return 1;
        }
        // 记忆化搜索的关键
        // 如果之前计算过该状态就直接返回结果
        if (f[pos][stats][bound] != -1) {
            return f[pos][stats][bound];
        }
        
        // 将当前状态初始化
        // 因为未初始化的状态值为 -1
        f[pos][stats][bound] = 0;
        // 计算第 pos 位可枚举的字符下界
        char l = ((bound & 1) != 0 ? s1.charAt(pos) : 'a');
        // 计算第 pos 位可枚举的字符上界
        char r = ((bound & 2) != 0 ? s2.charAt(pos) : 'z');
        for (char ch = l; ch <= r; ++ch) {
            int nxt_stats = getTrans(stats, ch);
            // 这里写得较为复杂
            // 本质上就是关于 bound 的转移函数
            // 可以根据自己的理解编写
            int nxt_bound = ((bound & 1) != 0 ? (ch == s1.charAt(pos) ? 1 : 0) : 0) ^ ((bound & 2) != 0 ? (ch == s2.charAt(pos) ? 1 : 0) << 1 : 0);
            f[pos][stats][bound] += dfs(pos + 1, nxt_stats, nxt_bound);
            f[pos][stats][bound] %= MOD;
        }
        return f[pos][stats][bound];
    }

    // 这是计算关于 stats 的转移函数
    // 输入为 stats 和 d
    // 输出为转移的结果 g_s(stats, d)
    public int getTrans(int stats, char ch) {
        // 如果之前计算过该转移函数就直接返回结果
        if (trans[stats][ch - 'a'] != -1) {
            return trans[stats][ch - 'a'];
        }
        // 这是 KMP 算法的一部分
        // 把 evil 看作「模式串」，stats 看作「主串」匹配到的位置
        while (stats != 0 && evil.charAt(stats) != ch) {
            stats = fail[stats - 1];
        }
        // 存储结果并返回
        return trans[stats][ch - 'a'] = (evil.charAt(stats) == ch ? stats + 1 : 0);
    }
}

```



## 字符串问题-统计，至多包含，最后一个单词长度

### Leetcode58 最后一个单词的长度

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

 

示例 1：

输入：s = "Hello World"
输出：5
示例 2：

输入：s = "   fly me   to   the moon  "
输出：4
示例 3：

输入：s = "luffy is still joyboy"
输出：6

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int length = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) != ' ') {
                length++;
            } else if (length != 0) {
                return length;
            }
        }
        return length;
    }
}
```



### Leetcode387 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

 

示例：

s = "leetcode"
返回 0

s = "loveleetcode"
返回 2

```
class Solution {

    public int firstUniqChar_1(String s) {
        Map<Character, Integer> map = new HashMap<>(26);
        char[] chars = s.toCharArray();
        for (char ch : chars) {
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        }
        for (int i = 0; i < chars.length; i++) {
            if (map.get(chars[i]) == 1) {
                return i;
            }
        }
        return -1;
    }

    public int firstUniqChar_2(String s) {
        int[] freq = new int[26];
        char[] chars = s.toCharArray();
        for (char ch : chars) {
            freq[ch - 'a']++;
        }
        for (int i = 0; i < chars.length; i++) {
            if (freq[chars[i] - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }

    public int firstUniqChar_3(String s) {
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
                if (s.indexOf(ch) == s.lastIndexOf(ch)) {
                    return i;
                }
            }
        return -1;
    }

    public int firstUniqChar_4(String s) {
        boolean[] notUniq = new boolean[26];
        for (int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if (!notUniq[ch -'a']) {
                if (s.indexOf(ch) == s.lastIndexOf(ch)) {
                    return i;
                } else {
                    notUniq[ch - 'a'] = true;
                }
            }
        }
        return -1;
    }

    public int firstUniqChar(String s) {
        int res = -1;
        for (char ch = 'a'; ch <= 'z'; ch++) {
            int index = s.indexOf(ch);
            if (index != -1 && index == s.lastIndexOf(ch)) {
                res = (res == -1 || res > index) ? index : res;
            }
        }
        return res;
    }
}
```



### [1.Leetcode1638 统计只差一个字符的子串数目](https://leetcode-cn.com/problems/count-substrings-that-differ-by-one-character/)

给你两个字符串 s 和 t ，请你找出 s 中的非空子串的数目，这些子串满足替换 一个不同字符 以后，是 t 串的子串。换言之，请你找到 s 和 t 串中 恰好 只有一个字符不同的子字符串对的数目。

比方说， "computer" 和 "computation" 加粗部分只有一个字符不同： 'e'/'a' ，所以这一对子字符串会给答案加 1 。

请你返回满足上述条件的不同子字符串对数目。

一个 子字符串 是一个字符串中连续的字符。

 

示例 1：

输入：s = "aba", t = "baba"
输出：6
解释：以下为只相差 1 个字符的 s 和 t 串的子字符串对：
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
("aba", "baba")
加粗部分分别表示 s 和 t 串选出来的子字符串。

```java
class Solution {
    public int countSubstrings(String s, String t) {
        char[] s_arr = s.toCharArray();
        char[] t_arr = t.toCharArray();
        int s_len = s_arr.length;
        int t_len = t_arr.length;
        // 结果
        int res = 0;
        for(int i=0;i<s_len;i++){
            for(int j=0;j<t_len;j++){
                int k = 0;
                int diff = 0;
                while(i+k<s_len&&j+k<t_len){
                    if(s_arr[i+k]!=t_arr[j+k]){
                        diff++;
                    }
                    if(diff>1){
                        break;
                    }
                    if(diff==1){
                        res+=1;
                    }
                    k++;
                }
            }
        }
        return res;
    }
}
```

### [2.Leetcode1297 子串的最大出现次数](https://leetcode-cn.com/problems/maximum-number-of-occurrences-of-a-substring/)

给你一个字符串 s ，请你返回满足以下条件且出现次数最大的 任意 子串的出现次数：

子串中不同字母的数目必须小于等于 maxLetters 。
子串的长度必须大于等于 minSize 且小于等于 maxSize 。


示例 1：

输入：s = "aababcaab", maxLetters = 2, minSize = 3, maxSize = 4
输出：2
解释：子串 "aab" 在原字符串中出现了 2 次。
它满足所有的要求：2 个不同的字母，长度为 3 （在 minSize 和 maxSize 范围内）。
示例 2：

输入：s = "aaaa", maxLetters = 1, minSize = 3, maxSize = 3
输出：2
解释：子串 "aaa" 在原字符串中出现了 2 次，且它们有重叠部分。

```java
class Solution {
 private boolean isMatch(String str, int maxLetters) {
        Set<Character> set = new HashSet<>();
        for (char c : str.toCharArray()) {
            set.add(c);
            if (set.size() > maxLetters) {
                return false;
            }
        }

        return set.size() <= maxLetters;
    }

    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {
        int len = s.length();
        Map<String, Integer> countMap = new HashMap<>();
        for (int i = 0; i < len; i++) {
            if (i + minSize > len) {
                break;
            }

            String sub = s.substring(i, i + minSize);
            if (isMatch(sub, maxLetters)) {
                countMap.put(sub, countMap.getOrDefault(sub, 0) + 1);
            }
        }

        int ansMax = 0;
        for (String str: countMap.keySet()) {
            int count = countMap.get(str);
            if (count > ansMax) {
                ansMax = count;
            }
        }

        return ansMax;
    }
}

```

### [2.Leetcode1513 仅含1的子串数](https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/)

给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。

返回所有字符都为 1 的子字符串的数目。

由于答案可能很大，请你将它对 10^9 + 7 取模后返回。

 

示例 1：

输入：s = "0110111"
输出：9
解释：共有 9 个子字符串仅由 '1' 组成
"1" -> 5 次
"11" -> 3 次
"111" -> 1 次
示例 2：

输入：s = "101"
输出：2
解释：子字符串 "1" 在 s 中共出现 2 次

```java
class Solution {
    public int numSub(String s) {
        int ones  = 0;
        int res = 0;
        int mod = (int)1e9+7;
        for(int i=0;i<s.length();i++){
            ones = s.charAt(i)=='1'?ones+1:0;
            res = (res+ones)%mod;
        }
        return res;
    }
}
```

### [3.Leetcode730 统计不同回文子序列](https://leetcode-cn.com/problems/count-different-palindromic-subsequences/)

给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。

通过从 S 中删除 0 个或多个字符来获得子序列。

如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。

如果对于某个  i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。

 

示例 1：

输入：
S = 'bccb'
输出：6
解释：
6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。
注意：'bcb' 虽然出现两次但仅计数一次。

```java
class Solution {
  public int countPalindromicSubsequences(String S) {
    int n = S.length();
    int mod = 1000000007;
    int[][][] dp = new int[4][n][n];

    for (int i = n-1; i >= 0; --i) {
      for (int j = i; j < n; ++j) {
        for (int k = 0; k < 4; ++k) {
          char c = (char) ('a' + k);
          if (j == i) {
            if (S.charAt(i) == c) dp[k][i][j] = 1;
            else dp[k][i][j] = 0;
          } else { // j > i
            if (S.charAt(i) != c) dp[k][i][j] = dp[k][i+1][j];
            else if (S.charAt(j) != c) dp[k][i][j] = dp[k][i][j-1];
            else { // S[i] == S[j] == c
              if (j == i+1) dp[k][i][j] = 2; // "aa" : {"a", "aa"}
              else { // length is > 2
                dp[k][i][j] = 2;
                for (int m = 0; m < 4; ++m) { // count each one within subwindows [i+1][j-1]
                  dp[k][i][j] += dp[m][i+1][j-1];
                  dp[k][i][j] %= mod;
                }
              }
            }
          }
        }
      }
    }

    int ans = 0;
    for (int k = 0; k < 4; ++k) {
      ans += dp[k][0][n-1];
      ans %= mod;
    }

    return ans;
  }
}


```

### Leetcode159 至多包含两个不同字符的最长子串

给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。

示例 1:

输入: "eceba"
输出: 3
解释: t 是 "ece"，长度为3。
示例 2:

输入: "ccaabbb"
输出: 5
解释: t 是 "aabbb"，长度为5。

```java
class Solution {
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int n = s.length();
        if(n < 3) return n;
        char[] arr = s.toCharArray();
        int[] window = new int[256];
        int l = 0, r = 0, count = 0, res = 0;
        while(r < n) {
            char c = arr[r];
            if(window[c] == 0) count++;
            window[c]++;
            if(count < 3) res = Math.max(res,r - l + 1);
            while(count == 3) {        
                c = arr[l];
                l++;
                if(window[c] == 1) count--;
                window[c]--;
            }
            r++;
        }
        return res;
    }
}
```

### [Leetcode395 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

 

示例 1：

输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：

输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int ret = 0;
        int n = s.length();
        for (int t = 1; t <= 26; t++) {
            int l = 0, r = 0;
            int[] cnt = new int[26];
            int tot = 0;
            int less = 0;
            while (r < n) {
                cnt[s.charAt(r) - 'a']++;
                if (cnt[s.charAt(r) - 'a'] == 1) {
                    tot++;
                    less++;
                }
                if (cnt[s.charAt(r) - 'a'] == k) {
                    less--;
                }

                while (tot > t) {
                    cnt[s.charAt(l) - 'a']--;
                    if (cnt[s.charAt(l) - 'a'] == k - 1) {
                        less++;
                    }
                    if (cnt[s.charAt(l) - 'a'] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                if (less == 0) {
                    ret = Math.max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
}


```



## 数组中子数组的乘积，求和

### [9.Leetcode053最大连续子数组和](https://leetcode-cn.com/problems/maximum-subarray/)-最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

 

示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
示例 2：

输入：nums = [1]
输出：1

> 解题思路：最大和的连续子数组

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = nums[0];
        for(int i=1;i<nums.length;i++){
            nums[i] = Math.max(nums[i],nums[i-1]+nums[i]);
            max = Math.max(max,nums[i]);
        }
        return max;
    }
}
```

### [10.Leetcode152 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

 

示例 1:

输入: [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
示例 2:

输入: [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。

> 可能存在正负的情况

```java
class Solution {
    public int maxProduct(int[] nums) {
        // 动态规划
        int n = nums.length;
        int[] maxNum = new int[n];
        int[] minNum = new int[n];
        // 结果
        int res = nums[0];
        // 初始化
        maxNum[0] = nums[0];
        minNum[0] = nums[0];
        // 转移方程
        for(int i=1;i<n;i++){
            maxNum[i] = Math.max(nums[i],Math.max(nums[i]*maxNum[i-1],nums[i]*minNum[i-1]));
            minNum[i] = Math.min(nums[i],Math.min(nums[i]*maxNum[i-1],nums[i]*minNum[i-1]));
            res = Math.max(res,maxNum[i]);
        }
        return res;
    }
}
```

## 子序列问题(LCS问题和递增子序列问题编辑距离回文)

### Leetcode525 连续数组(0和1)

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

 

示例 1:

输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
示例 2:

输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int res = 0, sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                nums[i] = -1;
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sum == 0 && i > res) {
                res = i + 1;
            }
            if (map.containsKey(sum)) {
                res = Math.max(i - map.get(sum), res);
            } else {
                map.put(sum, i);
            }
        }
        return res;
    }
}
```





### 剑指Offer57-II 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int temp_sum = 3;
        // 结果
        List<int[]> res = new ArrayList<>();
        while(l<r){
            //如果符合条件
            if(temp_sum==target){
                int[] temp = new int[r-l+1];
                for(int k=l;k<=r;k++){
                    temp[k-l] = k;
                }
                res.add(temp);
            }
            if(temp_sum>=target){
                temp_sum -= l;
                l++;
            }else{
                r++;
                temp_sum+=r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```



### Leetcode491 递增子序列

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

示例 1：

输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
示例 2：

输入：nums = [4,4,3,2,1]
输出：[[4,4]]

```java
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(0, Integer.MIN_VALUE, nums);
        return ans;
    }

    public void dfs(int cur, int last, int[] nums) {
        if (cur == nums.length) {
            if (temp.size() >= 2) {
                ans.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.add(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.remove(temp.size() - 1);
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }
}


```



### [1.Leetcode300 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        // 动态规划，以其结尾
        int n = nums.length;
        int[] dp = new int[n];
        // 初始化
        Arrays.fill(dp,1);
        // 转移方程
        // 
        int res = 1;
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                // 符合条件
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                    res = Math.max(res,dp[i]);
                }
            }
        }
        return res;
    }
}
```

### [2.Leetcode673 最长递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        int n = nums.length;
        //动态规划
        int[] dp = new int[n];
        int[] combinations = new int[n];
        // 初始化
        Arrays.fill(dp,1);
        Arrays.fill(combinations,1);
        // 转移方程
        int res = 1;
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                // 符合
                if(nums[i]>nums[j]){
                    // 开始
                    if(dp[j]+1>dp[i]){
                        dp[i] = dp[j] + 1;
                        combinations[i] = combinations[j];
                    }else if(dp[j]+1==dp[i]){
                        combinations[i] += combinations[j];
                    }
                }
                res = Math.max(res,dp[i]);
            }
        }

        // 统计
        int sum = 0;
        for(int i=0;i<n;i++){
            if(res==dp[i]){
                sum += combinations[i];
            }
        }
        return sum;
    }
}
```

### [NC153信封嵌套问题](https://www.nowcoder.com/practice/9bf77b5b018d4d24951c9a7edb40408f?tpId=117&&tqId=37863&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给 n*n* 个信封的长度和宽度。如果信封 A*A* 的长和宽都**小于**信封 B*B* ，那么信封 A*A* 可以放到信封 B*B* 里，请求出信封最多可以嵌套多少层。

数据范围：

1 \le n \le 2*10^51≤*n*≤2∗105

1 \le letters[i][0], letters[i][1] \le 10^91≤*l**e**t**t**e**r**s*[*i*][0],*l**e**t**t**e**r**s*[*i*][1]≤109

**示例1**

输入：

```
[[3,4],[2,3],[4,5],[1,3],[2,2],[3,6],[1,2],[3,2],[2,4]]
```

复制

返回值：

```
4
```

复制

说明：

```
从里到外分别是{1，2}，{2，3}，{3，4}，{4，5}。  
```

**示例2**

输入：

```
[[1,4],[4,1]]
```

复制

返回值：

```
1
```

```java
import java.util.*;
public class Solution {
    public int maxLetters (int[][] letters) {
        // 宽度从小到大排序，宽度相同时高度从大到小排序
        Arrays.sort(letters, new Comparator<int[]>(){
            public int compare(int[] arr1, int[] arr2) {
                if (arr1[0] == arr2[0]) return arr2[1] - arr1[1];
                else return arr1[0] - arr2[0];
            }
        });

        // h 数组存储高度，抹去了宽度
        int[] h = new int[letters.length];
        // 存储以 h[i] 结尾的 LIS 长度
        int[] dp = new int[letters.length];
        // 假设最坏的情况是没有递增，所以 LIS 长度最长为 1
        Arrays.fill(dp, 1);
        for (int i = 0; i < h.length; ++i) {
            h[i] = letters[i][1];
        }

        // 记录最长 LIS 长度
        int max = 1;
        for (int i = 1; i < dp.length; ++i) {
            for (int j = 0; j < i; ++j) {
                // 以 h[i] 结尾的递增子序列， h[j] 必然要比 h[i] 小，否则跳过
                if (h[j] >= h[i]) continue;
                int temp = dp[j] + 1;
                if (dp[i] < temp) dp[i] = temp;
            }
            max = dp[i] > max ? dp[i] : max;
        }
        return max;
    }
}
```





```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param letters int二维数组 
     * @return int
     */
    public int maxLetters(int[][] letters) {

        Arrays.sort(letters, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {

                if (o1[0] == o2[0]) {
                    return o1[1] - o2[1];
                } else {
                    return o1[0] - o2[0];
                }
            }
        });

        int w = letters[0][0];
        int h = letters[0][1];
        int cnt = 1;
        for (int i = 1; i < letters.length; i++) {
            if (letters[i][0] == w) {
                continue;
            }

            if (letters[i][1] > h) {
                w = letters[i][0];
                h = letters[i][1];
                cnt++;
            }
        }

        return cnt;
    }
}
```

### [3.Leetcode354  俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

给你一个二维整数数组 envelopes ，其中 envelopes[i] = [wi, hi] ，表示第 i 个信封的宽度和高度。

当另一个信封的宽度和高度都比这个信封大的时候，这个信封就可以放进另一个信封里，如同俄罗斯套娃一样。

请计算 最多能有多少个 信封能组成一组“俄罗斯套娃”信封（即可以把一个信封放到另一个信封里面）。

注意：不允许旋转信封。


示例 1：

输入：envelopes = [[5,4],[6,4],[6,7],[2,3]]
输出：3
解释：最多信封的个数为 3, 组合为: [2,3] => [5,4] => [6,7]。
示例 2：

输入：envelopes = [[1,1],[1,1],[1,1]]
输出：1

> 解题思路：递增子序列的问题

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        int n = envelopes.length;
        int[] dp = new int[n];
        // 排序
        Arrays.sort(envelopes,(a,b)->(a[0]-b[0]));
        // 初始化
        Arrays.fill(dp,1);
        // 结果
        int res = 1;
        // 转移方程
        for(int i=1;i<n;i++){
            for(int j=0;j<i;j++){
                if(envelopes[i][0]>envelopes[j][0]&&envelopes[i][1]>envelopes[j][1]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                    res  = Math.max(res,dp[i]);
                }
            }
        }   
        return res;
    }
}
```

### [4.Leetcode72 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

```java
class Solution {
    public int minDistance(String word1, String word2) {
        char[] arr1 = word1.toCharArray();
        char[] arr2 = word2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        //结果
        int[][] dp = new int[len1+1][len2+1];
        // 初始化
        for(int i=0;i<=len1;i++){
            dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j;
        }
        // 转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [5.Leetcode1143 最长公共子序列(LCS)](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] arr1 = text1.toCharArray();
        char[] arr2 = text2.toCharArray();
        // 长度
        int len1 = arr1.length;
        int len2 = arr2.length;
        // 动态
        int[][] dp = new int[len1+1][len2+1];
        // 初始化
        // 转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [6.Leetcode583 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

 

示例：

输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

> LCS的变形，找到相同的，总共减相同的即可

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int same = lcs(word1,word2);
        return len1+len2-same-same;
    }
    // LCS
    public int lcs(String word1,String word2){
        char[] arr1 = word1.toCharArray();
        char[] arr2 = word2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        // 动态规划
        int[][] dp = new int[len1+1][len2+1];
        // 初始化
        // 转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                // 转移方程
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [7.Leetcode712 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        // 计算最长公共前缀的asicii的话
        int sum_ascii = lcs(s1,s2);
        int sum_1 = 0;
        int sum_2 = 0;
        for(int i=0;i<s1.length();i++){
            sum_1 += (int)s1.charAt(i);
        }
        for(int j=0;j<s2.length();j++){
            sum_2 += (int)s2.charAt(j);
        }
        int res = sum_1+sum_2-sum_ascii-sum_ascii;
        return res;

    }

    // 最长公共子串前缀
    public int lcs(String s1,String s2){
        // dp里面存ascii
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m+1][n+1];
        // 转移方程
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                //判断
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j] = (int)s1.charAt(i-1)+dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

### [8.Leetcode005 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"

> 解题思路：中心扩散法

```java
class Solution {
    public String longestPalindrome(String s) {
        // 中心扩散法
        String res = "";
        for(int i=0;i<s.length();i++){
            String s1 = pali(s,i,i);
            String s2 = pali(s,i,i+1);
            String temp = s1.length()>s2.length()?s1:s2;
            // 再次判断
            res = res.length()>temp.length()?res:temp;
        }
        return res;
    }

    // 判断是否是回文
    public String pali(String s,int i,int j){
        while(i>=0&&j<s.length()&&s.charAt(i)==s.charAt(j)){
            i--;
            j++;
        }
        return s.substring(i+1,j);
    }
}
```

### [9.Leetcode516 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。

 

示例 1:
输入:

"bbbab"
输出:

4
一个可能的最长回文子序列为 "bbbb"。

示例 2:
输入:

"cbbd"
输出:

2
一个可能的最长回文子序列为 "bb"。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        // 动态规划
        int[][] dp = new int[n][n];
        //初始化
        for(int i=0;i<n;i++){
            dp[i][i] = 1;
        }
        // 转移方程 从底网上 从左往右
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```

### [10.Leetcode1312 让字符串成为回文串的最小插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。

「回文串」是正读和反读都相同的字符串。

 

示例 1：

输入：s = "zzazz"
输出：0

```java
class Solution {
    public int minInsertions(String s) {
        // 类似于查找最长回文序列
        char[] arr = s.toCharArray();
        // 动态规划
        int n = arr.length;
        int[][] dp = new int[n][n];
        // 正方形右上角
        // 初始化
        for(int i=0;i<n;i++){
            dp[i][i] = 0;
        }
        // 转移方程 从下往上 从左到右
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                // 相等无需处理
                if(arr[i]==arr[j]){
                    // 从当前往外走
                    dp[i][j] = dp[i+1][j-1];
                }else{
                    // 不相等 添加哪一个进来
                    dp[i][j] = Math.min(dp[i+1][j],dp[i][j-1]) + 1;
                }
            }
        }
        return dp[0][n-1];
    }
}
```





## 子串，子数组和子序列问题

### [Leetcode457 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)

存在一个不含 0 的 环形 数组 nums ，每个 nums[i] 都表示位于下标 i 的角色应该向前或向后移动的下标个数：

如果 nums[i] 是正数，向前（下标递增方向）移动 |nums[i]| 步
如果 nums[i] 是负数，向后（下标递减方向）移动 |nums[i]| 步
因为数组是 环形 的，所以可以假设从最后一个元素向前移动一步会到达第一个元素，而第一个元素向后移动一步会到达最后一个元素。

数组中的 循环 由长度为 k 的下标序列 seq 标识：

遵循上述移动规则将导致一组重复下标序列 seq[0] -> seq[1] -> ... -> seq[k - 1] -> seq[0] -> ...
所有 nums[seq[j]] 应当不是 全正 就是 全负
k > 1
如果 nums 中存在循环，返回 true ；否则，返回 false 。

 

示例 1：

输入：nums = [2,-1,1,2,2]
输出：true
解释：存在循环，按下标 0 -> 2 -> 3 -> 0 。循环长度为 3 。

```java
class Solution {
    public boolean circularArrayLoop(int[] nums) {
        int n = nums.length;
        for (int i = 0; i < n; i++) {
            if (nums[i] == 0) {
                continue;
            }
            int slow = i, fast = next(nums, i);
            // 判断非零且方向相同
            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(nums, fast)] > 0) {
                if (slow == fast) {
                    if (slow != next(nums, slow)) {
                        return true;
                    } else {
                        break;
                    }
                }
                slow = next(nums, slow);
                fast = next(nums, next(nums, fast));
            }
            int add = i;
            while (nums[add] * nums[next(nums, add)] > 0) {
                int tmp = add;
                add = next(nums, add);
                nums[tmp] = 0;
            }
        }
        return false;
    }

    public int next(int[] nums, int cur) {
        int n = nums.length;
        return ((cur + nums[cur]) % n + n) % n; // 保证返回值在 [0,n) 中
    }
}


```



### [Leetcode918 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。

在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length 时 C[i] = A[i]，且当 i >= 0 时 C[i+A.length] = C[i]）

此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）

 

示例 1：

输入：[1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
示例 2：

输入：[5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
示例 3：

输入：[3,-1,2,-1]
输出：4
解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4

> 使用maxSum计算正常子数组的最大和
> 使用minSum计算正常子数组的最小和, 然后使用totalSum减去中间的minSum得到两边环形子数组的最大和
> 返回Math.max(maxSum, totalSum - minSum)

```java
class Solution {
        public int maxSubarraySumCircular(int[] nums) {
        int totalSum = nums[0];
        int curMinSum = nums[0], minSum = nums[0];
        int curMaxSum = nums[0], maxSum = nums[0];
        for(int i = 1; i < nums.length; i++){
            totalSum += nums[i];
            curMinSum = curMinSum < 0 ? curMinSum + nums[i] : nums[i];
            curMaxSum = curMaxSum > 0 ? curMaxSum + nums[i] : nums[i];
            minSum = Math.min(minSum, curMinSum);
            maxSum = Math.max(maxSum, curMaxSum);
        }
        if(maxSum < 0){ // 全部都小于0, 直接返回最大的那个数
            return maxSum;
        }
        return Math.max(maxSum, totalSum - minSum);
    }

}
```



### Leetcode525 连续数组

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

 

示例 1:

输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
示例 2:

输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int res = 0, sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                nums[i] = -1;
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sum == 0 && i > res) {
                res = i + 1;
            }
            if (map.containsKey(sum)) {
                res = Math.max(i - map.get(sum), res);
            } else {
                map.put(sum, i);
            }
        }
        return res;
    }
}
```





### 剑指Offer57-II 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int temp_sum = 3;
        // 结果
        List<int[]> res = new ArrayList<>();
        while(l<r){
            //如果符合条件
            if(temp_sum==target){
                int[] temp = new int[r-l+1];
                for(int k=l;k<=r;k++){
                    temp[k-l] = k;
                }
                res.add(temp);
            }
            if(temp_sum>=target){
                temp_sum -= l;
                l++;
            }else{
                r++;
                temp_sum+=r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```



### Leetcode340 最多带有k个不同字符的最长子字符串

题目描述：

最多带有K个不同字符的最长子字符串，子字符串不能含有重复字符

输入：5 ，“leetcode” 输出：5—“tcode”

解题步骤：

采用窗口长度可变的滑动窗口法。先让一个指针指向最左边i=0，依次移动右边指针至i=s.length()。如果当前字符不包含在子字符串，则将该字符添加进子字符串。反之，如果子串包含该字符，左边指针依次向右移动，直至子串不包含该字符，再移动右边指针。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410113517956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5NDUwMjcxOTIz,size_16,color_FFFFFF,t_70)

```java
 public int KSubstring(String s, int k) {
  String sub = "";
  int maxLen = 0;
  for (int i = 0; i < s.length(); i++) {
   while(sub.contains(Character.toString(s.charAt(i)))) {
    sub = sub.substring(1);
   }
   sub += Character.toString(s.charAt(i));
   if(sub.length() <= k)
    maxLen = Math.max(maxLen, sub.length());
  }
  return maxLen;
 }
```



与改题目类似的还有另外一个

题目描述：

最多带有K个不同字符的最长子字符串，注意该题表示子字符串可以有重复字符，但是不同字符的种类必须小于k

解题步骤：

（1）还是采用滑动窗口的方法，如果子串中包含有当前字符，就直接添加到子串。
（2）如果字串中不包含当前字符，那么需要判断当前字符串字符种类是否大于等于k：

如果大于等于k则移动左边指针，使子串字符种类小于k后，再将当前字符添加进子串

```java
 public int lengthOfLongestSubstringKDistinct(String s, int k) {
  String str = "";
  String ret = "";
  if(s.length()<1 || k < 1)
   return 0;
  int count = 0;
  int maxLen = 0;
  for (int i = 0; i < s.length(); i++) {
   if(str.contains(Character.toString(s.charAt(i)))) {
    str += Character.toString(s.charAt(i));
   }
   else {
    while(count >= k) {
     String ch = Character.toString(str.charAt(0));
     str = str.substring(1);
     if(!str.contains(ch))
      count--;
    }
    str += Character.toString(s.charAt(i));
    count++;
   }
   if(maxLen < str.length()) {
    maxLen = str.length();
    ret = str;
   }
  }
  System.out.println(ret);
  return maxLen;
 }
```



### Leetcode796 旋转字符串

给定两个字符串, A 和 B。

A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

示例 1:
输入: A = 'abcde', B = 'cdeab'
输出: true

示例 2:
输入: A = 'abcde', B = 'abced'
输出: false

```java
class Solution {
    public boolean rotateString(String A, String B) {
                return A.length() == B.length() && (A + A).contains(B);

    }
}

```



### Leetcode205 同构字符串

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

 

示例 1:

输入：s = "egg", t = "add"
输出：true
示例 2：

输入：s = "foo", t = "bar"
输出：false
示例 3：

输入：s = "paper", t = "title"
输出：true

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        if(s.length() != t.length()){
            return false;
        }
        
        HashMap<Character, Character> map = new HashMap<>();
        for(int i=0; i<s.length(); i++){
            if(!map.containsKey(s.charAt(i))){
                if(map.containsValue(t.charAt(i))){
                    return false;
                }
                map.put(s.charAt(i), t.charAt(i));
            }else{
                if(map.get(s.charAt(i))!=t.charAt(i)){
                    return false;
                }
            }
        }
        
        return true;
    }
}
```



### [NC116 把数字翻译成字符串](https://www.nowcoder.com/practice/046a55e6cd274cffb88fc32dba695668?tpId=117&&tqId=37840&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)-数字翻译成字符串

**描述**

有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。

现在给一串数字，返回有多少种可能的译码结果

**示例1**

输入：

```
"12"
```

复制

返回值：

```
2
```

复制

说明：

```
2种可能的译码结果（”ab” 或”l”）
```

**示例2**

输入：

```
"31717126241541717"
```

复制

返回值：

```
192
```



```java
import java.util.*;


public class Solution {
    /**
     * 解码
     * @param nums string字符串 数字串
     * @return int整型
     */
    public int solve (String nums) {
        // write code here
        return dfs(nums.toCharArray(),0);
    }
    
    public int dfs(char[] nums,int start){
        //当start走到终点是
        if(start==nums.length){
            return 1;
        }
        //开始解码当字符为0的时候，0没对应的解码，所以直接返回0
        if(nums[start]=='0'){
            return 0;
        }
        //每次解码一次
        int res1 = dfs(nums,start+1);
        int res2 = 0;
        //如果当前字符等于1
        if( (start<nums.length-1)&&( nums[start]=='1' || (nums[start]=='2'&&nums[start+1]<='6')  )  ){
            res2 = dfs(nums,start+2);
        }
        return res1+res2;
        
        
    }
}
```

### [NC31 第一个只出现一次的字符](https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=117&&tqId=37762&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

在一个字符串(0<=字符串长度<=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）

**示例1**

输入：

```
"google"
```

复制

返回值：

```
4
```

```java
public class Solution {
    public int FirstNotRepeatingChar(String str) {
         if(str==null||str.length()==0){
             return -1;
         }   
         //用一个类似hash的数组来存储字符出现的次数
        int[] count = new int[128];
        for(int i=0;i<str.length();i++){
            count[str.charAt(i)]++;
        }
        for(int i=0;i<str.length();i++){
            if(count[str.charAt(i)]==1){
                return i;
            }
        }
        return -1;
    }
}
```

### [NC55 最长公共前缀](https://www.nowcoder.com/practice/28eb3175488f4434a4a6207f6f484f47?tpId=188&&tqId=38627&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给你一个长度为 n*n* 的字符串数组 strs*s**t**r**s* , 编写一个函数来查找字符串数组中的最长公共前缀，返回这个公共前缀。

数据范围：

0 \le n \le 10000≤*n*≤1000

0 \le len(strs[i]) \le 50000≤*l**e**n*(*s**t**r**s*[*i*])≤5000

**示例1**

输入：

```
["abca","abc","abca","abc","abcc"]
```

复制

返回值：

```
"abc"
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param strs string字符串一维数组 
     * @return string字符串
     */
    public String longestCommonPrefix (String[] strs) {
        // write code here
        if(strs.length<1){
            return "";
        }
        // 选出一个模板
        String template = strs[0];
        // 对其长度遍历
        for(int i=0;i<template.length();i++){
            char c = template.charAt(i);
            // 跟下面的进行对比
            for(int j=1;j<strs.length;j++){
                // 不相等就返回
                if(i==strs[j].length() || strs[j].charAt(i)!=c){
                    return template.substring(0,i);
                }
            }
        }
        return template;
    }
}
```

### [NC95 数组中的最长连续子序列](https://www.nowcoder.com/practice/eac1c953170243338f941959146ac4bf?tpId=188&&tqId=38566&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定无序数组arr，返回其中最长的连续序列的长度(要求值连续，位置可以不连续,例如 3,4,5,6为连续的自然数）

**示例1**

输入：

```
[100,4,200,1,3,2]
```

复制

返回值：

```
4
```

复制

**示例2**

输入：

```
[1,1,1]
```

复制

返回值：

```
1
```

```java
import java.util.*;


public class Solution {
    /**
     * max increasing subsequence
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int MLS (int[] nums) {
        // write code here
        // 不要求序列元素在原数组中连续 
        HashSet<Integer> hashset = new HashSet<>();
        for(int num:nums){
            hashset.add(num);
        }
        int res = 0;
        for(int num:hashset){
            //如果不存在前缀
            if(!hashset.contains(num-1)){
                //找后缀
                int curNum = num;
                int curLength = 1;
                while(hashset.contains(curNum+1)){
                    curNum += 1;
                    curLength += 1;
                }
                res = Math.max(res,curLength);
            }
        }
        return res;
    }
}
```

### [NC91 最长递增子序列](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=188&&tqId=38586&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）

**示例1**

输入：

```
[2,1,5,3,6,4,8,9,7]
```

复制

返回值：

```
[1,3,4,8,9]
```

复制

**示例2**

输入：

```
[1,2,8,6,4]
```

复制

返回值：

```
[1,2,4]
```

复制

说明：

```
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4） 
```

```java
import java.util.*;
public class Solution {
    public int[] LIS (int[] arr) {
        if(arr == null || arr.length <= 0){
            return null;
        }

        int len = arr.length;
        int[] count = new int[len];             // 存长度
        int[] end = new int[len];               // 存最长递增子序列

        //init
        int index = 0;                          // end 数组下标
        end[index] = arr[0];
        count[0] = 1;

        for(int i = 0; i < len; i++){
            if(end[index] < arr[i]){
                end[++index] = arr[i];
                count[i] = index;
            }
            else{
                int left = 0, right = index;
                while(left <= right){
                    int mid = (left + right) >> 1;
                    if(end[mid] >= arr[i]){
                        right = mid - 1;
                    }
                    else{
                        left = mid + 1;
                    }
                }
                end[left] = arr[i];
                count[i] = left;
            }
        }

        //因为返回的数组要求是字典序，所以从后向前遍历
        int[] res = new int[index + 1];
        for(int i = len - 1; i >= 0; i--){
            if(count[i] == index){
                res[index--] = arr[i];
            }
        }
        return res;
    }
}
```

### [Leetcode523连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)


给你一个整数数组 `nums` 和一个整数 `k` ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

- 子数组大小 **至少为 2** ，且
- 子数组元素总和为 `k` 的倍数。

如果存在，返回 `true` ；否则，返回 `false` 。

如果存在一个整数 `n` ，令整数 `x` 符合 `x = n * k` ，则称 `x` 是 `k` 的一个倍数。`0` 始终视为 `k` 的一个倍数。

 

**示例 1：**

```
输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
```

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int m = nums.length;
        if (m < 2) {
            return false;
        }
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        map.put(0, -1);
        int remainder = 0;
        for (int i = 0; i < m; i++) {
            remainder = (remainder + nums[i]) % k;
            if (map.containsKey(remainder)) {
                int prevIndex = map.get(remainder);
                if (i - prevIndex >= 2) {
                    return true;
                }
            } else {
                map.put(remainder, i);
            }
        }
        return false;
    }
}
```

### [Leetcode940 不同的子序列II](https://leetcode-cn.com/problems/distinct-subsequences-ii/)

给定一个字符串 S，计算 S 的不同非空子序列的个数。

因为结果可能很大，所以返回答案模 10^9 + 7.

 

示例 1：

输入："abc"
输出：7
解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。
示例 2：

输入："aba"
输出：6
解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。

```java
class Solution {
    public int distinctSubseqII(String s) {
        int mod = 1000000007;
        int n = s.length();
        //动态规划
        int[] dp = new int[n+1];
        //初始化
        dp[0] = 1;
        int[] last = new int[26];
        Arrays.fill(last,-1);
        //转移方程
        for(int i=0;i<n;i++){
            int x = s.charAt(i)-'a';
            dp[i+1] = dp[i]*2%mod;
            if(last[x]>=0){
                dp[i+1] -=dp[last[x]];
            }
            dp[i+1] %= mod;
            last[x] = i;
        }
        dp[n]--;
        if(dp[n]<0){
            dp[n] += mod;
        }
        return dp[n];
    }
}
```

### Leetcode005 最长回文子串

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"

```java
class Solution {
    public String longestPalindrome(String s) {
        // 中心扩散法
        String res = "";
        int len = s.length();
        for(int i=0;i<len;i++){
            String s1 = check(s,i,i);
            String s2 = check(s,i,i+1);
            // 判断
            res = s1.length()>res.length()?s1:res;
            res = s2.length()>res.length()?s2:res;
        }
        return res;
    }

    public String check(String s,int l,int r){
        while(l>=0&&r<s.length()&&s.charAt(l)==s.charAt(r)){
            l--;
            r++;
        }
        return s.substring(l+1,r);
    }
}
```



### [Leetcode214 最短回文串](https://leetcode-cn.com/problems/shortest-palindrome/)

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

 

示例 1：

输入：s = "aacecaaa"
输出："aaacecaaa"
示例 2：

输入：s = "abcd"
输出："dcbabcd"

**字符串哈希**

```java
class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
        int base = 131, mod = 1000000007;
        int left = 0, right = 0, mul = 1;
        int best = -1;
        for (int i = 0; i < n; ++i) {
            left = (int) (((long) left * base + s.charAt(i)) % mod);
            right = (int) ((right + (long) mul * s.charAt(i)) % mod);
            if (left == right) {
                best = i;
            }
            mul = (int) ((long) mul * base % mod);
        }
        String add = (best == n - 1 ? "" : s.substring(best + 1));
        StringBuffer ans = new StringBuffer(add).reverse();
        ans.append(s);
        return ans.toString();
    }
。
```



**KMP算法**

```java
class Solution {
    public String shortestPalindrome(String s) {
        int n = s.length();
        int[] fail = new int[n];
        Arrays.fill(fail, -1);
        for (int i = 1; i < n; ++i) {
            int j = fail[i - 1];
            while (j != -1 && s.charAt(j + 1) != s.charAt(i)) {
                j = fail[j];
            }
            if (s.charAt(j + 1) == s.charAt(i)) {
                fail[i] = j + 1;
            }
        }
        int best = -1;
        for (int i = n - 1; i >= 0; --i) {
            while (best != -1 && s.charAt(best + 1) != s.charAt(i)) {
                best = fail[best];
            }
            if (s.charAt(best + 1) == s.charAt(i)) {
                ++best;
            }
        }
        String add = (best == n - 1 ? "" : s.substring(best + 1));
        StringBuffer ans = new StringBuffer(add).reverse();
        ans.append(s);
        return ans.toString();
    }
}

```

### [Leetcode459 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

示例 1:

输入: "abab"

输出: True

解释: 可由子字符串 "ab" 重复两次构成。
示例 2:

输入: "aba"

输出: False

**枚举**

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        for (int i = 1; i * 2 <= n; ++i) {
            if (n % i == 0) {
                boolean match = true;
                for (int j = i; j < n; ++j) {
                    if (s.charAt(j) != s.charAt(j - i)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return true;
                }
            }
        }
        return false;
    }
}

```



**字符串匹配**

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != s.length();
    }
}

```

**KMP解法**

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return kmp(s + s, s);
    }

    public boolean kmp(String query, String pattern) {
        int n = query.length();
        int m = pattern.length();
        int[] fail = new int[m];
        Arrays.fill(fail, -1);
        for (int i = 1; i < m; ++i) {
            int j = fail[i - 1];
            while (j != -1 && pattern.charAt(j + 1) != pattern.charAt(i)) {
                j = fail[j];
            }
            if (pattern.charAt(j + 1) == pattern.charAt(i)) {
                fail[i] = j + 1;
            }
        }
        int match = -1;
        for (int i = 1; i < n - 1; ++i) {
            while (match != -1 && pattern.charAt(match + 1) != query.charAt(i)) {
                match = fail[match];
            }
            if (pattern.charAt(match + 1) == query.charAt(i)) {
                ++match;
                if (match == m - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}

```

### [Leetcode395 至少有K个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/)

给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串， 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度。

 

示例 1：

输入：s = "aaabb", k = 3
输出：3
解释：最长子串为 "aaa" ，其中 'a' 重复了 3 次。
示例 2：

输入：s = "ababbc", k = 2
输出：5
解释：最长子串为 "ababb" ，其中 'a' 重复了 2 次， 'b' 重复了 3 次。

```java
class Solution {
    public int longestSubstring(String s, int k) {
        int ret = 0;
        int n = s.length();
        for (int t = 1; t <= 26; t++) {
            int l = 0, r = 0;
            int[] cnt = new int[26];
            int tot = 0;
            int less = 0;
            while (r < n) {
                cnt[s.charAt(r) - 'a']++;
                if (cnt[s.charAt(r) - 'a'] == 1) {
                    tot++;
                    less++;
                }
                if (cnt[s.charAt(r) - 'a'] == k) {
                    less--;
                }

                while (tot > t) {
                    cnt[s.charAt(l) - 'a']--;
                    if (cnt[s.charAt(l) - 'a'] == k - 1) {
                        less++;
                    }
                    if (cnt[s.charAt(l) - 'a'] == 0) {
                        tot--;
                        less--;
                    }
                    l++;
                }
                if (less == 0) {
                    ret = Math.max(ret, r - l + 1);
                }
                r++;
            }
        }
        return ret;
    }
}


```

### Leetcode336 回文对

给定一组 互不相同 的单词， 找出所有 不同 的索引对 (i, j)，使得列表中的两个单词， words[i] + words[j] ，可拼接成回文串。

 

示例 1：

输入：words = ["abcd","dcba","lls","s","sssll"]
输出：[[0,1],[1,0],[3,2],[2,4]] 
解释：可拼接成的回文串为 ["dcbaabcd","abcddcba","slls","llssssll"]
示例 2：

输入：words = ["bat","tab","cat"]
输出：[[0,1],[1,0]] 
解释：可拼接成的回文串为 ["battab","tabbat"]
示例 3：

输入：words = ["a",""]
输出：[[0,1],[1,0]]

```java
class Solution {
    List<String> wordsRev = new ArrayList<String>();
    Map<String, Integer> indices = new HashMap<String, Integer>();

    public List<List<Integer>> palindromePairs(String[] words) {
        int n = words.length;
        for (String word: words) {
            wordsRev.add(new StringBuffer(word).reverse().toString());
        }
        for (int i = 0; i < n; ++i) {
            indices.put(wordsRev.get(i), i);
        }

        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < n; i++) {
            String word = words[i];
            int m = words[i].length();
            if (m == 0) {
                continue;
            }
            for (int j = 0; j <= m; j++) {
                if (isPalindrome(word, j, m - 1)) {
                    int leftId = findWord(word, 0, j - 1);
                    if (leftId != -1 && leftId != i) {
                        ret.add(Arrays.asList(i, leftId));
                    }
                }
                if (j != 0 && isPalindrome(word, 0, j - 1)) {
                    int rightId = findWord(word, j, m - 1);
                    if (rightId != -1 && rightId != i) {
                        ret.add(Arrays.asList(rightId, i));
                    }
                }
            }
        }
        return ret;
    }

    public boolean isPalindrome(String s, int left, int right) {
        int len = right - left + 1;
        for (int i = 0; i < len / 2; i++) {
            if (s.charAt(left + i) != s.charAt(right - i)) {
                return false;
            }
        }
        return true;
    }

    public int findWord(String s, int left, int right) {
        return indices.getOrDefault(s.substring(left, right + 1), -1);
    }
}

```



### --- 单个递增

### Leetcode159 至多包含两个不同字符的最长子串

给定一个字符串 s ，找出 至多 包含两个不同字符的最长子串 t ，并返回该子串的长度。

示例 1:

输入: "eceba"
输出: 3
解释: t 是 "ece"，长度为3。
示例 2:

输入: "ccaabbb"
输出: 5
解释: t 是 "aabbb"，长度为5。

```java
class Solution {
    public int lengthOfLongestSubstringTwoDistinct(String s) {
        int n = s.length();
        if(n < 3) return n;
        char[] arr = s.toCharArray();
        int[] window = new int[256];
        int l = 0, r = 0, count = 0, res = 0;
        while(r < n) {
            char c = arr[r];
            if(window[c] == 0) count++;
            window[c]++;
            if(count < 3) res = Math.max(res,r - l + 1);
            while(count == 3) {        
                c = arr[l];
                l++;
                if(window[c] == 1) count--;
                window[c]--;
            }
            r++;
        }
        return res;
    }
}
```

### Leetcode340 至多包含K个不同字符的最长子串

给定一个字符串 s ，找出 至多 包含 k 个不同字符的最长子串 T。

 

示例 1:

输入: s = "eceba", k = 2
输出: 3
解释: 则 T 为 "ece"，所以长度为 3。
示例 2:

输入: s = "aa", k = 1
输出: 2
解释: 则 T 为 "aa"，所以长度为 2。

```java
class Solution {
    public int lengthOfLongestSubstringKDistinct(String s, int k) {
        int max = 0;
        int left = 0;
        //用map记录每个字符最新出现的位置
        Map<Character, Integer> m = new HashMap<>();
        for(int i = 0; i < s.length(); ++i) {
            m.put(s.charAt(i), i);
            if (m.size() <= k && i - left + 1 > max) {
                max = i - left + 1;
            }
            //当不同字符的数量大于k的时候，就从开头开始去掉一个字符
            if (m.size() > k) {
                // 因为m中存储的是最新位置，如果不相等说明右边还有这个字符，即使删了字符种类也不会-1
                while (m.get(s.charAt(left)) != left) {
                    left++;
                }
                m.remove(s.charAt(left));
                left++;
            }
        }
        return max;
    }
}
```



### [NC155 牛牛的数列](https://www.nowcoder.com/practice/f2419f68541d499f920eac51c63d3f72?tpId=117&&tqId=37865&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

牛牛现在有一个 n*n* 个数组成的数列 nums*n**u**m**s* , 牛牛现在想取一个**连续的**子序列,并且这个子序列还必须得满足: 最多只把一个数改变成一个**正整数**, 就可以使得这个连续的子序列是一个**严格上升**的子序列, 牛牛想知道这个连续子序列最长的长度是多少。

数据范围：

1 \le n \le 10^51≤*n*≤105

1 \le nums[i] \le 10^51≤*n**u**m**s*[*i*]≤105

**示例1**

输入：

```
https://leetcode-cn.com/problems/continuous-subarray-sum/[7,2,3,1,5,6]https://leetcode-cn.com/problems/continuous-subarray-sum/
```

复制

返回值：

```
5
```

```java
import java.util.*;

public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int一维数组 
     * @return int
     * 动态规划
     * 状态定义：dp1[i]表示以i结尾的最长连续递增子序列的长度，dp2[i]表示以i开始的连续递增子序列的长度
     * 状态转移方程：
     * 对于dp1[i]：如果arr[i]>arr[i-1]则dp[i] = dp[i-1]+1
     * 对于dp2[i]：需要从后往前进行遍历，如果arr[i]<arr[i+1],则dp[i] = dp[i+1]+1
     * 状态初始化：dp1[0] = 1;dp2[arr.length-1]=1;
     */
    public int maxSubArrayLength (int[] nums) {
        // 处理特殊情况，即只有一个元素和两个元素的时候
        if(nums.length == 1 || nums.length == 2){
            return nums.length;
        }
        // write code here
        int[] dp1 = new int[nums.length];
        int[] dp2 = new int[nums.length];
        // 计算dp1，状态初始化
        dp1[0] = 1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]){
                dp1[i] = dp1[i-1]+1;
            }else{
                dp1[i] = 1;
            }
        }
        // 计算dp2,状态初始化
        dp2[nums.length-1] = 1;
        for(int i=nums.length-2;i>=0;i--){
            if(nums[i]<nums[i+1]){
                dp2[i] = dp2[i+1]+1;
            }else{
                dp2[i] = 1;
            }
        }
        // 寻找结果
        int max = 1;
        for(int i=0;i<nums.length;i++){
            // 可以使用的连接点，连接点即修改后可以得到更长连续递增子序列的元素
            if(i-1>=0 && i+1<nums.length && nums[i+1]-nums[i-1]>1){
                max = Math.max(max,dp2[i+1]+dp1[i-1]+1);
            // 如果不满足，找单边长度
            }else{
                if(i==0){
                    max = Math.max(max,nums[i+1]>1?dp2[i+1]+1:dp2[i+1]);
                }else if(i==nums.length-1){
                    max = Math.max(max,dp1[i-1]+1);
                }else{
                    max = Math.max(max,Math.max(dp1[i-1]+1,dp2[i+1]+1));
                }
            }
        }
        return max;
    }
}
```

### [1234类似-Leetcode128最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

 

示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 不要求序列元素在原数组中连续 
        HashSet<Integer> hashset = new HashSet<>();
        for(int num:nums){
            hashset.add(num);
        }
        int res = 0;
        for(int num:hashset){
            //如果不存在前缀
            if(!hashset.contains(num-1)){
                //找后缀
                int curNum = num;
                int curLength = 1;
                while(hashset.contains(curNum+1)){
                    curNum += 1;
                    curLength += 1;
                }
                res = Math.max(res,curLength);
            }
        }
        return res;
    }
}
```



### [子数组-Leetcode674 最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：

输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。

> 解题思路：滑动窗口

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int left = 0;
        int right = 1;
        int res = 1;
        int len = nums.length;
        while(right<len){
            //判断
            if(nums[right]<=nums[right-1]){
                left  = right;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [子序列-Leetcode300 最长递增子序列-长度](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

输入：nums = [0,1,0,3,2,3]
输出：4
示例 3：

输入：nums = [7,7,7,7,7,7,7]
输出：1

> 解题思路：动态规划

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        // 动态规划
        int[] dp = new int[len];
        // 初始化
        Arrays.fill(dp,1);
        // 结果
        int res = 1;
        // 转移方程
        for(int i=1;i<len;i++){
            for(int j=0;j<i;j++){
                //判断
                if(nums[i]>nums[j]){
                    dp[i] = Math.max(dp[i],dp[j]+1);
                    res = Math.max(res,dp[i]);
                }
            }
        }
        return res;
    }
}
```

### [子序列-Leetcode673最递增子序列的个数](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

给定一个未排序的整数数组，找到最长递增子序列的个数。

示例 1:

输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
示例 2:

输入: [2,2,2,2,2]
输出: 5
解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。
注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。

```java
class Solution {
    public int findNumberOfLIS(int[] nums) {
        // 最长递增子序列的问题
        int len = nums.length;
        int[] dp = new int[len];
        int[] comb = new int[len];
        // 初始化
        Arrays.fill(dp,1);
        Arrays.fill(comb,1);
        // 转移方程
        int long_path = 1;
        for(int i=1;i<len;i++){
            for(int j=0;j<i;j++){
                //判断
                if(nums[i]>nums[j]){
                    if(dp[j]+1>dp[i]){
                        dp[i] = dp[j]+1;
                        comb[i] = comb[j];
                    }else if(dp[j]+1==dp[i]){
                        comb[i] += comb[j];
                    }
                }
                long_path = Math.max(long_path,dp[i]);
            }
        }
        // 遍历
        int res = 0;
        for(int i=0;i<len;i++){
            if(dp[i]==long_path){
                res += comb[i];
            }
        } 
        return res;  
    }
}
```

### [NC153信封嵌套问题](https://www.nowcoder.com/practice/9bf77b5b018d4d24951c9a7edb40408f?tpId=117&&tqId=37863&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给 n*n* 个信封的长度和宽度。如果信封 A*A* 的长和宽都**小于**信封 B*B* ，那么信封 A*A* 可以放到信封 B*B* 里，请求出信封最多可以嵌套多少层。

数据范围：

1 \le n \le 2*10^51≤*n*≤2∗105

1 \le letters[i][0], letters[i][1] \le 10^91≤*l**e**t**t**e**r**s*[*i*][0],*l**e**t**t**e**r**s*[*i*][1]≤109

**示例1**

输入：

```
[[3,4],[2,3],[4,5],[1,3],[2,2],[3,6],[1,2],[3,2],[2,4]]
```

复制

返回值：

```
4
```

复制

说明：

```
从里到外分别是{1，2}，{2，3}，{3，4}，{4，5}。  
```

**示例2**

输入：

```
[[1,4],[4,1]]
```

复制

返回值：

```
1
```

```java
import java.util.*;
public class Solution {
    public int maxLetters (int[][] letters) {
        // 宽度从小到大排序，宽度相同时高度从大到小排序
        Arrays.sort(letters, new Comparator<int[]>(){
            public int compare(int[] arr1, int[] arr2) {
                if (arr1[0] == arr2[0]) return arr2[1] - arr1[1];
                else return arr1[0] - arr2[0];
            }
        });

        // h 数组存储高度，抹去了宽度
        int[] h = new int[letters.length];
        // 存储以 h[i] 结尾的 LIS 长度
        int[] dp = new int[letters.length];
        // 假设最坏的情况是没有递增，所以 LIS 长度最长为 1
        Arrays.fill(dp, 1);
        for (int i = 0; i < h.length; ++i) {
            h[i] = letters[i][1];
        }

        // 记录最长 LIS 长度
        int max = 1;
        for (int i = 1; i < dp.length; ++i) {
            for (int j = 0; j < i; ++j) {
                // 以 h[i] 结尾的递增子序列， h[j] 必然要比 h[i] 小，否则跳过
                if (h[j] >= h[i]) continue;
                int temp = dp[j] + 1;
                if (dp[i] < temp) dp[i] = temp;
            }
            max = dp[i] > max ? dp[i] : max;
        }
        return max;
    }
}
```



**二分查找的方法**

Java自带的二分查找到的API

```java
//先按照长递增排序，然后长度相同的按照宽递减排序，最后按照宽去找到最长递增子序列。
import java.io.*;
import java.util.*;
public class Main{
   	 public static void main(String []args)throws IOException{
	        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
	        int n = Integer.parseInt(bf.readLine().trim());
	        int[][] arr = new int[n][2];
	        for(int i = 0; i< n; i++){
	            String[] str = bf.readLine().trim().split(" ");
	            arr[i][0] = Integer.parseInt(str[0]);
	            arr[i][1] = Integer.parseInt(str[1]);
	        }
	        bf.close();
	        Arrays.sort(arr, (o1, o2) -> (o1[0]-o2[0] != 0 ? o1[0]-o2[0] : o2[1] - o1[1]));
	        //二分查找法计算LIS长度，该方法在前面一题LIS的讨论区有详细介绍
	        int[]minTail = new int[n];
	        int len = 0;
	        for(int i = 0;i<n;i++){
	            int index = Arrays.binarySearch(minTail, 0, len, arr[i][1]);
	            if(index < 0){
	                index = -index -1;
	            }
	            
	            minTail[index] = arr[i][1];
	            
	            if(index == len)
	                len++;
	        }
	        System.out.println(len);
	    }
}
```



**二分查找的**

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param letters int二维数组 
     * @return int
     */
    public int maxLetters (int[][] letters) {
        // write code here
        Arrays.sort(letters, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if(o1[0]!=o2[0]){
                    return o1[0]-o2[0];
                }else{
                    return o2[1]-o1[1];
                }
            }
        });
        List<Integer> hs = new ArrayList<>();
        for(int i=0;i<letters.length;i++){
            int tmp = letters[i][1];
            if(hs.isEmpty()||hs.get(hs.size()-1)<tmp){
                hs.add(tmp);
            }else{
                int l = 0;
                int r = hs.size()-1;
                while(l<=r){
                    int mid = (l+r)/2;
                    if(hs.get(mid)<tmp){
                        l = mid+1;
                    }else{
                        if(mid==0||hs.get(mid-1)<tmp){
                            hs.set(mid,tmp);
                            break;
                        }else{
                            r = mid-1;
                        }
                    }
                }
            }
        }
        return hs.size();
    }
}
```



**动归规划**

```java
import java.util.*;

public class Solution {
    public int maxLetters (int[][] letters) {
        // write code here
        if(letters.length == 0) return 0;
        Arrays.sort(letters, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                if(a[0] == b[0]) return a[1] - b[1];
                else return a[0] - b[0];
            }
        });
        int n = letters.length;
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){
                if(letters[i][1] > letters[j][1])
                    dp[i] = Math.max(dp[i], dp[j]);
            }
            dp[i]++;
        }
        return dp[n - 1];
    }
}
```





```java
import java.util.*;

public class Solution {
    public int maxLetters (int[][] letters) {
        // write code here
        if(letters.length == 0) return 0;
        Arrays.sort(letters, new Comparator<int[]>(){
            public int compare(int[] a, int[] b){
                if(a[0] == b[0]) return a[1] - b[1];
                else return a[0] - b[0];
            }
        });
        int n = letters.length;
        int[] dp = new int[n];
        dp[0] = 1;
        for(int i = 1; i < n; i++){
            for(int j = 0; j < i; j++){
                if(letters[i][1] > letters[j][1])
                    dp[i] = Math.max(dp[i], dp[j]);
            }
            dp[i]++;
        }
        return dp[n - 1];
    }
}
```



```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param letters int二维数组 
     * @return int
     */
    public int maxLetters(int[][] letters) {

        Arrays.sort(letters, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {

                if (o1[0] == o2[0]) {
                    return o1[1] - o2[1];
                } else {
                    return o1[0] - o2[0];
                }
            }
        });

        int w = letters[0][0];
        int h = letters[0][1];
        int cnt = 1;
        for (int i = 1; i < letters.length; i++) {
            if (letters[i][0] == w) {
                continue;
            }

            if (letters[i][1] > h) {
                w = letters[i][0];
                h = letters[i][1];
                cnt++;
            }
        }

        return cnt;
    }
}
```



### [子序列-NC91 最长递增子序列的结果](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=188&&tqId=38586&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定数组arr，设长度为n，输出arr的最长递增子序列。（如果有多个答案，请输出其中 按数值(注：区别于按单个字符的ASCII码值)进行比较的 字典序最小的那个）

**示例1**

输入：

```
[2,1,5,3,6,4,8,9,7]
```

返回值：

```
[1,3,4,8,9]
```

**示例2**

输入：

```
[1,2,8,6,4]
```

返回值：

```
[1,2,4]
```

复制

说明：

```
其最长递增子序列有3个，（1，2，8）、（1，2，6）、（1，2，4）其中第三个 按数值进行比较的字典序 最小，故答案为（1，2，4）   
```

```java
import java.util.*;
public class Solution {
    public int[] LIS (int[] arr) {
        if(arr == null || arr.length <= 0){
            return null;
        }

        int len = arr.length;
        int[] count = new int[len];             // 存长度
        int[] end = new int[len];               // 存最长递增子序列

        //init
        int index = 0;                          // end 数组下标
        end[index] = arr[0];
        count[0] = 1;

        for(int i = 0; i < len; i++){
            if(end[index] < arr[i]){
                end[++index] = arr[i];
                count[i] = index;
            }
            else{
                int left = 0, right = index;
                while(left <= right){
                    int mid = (left + right) >> 1;
                    if(end[mid] >= arr[i]){
                        right = mid - 1;
                    }
                    else{
                        left = mid + 1;
                    }
                }
                end[left] = arr[i];
                count[i] = left;
            }
        }

        //因为返回的数组要求是字典序，所以从后向前遍历
        int[] res = new int[index + 1];
        for(int i = len - 1; i >= 0; i--){
            if(count[i] == index){
                res[index--] = arr[i];
            }
        }
        return res;
    }
}
```

### [Leetcode128 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

 

示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
示例 2：

输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        // 不要求序列元素在原数组中连续 
        HashSet<Integer> hashset = new HashSet<>();
        for(int num:nums){
            hashset.add(num);
        }
        int res = 0;
        for(int num:hashset){
            //如果不存在前缀
            if(!hashset.contains(num-1)){
                //找后缀
                int curNum = num;
                int curLength = 1;
                while(hashset.contains(curNum+1)){
                    curNum += 1;
                    curLength += 1;
                }
                res = Math.max(res,curLength);
            }
        }
        return res;
    }
}
```



### ----单个重复

### [子串-Leetcode003无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
示例 3:

输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        char[] arr = s.toCharArray();
        int len = arr.length;
        // hashmap辅助
        HashMap<Character,Integer> dict = new HashMap<>();
        // 结果
        int res = 0;
        // 滑动窗口
        int left = 0;
        int right = 0;
        while(right<len){
            //判断是否包含
            if(dict.containsKey(arr[right])){
                left = Math.max(dict.get(arr[right])+1,left);
            }
            dict.put(arr[right],right);
            // 结果更新
            res = Math.max(res,right-left+1);
            // 继续
            right++;
        }
        return res;
    }
}
```

### [Leetcode1156 单字符重复子串的最大长度](https://leetcode-cn.com/problems/swap-for-longest-repeated-character-substring/)

如果字符串中的所有字符都相同，那么这个字符串是单字符重复的字符串。

给你一个字符串 text，你只能交换其中两个字符一次或者什么都不做，然后得到一些单字符重复的子串。返回其中最长的子串的长度。

 

示例 1：

输入：text = "ababa"
输出：3
示例 2：

输入：text = "aaabaaa"
输出：6
示例 3：

输入：text = "aaabbaaa"
输出：4
示例 4：

输入：text = "aaaaa"
输出：5

```java
class Solution {
    public int maxRepOpt1(String text) {
        char[] word = text.toCharArray();
        // 统计窗口内的各个字符出现的次数
        int[] winCount = new int[26];
        // 统计text内的各个字符出现的次数
        int[] charCount = new int[26];
        for(char c:word){
            charCount[c-'a']++;
        }
        // 判断
        int maxChar = 0;
        int start = 0, maxWin = 0, maxCount = 0;
        for(int i=0;i<word.length;i++){
            int c = word[i]-'a';
            winCount[c]++;
            // 判断是否扩大当前窗口
            if(winCount[c]>maxCount){
                maxChar = c;
                maxCount = winCount[c];
                maxWin = maxCount+1;
            }else if(i-start+1>maxWin){
                winCount[word[start]-'a']--;
                start++;
            }
        }
        return Math.min(maxWin,charCount[maxChar]);
    }
}
```

### [NC142 最长重复子串](https://www.nowcoder.com/practice/4fe306a84f084c249e4afad5edf889cc?tpId=117&&tqId=37853&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

定义**重复字符串**是由两个相同的字符串首尾拼接而成，例如 ![img](https://www.nowcoder.com/equation?tex=abcabc%5C) 便是长度为6的一个重复字符串，而 ![img](https://www.nowcoder.com/equation?tex=abcba%5C) 则不存在重复字符串。

给定一个字符串，请返回其最长重复子串的长度。

若不存在任何重复字符子串，则返回 0 。

**示例1**

输入：

```
"ababc"
```

复制

返回值：

```
4
```

复制

说明：

```
abab为最长的重复字符子串，长度为4  
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 
     * @param a string字符串 待计算字符串
     * @return int整型
     */
    public int solve (String a) {
        // write code here
        //判断
        if(a==null||a.length()<=1){
            return 1;
        }
        //转成数组
        char[] arr = a.toCharArray();
        int len = arr.length;
        int maxLen = len/2;
        //开始判断
        for(int i=maxLen;i>0;i--){
            for(int j=0;j<=len-2*i;j++){
                if(check(arr,j,i)){
                    return 2*i;
                }
            }
        }
        return 0;
    }
    public boolean check(char[] arr,int start,int len){
        for(int i=start;i<start+len;i++){
            if(arr[i]!=arr[i+len]){
                return false;
            }
        }
        return true;
        
    }
}
```

### 

### - - -单个连续和

### [子数组-Leetcode209长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        // 连续子数组
        int left = 0;
        int right = 0;
        int temp_sum = 0;
        int len = nums.length;
        // 结果
        int maxlen = len+1;
        while(right<len){
            temp_sum+=nums[right];
            //判断
            while(temp_sum>=target){
                maxlen = Math.min(maxlen,right-left+1);
                temp_sum -= nums[left];
                left++;
            }
            right++;
        }
        return maxlen==len+1?0:maxlen;
    }
}
```

### 剑指Offer57-II 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int temp_sum = 3;
        // 结果
        List<int[]> res = new ArrayList<>();
        while(l<r){
            //如果符合条件
            if(temp_sum==target){
                int[] temp = new int[r-l+1];
                for(int k=l;k<=r;k++){
                    temp[k-l] = k;
                }
                res.add(temp);
            }
            if(temp_sum>=target){
                temp_sum -= l;
                l++;
            }else{
                r++;
                temp_sum+=r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```

### [NC19 子数组的最大累加和问题](https://www.nowcoder.com/practice/554aa508dd5d4fefbf0f86e5fe953abd?tpId=188&&tqId=38594&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个数组arr，返回子数组的最大累加和

例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.

题目保证没有全为负数的数据

[要求]

时间复杂度为O(n)*O*(*n*)，空间复杂度为O(1)*O*(1)

**示例1**

输入：

```
[1, -2, 3, 5, -2, 6, -1]
```

复制

返回值：

```
12
```

```java
import java.util.*;


public class Solution {
    /**
     * max sum of the subarray
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxsumofSubarray (int[] arr) {
        // write code here
        int maxSum = arr[0];
        for(int i=1;i<arr.length;i++){
            arr[i] = Math.max(arr[i],arr[i-1]+arr[i]);
            maxSum = Math.max(maxSum,arr[i]);
        }
        return maxSum;
    }
}
```

### [NC83 子数组的最大乘积](https://www.nowcoder.com/practice/9c158345c867466293fc413cff570356?tpId=117&&tqId=37785&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个double类型的数组arr，其中的元素可正可负可0，返回子数组累乘的最大乘积。

**示例1**

输入：

```
[-2.5,4,0,3,0.5,8,-1]
```

复制

返回值：

```
12.00000
```

```java
public class Solution {
    public double maxProduct(double[] nums) {
        int len = nums.length;
        // 两个数组
        double[] maxArr = new double[len];
        double[] minArr = new double[len];
        // 初始化
        maxArr[0] = nums[0];
        minArr[0] = nums[0];
        // 对其遍历
        // 结果存储
        double res = nums[0];
        for(int i=1;i<nums.length;i++){
            // 转移方程
            maxArr[i] = Math.max(nums[i],Math.max(nums[i]*maxArr[i-1],nums[i]*minArr[i-1]));
            minArr[i] = Math.min(nums[i],Math.min(nums[i]*maxArr[i-1],nums[i]*minArr[i-1]));
            res = Math.max(res,maxArr[i]);
        }
        return res;
    }
}
```

### [NC125 未排序数组中累加和为给定值的最长子数组长度](https://www.nowcoder.com/practice/704c8388a82e42e58b7f5751ec943a11?tpId=117&&tqId=37794&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个无序数组arr, 其中元素可正、可负、可0。给定一个整数k，求arr所有连续子数组中累加和为k的最长子数组长度。

保证至少存在一个合法的子数组。

**示例1**

输入：

```
[1,-2,1,1,1],0
```

复制

返回值：

```
3
```

```java
import java.util.*;


public class Solution {
    /**
     * max length of the subarray sum = k
     * @param arr int整型一维数组 the array
     * @param k int整型 target
     * @return int整型
     */
    public int maxlenEqualK (int[] arr, int k) {
        // write code here
        if(arr==null||arr.length==0){
            return 0;
        }
        Map<Integer,Integer> map = new HashMap<>();
        map.put(0,-1);
        int len = 0;
        int sum = 0;
        for(int i=0;i<arr.length;i++){
            sum += arr[i];
            if(map.containsKey(sum-k)){
                len = Math.max(len,i-map.get(sum-k));
            }
            if(!map.containsKey(sum)){
                map.put(sum,i);
            }
        }
        return len;
        
    }
}
```

### 

### - - - 双数组的重复

### [Leetcode718 最长重复子数组](https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/)

给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

 

示例：

输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。

> 动态规划

```java
class Solution {
    public int findLength(int[] nums1, int[] nums2) {
        int n = nums1.length;
        int m = nums2.length;
        int[][] dp = new int[n+1][m+1];//以n和m为结尾的字符串
        // 结果存储
        int maxlen = 0;
        // 初始化继续
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                //判断
                if(nums1[i-1]==nums2[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = 0;
                }
                // 更新
                maxlen = Math.max(dp[i][j],maxlen);
            }
        }
        return maxlen;
    }
}
```



### [NC127 最长公共子串](https://www.nowcoder.com/practice/f33f5adc55f444baa0e0ca87ad8a6aac?tpId=117&&tqId=37799&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定两个字符串str1和str2,输出两个字符串的最长公共子串

题目保证str1和str2的最长公共子串存在且唯一。

**示例1**

输入：

```
"1AB2345CD","12345EF"
```

复制

返回值：

```
"2345"
```

```java
import java.util.*;


public class Solution {
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String str1, String str2) {
        // write code here
        //最长公共子串
        char[] arr1 = str1.toCharArray();
        char[] arr2 = str2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        String[][] dp = new String[len1+1][len2+1];
        String res = "";
        for(int i=0;i<=len1;i++){
            for(int j=0;j<=len2;j++){
                if(i==0||j==0){
                    dp[i][j] = "";
                }else if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + arr1[i-1];
                }else{
                    //不相等
                    dp[i][j] = "";
                }
                res = res.length()<dp[i][j].length()?dp[i][j]:res;
            }
        }
        return res;
    }
}
```

### [Leetcode1143 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
示例 2：

输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] num1 = text1.toCharArray();
        char[] num2 = text2.toCharArray();
        int n = num1.length;
        int m = num2.length;
        // 动态规划
        int[][] dp = new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                //判断
                if(num1[i-1]==num2[j-1]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[n][m];
    }
}
```

### [NC 92 最长公共子序列II](https://www.nowcoder.com/practice/6d29638c85bb4ffd80c020fe244baf11?tpId=117&&tqId=37798&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定两个字符串str1和str2，输出两个字符串的最长公共子序列。如果最长公共子序列为空，则返回"-1"。目前给出的数据，仅仅会存在一个最长的公共子序列

**示例1**

输入：

```
"1A2C3D4B56","B1D23A456A"
```

返回值：

```
"123456"
```

**示例2**

输入：

```
"abc","def"
```

返回值：

```
"-1"
```

**示例3**

输入：

```
"abc","abc"
```

返回值：

```
"abc"
```

```java
import java.util.*;


public class Solution {
    /**
     * longest common subsequence
     * @param s1 string字符串 the string
     * @param s2 string字符串 the string
     * @return string字符串
     */
    public String LCS (String s1, String s2) {
        // write code here
        char[] arr1 = s1.toCharArray();
        char[] arr2 = s2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        String[][] dp = new String[len1+1][len2+1];
        for(int i=0;i<=len1;i++){
            for(int j=0;j<=len2;j++){
                if(i==0||j==0){
                    dp[i][j] = "";
                }else if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + arr1[i-1];
                }else{
                    dp[i][j] = dp[i-1][j].length()>dp[i][j-1].length()?dp[i-1][j]:dp[i][j-1];
                }
            }
        }
        return dp[len1][len2]==""?"-1":dp[len1][len2];
    }
}
```

### [牛客-查找两个字符串a,b中的最长公共子串](https://www.nowcoder.com/questionTerminal/181a1a71c7574266ad07f9739f791506)

查找两个字符串a,b中的最长公共子串。若有多个，输出在较短串中最先出现的那个。 

  注：子串的定义：将一个字符串删去前缀和后缀（也可以不删）形成的字符串。请和“子序列”的概念分开！


  本题含有多组输入数据！


**输入描述:**

```
输入两个字符串
```

**输出描述:**

```
返回重复出现的字符
```

示例1

**输入**

```
abcdefghijklmnop
abcsafjklmnopqrstuvw
```

**输出**

```
jklmnop
```

**复杂方法**

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            String s1 = in.nextLine();
            String s2 = in.nextLine();
            String max = s1.length() >= s2.length()?s1:s2;
            String min = s1.length() >= s2.length()?s2:s1;
            int l = 0;
            String s ="";
            for(int i=0;i<min.length();i++){
                for(int j=i+1;j<=min.length();j++){
                    if(max.contains(min.substring(i,j)) && j-i>l){
                        l=j-i;
                        s=min.substring(i,j);
                    }
                }
            }
            System.out.println(s);
        }
        
    }
    
}
```



### - - - 单回文

### [最长回文子串-Leetcode005最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例 2：

输入：s = "cbbd"
输出："bb"
示例 3：

输入：s = "a"
输出："a"
示例 4：

输入：s = "ac"
输出："a"

> 中心扩散法

```java
class Solution {
    public String longestPalindrome(String s) {
        // 中心扩散法
        String res = "";
        int len = s.length();
        for(int i=0;i<len;i++){
            String s1 = check(s,i,i);
            String s2 = check(s,i,i+1);
            // 判断
            res = s1.length()>res.length()?s1:res;
            res = s2.length()>res.length()?s2:res;
        }
        return res;
    }

    public String check(String s,int l,int r){
        while(l>=0&&r<s.length()&&s.charAt(l)==s.charAt(r)){
            l--;
            r++;
        }
        return s.substring(l+1,r);
    }
}
```

### [最长回文子序列-Leetcode516最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

示例 1：

输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
示例 2：

输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        // 最长回文子序列
        int n = s.length();
        int[][] dp = new int[n][n];
        // 初始化
        for(int i=0;i<n;i++){
            dp[i][i] = 1;
        }
        // 转移方程 从底向上 从左往右
        for(int i=n-1;i>=0;i--){
            for(int j=i+1;j<n;j++){
                if(s.charAt(i)==s.charAt(j)){
                    //回文序列
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);
                }
            }
        }
        return dp[0][n-1];
    }
}
```

### [NC154 最长回文子序列](https://www.nowcoder.com/practice/c7fc893654b44324b6763dea095ceaaf?tpId=117&&tqId=37864&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个字符串，找到其中最长的回文子序列，并返回该序列的长度。字符串长度<=5000

回文序列是指这个序列无论从左读还是从右读都是一样的。

**示例1**

输入：

```
"abccsb"
```

复制

返回值：

```
4
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param s string 一个字符串由小写字母构成，长度小于5000
     * @return int
     */
    public int longestPalindromeSubSeq (String s) {
        int len = s.length();
        if(len == 0){
            return 0;
        }
        // i - j 的最长回文子序列的长度
        int[][] dp = new int[len][len];

        for(int i = len - 1 ; i >= 0 ; i--){
            for(int j = i ; j < len ; j++){
                if(i == j){
                    dp[i][j] = 1;
                }else if(s.charAt(i) == s.charAt(j)){
                    dp[i][j] = dp[i+1][j-1] + 2;
                }else{
                    dp[i][j] = Math.max(dp[i+1][j] ,dp[i][j-1]);
                }
            }
        }
        return dp[0][len-1];
    }
}
```

### 

### --- 双数组覆盖的问题

### [1.Leetcode76 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"

```java
class Solution {
    public String minWindow(String s, String t) {
        // 得到t的字母以及频率表
        int[] need = new int[128];
        int[] window = new int[128];
        // 统计
        for(char c:t.toCharArray()){
            need[c]++;
        }
        // 滑窗
        int left = 0;
        int right = 0;
        // 结果
        String res = "";
        int minlen = s.length()+1;
        // 统计满足条件的
        int count = 0;
        while(right<s.length()){
            char c = s.charAt(right);
            window[c]++;
            //看是否满足条件
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            // 满足了左边移动
            while(count==t.length()){
                // 左边移动
                c = s.charAt(left);
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                // 记录长度
                if(right-left<minlen){
                    minlen = right-left+1;
                    res = s.substring(left,right+1);
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return res;
    }
}
```

### [2.Leetcode567字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)


给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

 

**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

> 解题思路：滑窗

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] need = new int[128];
        int[] window = new int[128];
        //统计
        for(char c:s1.toCharArray()){
            need[c]++;
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int count = 0;
        while(right<s2.length()){
            char c = s2.charAt(right);
            window[c]++;
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            //查看是否满足条件了
            while(right-left+1>=s1.length()){
                c = s2.charAt(left);
                //判断
                if(count==s1.length()){
                    return true;
                }
                // 继续
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return false;
    }
}
```

### [3.Leetcode438找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。
示例 1:

输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        // 字母异位词
        int[] need = new int[128];
        int[] window = new int[128];
        for(char c:p.toCharArray()){
            need[c]++;
        }
        int left = 0;
        int right = 0;
        int count  = 0;
        // 结果
        List<Integer> res = new ArrayList<>();
        while(right<s.length()){
            char c = s.charAt(right);
            window[c]++;
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            // 开始缩减
            while(right-left+1>=p.length()){
                if(count==p.length()){
                    res.add(left);
                }
                c = s.charAt(left);
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return res;
    }
}
```

### 15.字符串排列包含的问题

给定m个不重复的字符 [a, b, c, d]，以及一个长度为n的字符串tbcacbdata，问能否在这个字符串中找到一个长度为m的连续子串，使得这个子串刚好由上面m个字符组成，顺序无所谓，返回任意满足条件的一个子串的起始位置，未找到返回-1。比如上面这个例子，acbd，3。

**题目分析**

本题的子串需要满足   长度为m，字符不重复   ，可以使用   长为m的滑动窗口遍历字符串   ，窗口内每个字符都要出现一次，如果符合条件，就返回窗口起始位置。   

​    如果这里不允许使用substring,indexOf函数，可以将字符串中每个字符出现的次数存入长度为26的数组中进行比较每次数组中对应位置数量是否相等，具体可参照上面LeetCode 567题。

```java
public class Solution {
    public int checkInclusion(char[] ch,String s) {
        if(ch.length > s.length()){
            return -1;
        }
        for(int i = 0; i < s.length() - ch.length; i++){
            //每次匹配长度为m的子串
            if(matchs(ch,s.substring(i,i+ch.length)))
                return i;
        }
        return -1;
    }
    private static boolean matchs(char[] ch,String s){
        for(int i = 0; i < s.length();i++){
            //返回-1说明字符串中不包含这个字符
            if(s.indexOf(ch[i]) == -1)
                return false;
        }
        return true;
    }
}
```

### [NC28 最小覆盖子串](https://www.nowcoder.com/practice/c466d480d20c4c7c9d322d12ca7955ac?tpId=188&&tqId=38617&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给出两个字符串 S*S* 和 T*T*，要求在O(n)*O*(*n*)的时间复杂度内在 S*S* 中找出最短的包含 T*T* 中所有字符的子串。
例如：

S ="XDOYEZODEYXNZ"*S*="*X**D**O**Y**E**Z**O**D**E**Y**X**N**Z*"
T ="XYZ"*T*="*X**Y**Z*"
找出的最短子串为"YXNZ""*Y**X**N**Z*".

注意：
如果 S*S* 中没有包含 T*T* 中所有字符的子串，返回空字符串 “”；
满足条件的子串可能有很多，但是题目保证满足条件的最短的子串唯一。

**示例1**

输入：

```
"XDOYEZODEYXNZ","XYZ"
```

复制

返回值：

```
"YXNZ"
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param S string字符串 
     * @param T string字符串 
     * @return string字符串
     */
    public String minWindow (String s, String t) {
        // write code here
        // 两个子串
        int[] need = new int[128];
        int[] window = new int[128];
        for(Character c:t.toCharArray()){
            need[c]++;
        }
        // 滑动窗口
        int left = 0;
        int right = 0;
        int count = 0;
        char[] arr = s.toCharArray();
        int len = arr.length;
        // 记录结果
        int minLen = s.length()+1;
        String res = "";
        while(right<len){
            char c = arr[right];
            window[c]++;

            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            // 一直满足条件就一直剔除
            while(count==t.length()){
                c = arr[left];
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                if(right-left<minLen){
                    minLen = right-left+1;
                    res = s.substring(left,right+1);
                }

                window[c]--;
                left++;
            }
            right++;
        }
        return res;
    }
}
```

### 

### - - - 单个子串连续1的问题

### [3.Leetcode485 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

给定一个二进制数组， 计算其中最大连续 1 的个数。

 

示例：

输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        // 滑窗
        int left = 0;
        int right = 0;
        int res = 0;
        while(right<nums.length){
            // 缩
            if(nums[right]!=1){
                left = right+1;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [1.Leetcode1004最大连续1的个数III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 

示例 1：

输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。

> 解题思路：滑窗

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0;
        int right = 0;
        // 判断操作的次数
        int zeros = 0;
        // 记录结果
        int res = 0;
        while(right<nums.length){
            if(nums[right]==0){
                zeros++;
            }
            // 满足缩的条件了
            while(zeros>k){
                if(nums[left]==0){
                    zeros--;
                }
                left++;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [2.Leetcode1493删掉一个元素以后全为1的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

 

提示 1：

输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。

示例 2：

输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。

> 解题思路：对操作次数限制即可了。

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0;
        int right = 0;
        int zeros = 0;
        int res = 0;
        while(right<nums.length){
            if(nums[right]==0){
                zeros++;
            }
            //缩的条件
            while(zeros>1){
                if(nums[left]==0){
                    zeros--;
                }
                left++;
            }
            // 记录
            res = Math.max(res,right-left);
            right++;
        }
        return res;
    }
}
```

### [3.Leetcode424替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意：字符串长度 和 k 不会超过 104。

 

示例 1：

输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
示例 2：

输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。

```java
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int left = 0;
        int right = 0;
        // 记录
        int[] windows = new int[128];
        // 记录此时的最大频率
        int cur = 0;
        // 结果记录
        int res = 0;
        while(right<arr.length){
            //记录
            char c = arr[right];
            windows[c]++;
            cur = Math.max(cur,windows[c]);
            // 看是否满足缩招的条件了
            while(right-left+1-cur>k){
                c = arr[left];
                windows[c]--;
                left++;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### - - - 双数组转换代价最小 尽可能相等

### [2.Leetcode1208尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

给你两个长度相同的字符串，s 和 t。

将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

 

示例 1：

输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。

```java
class Solution {
    public int equalSubstring(String s, String t, int maxCost) {
        char[] s_arr = s.toCharArray();
        char[] t_arr = t.toCharArray();
        int[] cost = new int[s_arr.length];
        for(int i=0;i<s_arr.length;i++){
            cost[i] = Math.abs(s_arr[i]-t_arr[i]);
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int temp_cost = 0;
        int len = 0;
        while(right<cost.length){
            temp_cost += cost[right];
            //缩招
            while(temp_cost>maxCost){
                temp_cost -= cost[left];
                left++;
            }
            len = Math.max(len,right-left+1);
            right++;
        }
        return len;
    }
}
```

### [3.Leetcode1052 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)


今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。

在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。

请你返回这一天营业下来，最多有多少客户能够感到满意。


**示例：**

```
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```



```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int sum1 = 0;
        for(int i=0;i<customers.length;i++){
            if(grumpy[i]==0){
                sum1 += customers[i];
                customers[i] = 0;
            }
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int temp_sum = 0;
        int sum2 = 0;
        while(right<customers.length){
            temp_sum += customers[right];
            // 是否缩招
            while(right-left+1>minutes){
                temp_sum -= customers[left];
                left++;
            }
            sum2 = Math.max(sum2,temp_sum);
            right++;
        }
        return sum1+sum2;
    }
}
```

### - - - 编辑距离代价问题

### [牛客-求x到y的最少计算次数](https://www.nowcoder.com/questionTerminal/45d04d4d047c48768543eeec95798ed6?commentTags=Java)

链接：https://www.nowcoder.com/questionTerminal/45d04d4d047c48768543eeec95798ed6?commentTags=Java
来源：牛客网



给定两个-100到100的整数x和y,对x只能进行加1，减1，乘2操作，问最少对x进行几次操作能得到y？ 

  例如：
 a=3,b=11: 可以通过3*2*2-1，3次操作得到11；
 a=5,b=8：可以通过(5-1)*2，2次操作得到8；

**输入描述:**

```
输入以英文逗号分隔的两个数字，数字均在32位整数范围内。
```

**输出描述:**

```
输出一个数字
```

示例1

**输入**

```
3,11
```

**输出**

```
3
```

```java
import java.util.*;

public class Main {
    
    public static void main(String[] args) {
        
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        String[] nums = s.split(",");
        int a = Integer.parseInt(nums[0]);
        int b = Integer.parseInt(nums[1]);
        
        int ans = solution(a,b);
        System.out.println(ans);
    }
    
    private static int solution(int a, int b){
        
        int ans = 0;
        // 特殊值
            if(a == 0 && b <= 0) return Math.abs(b);
            if(a == 0 && b > 0) return minOps(1,b) + 1;

        // a b 同号
        if(a * b > 0){
            a = Math.abs(a); b = Math.abs(b);
            if(a >= b) return a - b;
            // a < b
            else return minOps(a,b);
        } 
        // a b 异号
        // 如果 a 是负值，将 a 转换为正值 1，则 a * b > 0,调用自身得到结果。
        if(a < 0) return ans - a + 1 + solution(1,b);
        // 如果 b 是负值，将 b 转换为正值 1。
        return ans - b + 1 + solution(a,1);
    }
    
    private static int minOps(int a, int b){

        if(b >= a && b <= (a << 1))
            return Math.min(b - a,(a << 1) - b + 1);
        if((b & 1) == 1)
            return Math.min(minOps(a,(b + 1) >> 1), minOps(a,(b - 1) >> 1)) + 2;
        return minOps(a,b >> 1) + 1;
    }
}
```

**深度优先搜索**

```java
import java.util.Scanner;

/**
 * @Author: coderjjp
 * @Date: 2020-05-09 18:27
 * @Description:
 * @version: 1.0
 */
public class Main {
    static Scanner sc = new Scanner(System.in);
    static String s[] = sc.next().split(",");
    static int x = Integer.valueOf(s[0]);
    static int y = Integer.valueOf(s[1]);
    static int min = Math.abs(x - y);//最小值的上界
    public static void main(String[] args) {
        dfs(x, y, 0);
        System.out.println(min);
    }

    private static void dfs(int x, int y, int count) {
        if (count == min)
            return;
        if (x == y){
            min = count;
            return;
        }
        dfs(x + 1, y, count + 1);
        dfs(x - 1, y, count + 1);
        dfs(x * 2, y, count + 1);
    }
}
```



### [1.Leetcode72 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符
删除一个字符
替换一个字符


示例 1：

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

```java
class Solution {
    public int minDistance(String word1, String word2) {
        char[] arr1 = word1.toCharArray();
        char[] arr2 = word2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        //结果
        int[][] dp = new int[len1+1][len2+1];
        // 初始化
        for(int i=0;i<=len1;i++){
            dp[i][0] = i;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j;
        }
        // 转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.min(dp[i-1][j-1],Math.min(dp[i-1][j],dp[i][j-1]))+1;
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [2.NC35 最小编辑代价](https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=117&&tqId=37801&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。

**示例1**

输入：

```
"abc","adc",5,3,2
```

返回值：

```
2
```



**示例2**

输入：

```
"abc","adc",5,3,100
```

复制

返回值：

```
8
```

```java
import java.util.*;


public class Solution {
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    public int minEditCost (String str1, String str2, int ic, int dc, int rc) {
        // write code here
        //将str1编辑成str2的最小代价
        char[] arr1 = str1.toCharArray();
        char[] arr2 = str2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        int[][] dp = new int[len1+1][len2+1];
        //初始化
        for(int i=0;i<=len1;i++){
            dp[i][0] = i*dc;
        }
        for(int j=0;j<=len2;j++){
            dp[0][j] = j*ic;
        }
        //转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    int insert = dp[i][j-1]+ic;
                    int delete = dp[i-1][j]+dc;
                    int replace = dp[i-1][j-1] + rc;
                    dp[i][j] = Math.min(replace,Math.min(insert,delete));
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [3.Leetcode583 两个字符串的删除操作](https://leetcode-cn.com/problems/delete-operation-for-two-strings/)

给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。

 

示例：

输入: "sea", "eat"
输出: 2
解释: 第一步将"sea"变为"ea"，第二步将"eat"变为"ea"

> LCS的变形，找到相同的，总共减相同的即可

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        int same = lcs(word1,word2);
        return len1+len2-same-same;
    }
    // LCS
    public int lcs(String word1,String word2){
        char[] arr1 = word1.toCharArray();
        char[] arr2 = word2.toCharArray();
        int len1 = arr1.length;
        int len2 = arr2.length;
        // 动态规划
        int[][] dp = new int[len1+1][len2+1];
        // 初始化
        // 转移方程
        for(int i=1;i<=len1;i++){
            for(int j=1;j<=len2;j++){
                // 转移方程
                if(arr1[i-1]==arr2[j-1]){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```

### [Leetcode712 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

```java
class Solution {
    public int minimumDeleteSum(String s1, String s2) {
        // 计算最长公共前缀的asicii的话
        int sum_ascii = lcs(s1,s2);
        int sum_1 = 0;
        int sum_2 = 0;
        for(int i=0;i<s1.length();i++){
            sum_1 += (int)s1.charAt(i);
        }
        for(int j=0;j<s2.length();j++){
            sum_2 += (int)s2.charAt(j);
        }
        int res = sum_1+sum_2-sum_ascii-sum_ascii;
        return res;

    }

    // 最长公共子串前缀
    public int lcs(String s1,String s2){
        // dp里面存ascii
        int m = s1.length();
        int n = s2.length();
        int[][] dp = new int[m+1][n+1];
        // 转移方程
        for(int i=1;i<=m;i++){
            for(int j=1;j<=n;j++){
                //判断
                if(s1.charAt(i-1)==s2.charAt(j-1)){
                    dp[i][j] = (int)s1.charAt(i-1)+dp[i-1][j-1];
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

### [4.Leetcode1312 让字符串成为回文串的最小插入次数](https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/)

给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。

请你返回让 s 成为回文串的 最少操作次数 。

「回文串」是正读和反读都相同的字符串。

 

示例 1：

输入：s = "zzazz"
输出：0

```java
class Solution {
    public int minInsertions(String s) {
        // 类似于查找最长回文序列
        char[] arr = s.toCharArray();
        // 动态规划
        int n = arr.length;
        int[][] dp = new int[n][n];
        // 正方形右上角
        // 初始化
        for(int i=0;i<n;i++){
            dp[i][i] = 0;
        }
        // 转移方程 从下往上 从左到右
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                // 相等无需处理
                if(arr[i]==arr[j]){
                    // 从当前往外走
                    dp[i][j] = dp[i+1][j-1];
                }else{
                    // 不相等 添加哪一个进来
                    dp[i][j] = Math.min(dp[i+1][j],dp[i][j-1]) + 1;
                }
            }
        }
        return dp[0][n-1];
    }
}
```

### -其它应用单词字典

### [Leetcode1048 最长字符串链](https://leetcode-cn.com/problems/longest-string-chain/)

给出一个单词列表，其中每个单词都由小写英文字母组成。

如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，"abc" 是 "abac" 的前身。

词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。

从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。


示例：

输入：["a","b","ba","bca","bda","bdca"]
输出：4
解释：最长单词链之一为 "a","ba","bda","bdca"。

> 动态规划；词链的判断

```java
class Solution {
    public int longestStrChain(String[] words) {
        // 动态规划以当前i结尾的串链个数
        // 1.先排序
        Arrays.sort(words,(a,b)->(a.length()-b.length()));
        //2.动态规划
        int n = words.length;
        int[] dp = new int[n];
        //转移方程
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                //判断
                if(check(words[i],words[j])){
                    dp[j] = Math.max(dp[i]+1,dp[j]);
                }
            }
        }
        // 3.结果
        int res = 0;
        for(int i:dp){
            res = Math.max(res,i);
        }
        return res+1;
    }   

    // 判断这两个词是否属于词链
    public boolean check(String a,String b){
        //长度相差1
        if(b.length()-a.length()!=1){
            return false;
        }
        int count = 0;
        int i = 0;
        int j =0;
        // 继续
        while(i<a.length()&&j<b.length()){
            //判断
            if(a.charAt(i)==b.charAt(j)){
                i++;
                j++;
            }else{
                count++;
                j++;
                if(count>1){
                    return false;
                }
            }
        }
        return true;
    }
}
```

### [面试题17.15 最长单词](https://leetcode-cn.com/problems/longest-word-lcci/)

给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。

示例：

输入： ["cat","banana","dog","nana","walk","walker","dogwalker"]
输出： "dogwalker"
解释： "dogwalker"可由"dog"和"walker"组成。
提示：

0 <= len(words) <= 200
1 <= len(words[i]) <= 100

```java
class Solution {
    public String longestWord(String[] words) {
        // 将单词列表按照长度降序 长度相同 按照字典序
        Arrays.sort(words,(o1,o2)->{
            if(o1.length()==o2.length()){
                return o1.compareTo(o2);
            }else{
                return Integer.compare(o2.length(),o1.length());
            }
        });
        // 用set
        Set<String> set = new HashSet<>(Arrays.asList(words));
        // 遍历当前单词是不是组合单词，是的话直接返回
        for(String word:words){
            set.remove(word);
            if(isComposedWord(set,word)){
                return word;
            }
            set.add(word);
        }   
        return "";
    }

    // 判断是否是组合单词
    public boolean isComposedWord(Set<String> set,String word){
        if(word.length()==0){
            return true;
        }
        for(int i=0;i<word.length();i++){
            if(set.contains(word.substring(0,i+1))&&isComposedWord(set,word.substring(i+1))){
                return true;
            }
        }
        return false;

    }
}
```

### [Leetcode139 单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        // 单词拆分 最外层是j
        // 用hashset来存储
        int n = s.length();
        HashSet<String> dict = new HashSet<>(wordDict);
        // 动态规划
        boolean[] dp = new boolean[n+1];
        // 开始
        dp[0] = true;
        // 转移方程
        for(int j=1;j<=n;j++){
            for(int i=0;i<j;i++){
                if(dp[i]&&dict.contains(s.substring(i,j))){
                    dp[j] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

### [Leetcode140 单词拆分II](https://leetcode-cn.com/problems/word-break-ii/)

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。

说明：

分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]

```java
class Solution {
    // 单词拆分
    // 结果存储
    List<String> res = new ArrayList<>();
    public List<String> wordBreak(String s, List<String> wordDict) {
        // 每一次的临时结果
        List<String> path = new ArrayList<>();
        // 将其转换为数组
        char[] arr = s.toCharArray();
        //  dfs算法
        dfs(arr,0,wordDict,path);
        return res;
    }
    //  dfs回溯算法
    public void dfs(char[] arr,int index, List<String> wordDict,List<String> path){
        // 如果遍历到最后了
        if(index==arr.length){
            // 将结果添加进来
            StringBuilder temp = new StringBuilder();
            // 对其遍历
            for(String word:path){
                temp.append(word);
                temp.append(" ");
            }
            res.add(temp.toString().substring(0,temp.length()-1));
        }
        // 递归结束条件
        if(index>arr.length){
            return;
        }
        // 选择状态
        for(String word:wordDict){
            // 当前单词的长度
            int len = word.length();
            // 判断是否相等
            if(index+len<=arr.length&&new String(arr,index,len).equals(word)){
                // 符合条件相等
                path.add(word);
                dfs(arr,index+len,wordDict,path);
                path.remove(path.size()-1);

            }
        }


    }
}
```

### Leetcode93 复原IP地址

给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

 

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        //结果
        List<String> res = new ArrayList<>();
        dfs(s,0,new ArrayList<>(),res);
        return res;
    }

    public void dfs(String s,int startIndex,List<String> path,List<String> res){
        // 递归截止条件
        if(path.size()>4){
            return;
        }
        if(path.size()>=4&&startIndex!=s.length()){
            return;
        }
        // 符合条件
        if(path.size()==4){
            res.add(String.join(".",path));
            return;
        }
        // 遍历
        for(int i=startIndex;i<s.length();i++){
            // 过滤条件在0-255之间，且前缀不是0 或者其长度大于3了
            String newStr = s.substring(startIndex,i+1);
            if( (newStr.length()>1&&newStr.startsWith("0"))  || newStr.length()>3){
                continue;
            }
            //判断数值方面
            int value = Integer.valueOf(newStr);
            if(value<0 || value>255){
                continue;
            }
            path.add(newStr);
            dfs(s,i+1,path,res);
            path.remove(path.size()-1);
        }
    }
}
```

### Leetcode468 验证IP地址

编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。

如果是有效的 IPv4 地址，返回 "IPv4" ；
如果是有效的 IPv6 地址，返回 "IPv6" ；
如果不是上述类型的 IP 地址，返回 "Neither" 。
IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(".")分割。比如，172.16.254.1；

同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。

IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (":")分割。比如,  2001:0db8:85a3:0000:0000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。

然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 是无效的 IPv6 地址。

同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的。

```java
class Solution {
    public String validIPAddress(String IP) {
        //开始判断
        if(IP==null||"".equals(IP)){
            return "Neither";
        }
        //判断
        if(IP.contains(".")){
            return isV4(IP);
        }else if(IP.contains(":")){
            return isV6(IP);
        }else{
            return "Neither";
        }
    }

    //判断V4
    public String isV4(String IP){
        //分割
        String[] isSegments = IP.split("\\.",-1);
        if(isSegments.length!=4){
            return "Neither";
        }
        // 继续遍历判断
        for(String s:isSegments){
            //判断每个ip的长度是否符合条件
            if(s.length()==0||s.length()>3||(s.length()>1&&s.charAt(0)=='0')){
                return "Neither";
            }
            // 继续判断中间存在不是数字的
            for(int i=0;i<s.length();i++){
                if(!Character.isDigit(s.charAt(i))){
                    return "Neither";
                }
            }
            //判断大小
            int val = Integer.parseInt(s);
            if(val>255){
                return "Neither";
            }
        }
        return "IPv4";
    }
    // 判断IPV6
    public String isV6(String IP){
        String[] ipSegments = IP.split(":",-1);
        //判断长度
        if(ipSegments.length!=8){
            return "Neither";
        }
        // 遍历判断
        for(String s:ipSegments){
            if(s.length()==0||s.length()>4){
                return "Neither";
            }
            // 继续单个字母
            for(int i=0;i<s.length();i++){
                char ch = s.charAt(i);
                if(!Character.isDigit(ch)&&(Character.toLowerCase(ch)>'f'||Character.toLowerCase(ch)<'a')){
                    return "Neither";
                }
            }
        }
        return "IPv6";
    }



}
```

### 8.IP地址与int整数的转换

ip地址与整数的转换。

例如，ip地址为10.0.3.193，把每段拆分成一个二进制形式组合起来为00001010 00000000 00000011 11000001，然后把这个二进制数转变成十进制整数就是167773121。

**题目分析：**

**IP地址转为整数**

借助位运算实现。如IP10.0.3.193，将10左移24位，0左移16位，3左移8位，193左移0位。4个seg`或运算`，即为结果。

```java
String ip = "10.0.3.193";
String[] arr = ip.split("\\.");
int arr0 = Integer.valueOf(arr[0])<<24;
int arr1 = Integer.valueOf(arr[1])<<16;
int arr2 = Integer.valueOf(arr[2])<<8;
int arr3 = Integer.valueOf(arr[3]);
System.out.println(arr0 | arr1 | arr2 | arr3);
```

**如何将整数转成IP**

将整数和255做`与运算`，结果为IP的第4段。整数右移8位，和255做`与运算`的结果就是IP的第3段...最后再将每轮与运算的结果拼接起来便是最终的IP地址。

```java
package com.lcz.test;

import java.util.Collections;
import java.util.*;

public class Test10 {
	public static void main(String[] args) {
		int n = 167773121;
		List<String> list = new ArrayList<>();
		list.add(Integer.toString(n&255));
		list.add(Integer.toString(n>>8&255));
		list.add(Integer.toString(n>>16&255));
		list.add(Integer.toString(n>>24&255));
		Collections.reverse(list);
		String res = "";
		for(int i=0;i<list.size();i++) {
			if(i==list.size()-1) {
				res += list.get(i);
			}else {
				res += list.get(i)+".";
			}
		}
		System.out.println(res);
	}
}

```



### [Leetcode1405 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)

如果字符串中不含有任何 'aaa'，'bbb' 或 'ccc' 这样的字符串作为子串，那么该字符串就是一个「快乐字符串」。

给你三个整数 a，b ，c，请你返回 任意一个 满足下列全部条件的字符串 s：

s 是一个尽可能长的快乐字符串。
s 中 最多 有a 个字母 'a'、b 个字母 'b'、c 个字母 'c' 。
s 中只含有 'a'、'b' 、'c' 三种字母。
如果不存在这样的字符串 s ，请返回一个空字符串 ""。

 

示例 1：

输入：a = 1, b = 1, c = 7
输出："ccaccbcc"
解释："ccbccacc" 也是一种正确答案。
示例 2：

输入：a = 2, b = 2, c = 1
输出："aabbc"

```java
class Solution {
    public String longestDiverseString(int a, int b, int c) {
        // 贪心算法
        String res = "";
        int[] A = new int[3];
        A[0] = a;
        A[1] = b;
        A[2] = c;
        int i;
        while(true){
            int ban = -1;
            for(i=0;i<A.length;i++){
                //判断
                if(res.length()>=2&&res.charAt(0)==res.charAt(1)&&res.charAt(0)-'a'==i){
                    ban = i;
                    break;
                }
            }
            int select = -1;
            for(i=0;i<A.length;i++){
                if(A[i]<=0 || ban==i){
                    continue;
                }
                if(select==-1 || A[i]>A[select]){
                    select = i;
                }
            }
            if(select==-1){
                break;
            }
            res = (char)(select+'a')+res;
            A[select] -= 1;
        }
        return res;
    }
}
```

### [面试题17.15 最长单词](https://leetcode-cn.com/problems/longest-word-lcci/)

给定一组单词words，编写一个程序，找出其中的最长单词，且该单词由这组单词中的其他单词组合而成。若有多个长度相同的结果，返回其中字典序最小的一项，若没有符合要求的单词则返回空字符串。

示例：

输入： ["cat","banana","dog","nana","walk","walker","dogwalker"]
输出： "dogwalker"
解释： "dogwalker"可由"dog"和"walker"组成。
提示：

0 <= len(words) <= 200
1 <= len(words[i]) <= 100

```java
class Solution {
    public String longestWord(String[] words) {
        // 将单词列表按照长度降序 长度相同 按照字典序
        Arrays.sort(words,(o1,o2)->{
            if(o1.length()==o2.length()){
                return o1.compareTo(o2);
            }else{
                return Integer.compare(o2.length(),o1.length());
            }
        });
        // 用set
        Set<String> set = new HashSet<>(Arrays.asList(words));
        // 遍历当前单词是不是组合单词，是的话直接返回
        for(String word:words){
            set.remove(word);
            if(isComposedWord(set,word)){
                return word;
            }
            set.add(word);
        }   
        return "";
    }

    // 判断是否是组合单词
    public boolean isComposedWord(Set<String> set,String word){
        if(word.length()==0){
            return true;
        }
        for(int i=0;i<word.length();i++){
            if(set.contains(word.substring(0,i+1))&&isComposedWord(set,word.substring(i+1))){
                return true;
            }
        }
        return false;

    }
}
```

### - - - 翻转 反转字符串单词

#### [Leetcode557 反转字符串中的单词III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```java
class Solution {
    //反转字符串中的单词II
    public String reverseWords(String s) {
        //先分割
        String[] strs = s.split("\\s+");
        // 结果
        StringBuilder res = new StringBuilder();
        //对其处理
        for(int i=0;i<strs.length;i++){
            // 添加
            res.append(new StringBuilder(strs[i]).reverse().toString());
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```



#### [Leetcode151 翻转字符串里的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)

给你一个字符串 s ，逐个翻转字符串中的所有 单词 。

单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。

请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。

说明：

输入字符串 s 可以在前面、后面或者单词间包含多余的空格。
翻转后单词间应当仅用一个空格分隔。
翻转后的字符串中不应包含额外的空格。


示例 1：

输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：

输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。

> 解题思路一、调用API

```java
class Solution {
    //使用split和reverse
    public String reverseWords(String s) {
        // 先对其分割成单词
        String[] words = s.trim().split("\\s+");
        //翻转 
        Collections.reverse(Arrays.asList(words));
        //对数组结果拼接
        return String.join(" ",words);
    }
}
```

**解题思路二、**

```java
class Solution {
    public String reverseWords(String s) {
        //分三步走
        // 先翻转整个数组
        // 再翻转单个单词
        //清除多余空格
        if(s==null){
            return null;
        }
        char[] s_arr = s.toCharArray();
        int n = s_arr.length;
        //第一步翻转这个数组
        reverse(s_arr,0,n-1);
        // 第二步翻转单个单词
        word_reversee(s_arr,n);
        // 第三步去除多余空格
        return clean_space(s_arr,n);
    }

    public void  reverse(char[] s_arr,int i,int j){
        while(i<j){
            char temp = s_arr[i];
            s_arr[i++] = s_arr[j];
            s_arr[j--] = temp;
        }
    }
    // 单词翻转
    public void word_reversee(char[] s_arr,int n){
        int i = 0;
        int j = 0;
        //结束条件
        while(j<n){
            //找到第一个的首字母
            while(i<n&&s_arr[i]==' ')i++;
            // 继续寻找
            j = i;
            while(j<n&&s_arr[j]!=' ')j++;
            reverse(s_arr,i,j-1);
            // 继续找
            i = j;
        }
    }

    // 去除多余的空格
    public String clean_space(char[] s_arr,int n){
        int i = 0;
        int j = 0;
        // 结束条件
        while(j<n){
            while(j<n&&s_arr[j]==' ')j++;
            while(j<n&&s_arr[j]!=' ')s_arr[i++] = s_arr[j++];
            while(j<n&&s_arr[j]==' ')j++;
            if(j<n)s_arr[i++] = ' ';
        }
        return new String(s_arr).substring(0,i);
    }

}
```

#### Leetcode344 反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

 

示例 1：

输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
示例 2：

输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]

```java
class Solution {
    public void reverseString(char[] s) {
        int n = s.length;
        int left = 0;
        int right = n-1;
        while(left<right){
            char temp = s[left];
            s[left]  = s[right];
            s[right] = temp;
            // 继续走
            left++;
            right--;
        }
    }
}
```

#### Leetcode7 整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

输入：x = 123
输出：321
示例 2：

输入：x = -123
输出：-321
示例 3：

输入：x = 120
输出：21

```java
class Solution {
    public int reverse(int x) {
        int res = 0;
        while(x!=0){
            int digit = x%10;
            // 判断是否溢出
            if((res*10)/10!=res){
                return 0;
            }
            res = res*10+digit;
            x = x/10;
        }
        return res;
    }
}
```

#### Leetcoode796 旋转字符串

给定两个字符串, A 和 B。

A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

示例 1:
输入: A = 'abcde', B = 'cdeab'
输出: true

示例 2:
输入: A = 'abcde', B = 'abced'
输出: false

```java
class Solution {
    public boolean rotateString(String A, String B) {
                return A.length() == B.length() && (A + A).contains(B);

    }
}

```

#### 剑指Offer05 替换空格

请实现一个函数，把字符串 s 中的每个空格替换成"%20"。

 

示例 1：

输入：s = "We are happy."
输出："We%20are%20happy."

```java
class Solution {
    public String replaceSpace(String s) {
        // 用stringbuilder来拼接字符串
        // 将其转换为数组
        char[] arr = s.toCharArray();
        // 结果
        StringBuilder res = new StringBuilder();
        // 对其遍历
        for(int i=0;i<arr.length;i++){
            // 对其遍历
            if(arr[i]==' '){
                // 空格
                res.append("%20");
            }else{
                res.append(arr[i]);
            }
        }
        return res.toString();
    }
}
```



#### 反转字符串中的单词

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

```java
class Solution {
    //反转字符串中的单词II
    public String reverseWords(String s) {
        //先分割
        String[] strs = s.split("\\s+");
        // 结果
        StringBuilder res = new StringBuilder();
        //对其处理
        for(int i=0;i<strs.length;i++){
            // 添加
            res.append(new StringBuilder(strs[i]).reverse().toString());
            res.append(" ");
        }
        return res.toString().trim();
    }
}
```

### 15.Leetcode字符串变形

描述

对于一个给定的字符串，我们需要在线性(也就是O(n))的时间里对它做一些变形。首先这个字符串中包含着一些空格，就像"Hello World"一样，然后我们要做的是把着个字符串中由空格隔开的单词反序，同时反转每个字符的大小写。比如"Hello World"变形后就变成了"wORLD hELLO"。

**输入描述：**

给定一个字符串s以及它的长度n(1≤n≤500)

**返回值描述：**

请返回变形后的字符串。题目保证给定的字符串均由大小写字母和空格构成。

示例1

输入：

```
"This is a sample",16
```

复制

返回值：

```
"SAMPLE A IS tHIS"
```

```java
import java.util.*;

public class Solution {
    public String trans(String s, int n) {
        StringBuffer str=new StringBuffer();
        int start=0;
        for (int i = n-1; i >= 0; i--) {
            if(s.charAt(i)==' '){
                str.append(" ");
                start=n-i;
            }else {
                char sss = (char) (s.charAt(i) < 97 ? s.charAt(i) + 32 : s.charAt(i) - 32);
                str.insert(start, sss);
            }
        }
        return str.toString();
    }
}
```

### 反转数字

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

你有注意到翻转后的整数可能溢出吗？因为给出的是32位整数，则其数值范围为[−2^{31}, 2^{31} − 1][−231,231−1]。翻转可能会导致溢出，如果反转后的结果会溢出就返回 0。

**示例1**

输入：

```
12
```



返回值：

```
21
```



示例2

输入：

```
-123
```

复制

返回值：

```
-321
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param x int整型 
     * @return int整型
     */
    public int reverse (int x) {
        // write code here
        int res = 0;
        while(x!=0){
            int cur = x%10;
            if((res*10)/10!=res){
                return 0;
            }
            res = res*10+cur;
            x = x/10;
        }
        return res;
    }
}
```



### [NC114 旋转字符串](https://www.nowcoder.com/practice/80b6bb8797644c83bc50ac761b72981c?tpId=117&&tqId=37838&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

字符串旋转:

给定两字符串A和B，如果能将A从中间某个位置分割为左右两部分字符串（可以为空串），并将左边的字符串移动到右边字符串后面组成新的字符串可以变为字符串B时返回true。

例如：如果A=‘youzan’，B=‘zanyou’，A按‘you’‘zan’切割换位后得到‘zanyou’和B相同，返回true。

再如：如果A=‘abcd’，B=‘abcd’，A切成‘abcd’和''（空串），换位后可以得到B，返回true。

**示例1**

输入：

```
"youzan","zanyou"
```

复制

返回值：

```
true
```

复制

**示例2**

输入：

```
"youzan","zyouan"
```

复制

返回值：

```
false
```



> 优美的解决思路：假如 A="abcd" 则 A+A = "abcdabcd"
> 2、如果B 满足 题目的条件，则B 一定属于 A+A 里面的一个子串

```java
import java.util.*;


public class Solution {
    /**
     * 旋转字符串
     * @param A string字符串 
     * @param B string字符串 
     * @return bool布尔型
     */
    public boolean solve (String A, String B) {
        // write code here
          //特殊情况处理
        if(A==null||B==null||A.length()<2||B.length()<2||A.length()!=B.length()){
            return false;
        }
        //日   这么巧妙
        return (A+A).contains(B);
    }
}
```

思路之二：
1、A和B长度不等，则返回 false
2、A个B长度相等，不断的切割 A为head和tail 两部分
3、如果B中同时包含 head和tail 两部分，则返回true
4、如果一直没找到，则返回false

```java
import java.util.*;


public class Solution {
    /**
     * 旋转字符串
     * @param A string字符串 
     * @param B string字符串 
     * @return bool布尔型
     */
    public boolean solve (String A, String B) {
         // write code here
        if(A==null||B==null||A.length()<2||B.length()<2||A.length()!=B.length()){
            return false;
        }
        int i=1;
        while(i<A.length()){
            String headStr = A.substring(0,i);
            String tailStr = A.substring(i);
            if(B.contains(headStr)&&B.contains(tailStr)){
                return true;
            }
            i++;
        }
        return false;
    }
}
```

### [NC翻转数列](https://www.nowcoder.com/questionTerminal/cc0a71a1dfdb4c64a3ffe000f71ae12c)

链接：https://www.nowcoder.com/questionTerminal/cc0a71a1dfdb4c64a3ffe000f71ae12c
来源：牛客网



小Q定义了一种数列称为翻转数列:
 给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为'-';。
 例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.
 而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.
 小Q现在希望你能帮他算算前n项和为多少。

**输入描述:**

```
输入包括两个整数n和m(2 <= n <= 109, 1 <= m), 并且满足n能被2m整除。
```

**输出描述:**

```
输出一个整数, 表示前n项和。
```

示例1

**输入**

```
8 2
```

**输出**

```
8
```



首先观察数列，我们可以将一组负正的数出现（如**-1,-2,3,4**）看作一组，则n个数一共有***n/(2m)\***组，而每一组求和结果为**m\*m**。于是得到前n项和的公式：***S\**n\**=n\*m\*m/(2m)=m\*n/2\*** 

 

```java

	/**

	* 思路: 单纯数学规律，从第一个数字开始，每 2m 个数字之和为 m^2，总共有 n/2m 个这样的组合，因此和为 m*n/2

	*/

	import java.util.*;

	public class Main{

	    public static void main(String[] args){

	        Scanner sc = new Scanner(System.in);

	        longn = sc.nextLong();

	        longm = sc.nextLong();

	        System.out.println(process(n, m));

	    }

	    public static long process(long n, long m){

	        if(n % (2* m) != 0)

	            return-1;

	        return m * (n / 2);

	    }

	}


```









## 字符串编码和解码

### [1.Leetcode443 压缩字符串](https://leetcode-cn.com/problems/string-compression/)

```java
class Solution {
    public int compress(char[] chars) {
        //压缩字符串
        int i = 0;
        // 新字符串的索引
        int index = 0;
        while(i<chars.length){
            // 查看后一个
            int j = i+1;
            // 查看是否需要编码
            while(j<chars.length&&chars[i]==chars[j]){
                j++;
            }
            // 相同的数目
            int num = j-i;
            if(num==1){
                //不需要编码
                chars[index++] = chars[i++];
                // 比较下一个
                continue;
            }
            // 需要编码
            chars[index++] = chars[i];
            int mod = num%10;
            // 如果大于10
            while(num>=10){
                num = num/10;
                chars[index++] = (char)(num+'0');
            }
            // 如果还有
            if(num>0){
                chars[index++] = (char)(mod+'0');
            }
            // 重新移动
            i = j;
        }
        return index;
    }
}
```

### [2.Leetcode394 字符串解码](https://leetcode-cn.com/problems/decode-string/)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

 

示例 1：

输入：s = "3[a]2[bc]"
输出："aaabcbc"

> 开始解码

```java
class Solution {
    public String decodeString(String s) {
        Stack<Integer> s_num = new Stack<>();
        Stack<StringBuilder> s_str = new Stack<>();
        // 存值
        int num = 0;
        StringBuilder res = new StringBuilder();
        int i = 0;
        char[] arr = s.toCharArray();
        // 开始
        while(i<arr.length){
            // 判断
            if(Character.isDigit(arr[i])){
                // 数字
                num = num*10 + arr[i]-'0';
            }else if(Character.isAlphabetic(arr[i])){
                //字母
                res.append(arr[i]);
            }else if(arr[i]=='['){
                // 入栈
                s_num.push(num);
                s_str.push(res);
                num = 0;
                res = new StringBuilder();
            }else if(arr[i]==']'){
                int temp = s_num.pop();
                StringBuilder str = s_str.pop();
                for(int j=0;j<temp;j++){
                    str.append(res);
                }
                res = str;
            }
            i++;
        }
        return res.toString();
    }
}
```



### [3.Leetcode820 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)

单词数组 words 的 有效编码 由任意助记字符串 s 和下标数组 indices 组成，且满足：

words.length == indices.length
助记字符串 s 以 '#' 字符结尾
对于每个下标 indices[i] ，s 的一个从 indices[i] 开始、到下一个 '#' 字符结束（但不包括 '#'）的 子字符串 恰好与 words[i] 相等
给你一个单词数组 words ，返回成功对 words 进行编码的最小助记字符串 s 的长度 。

 

示例 1：

输入：words = ["time", "me", "bell"]
输出：10
解释：一组有效编码为 s = "time#bell#" 和 indices = [0, 2, 5] 。
words[0] = "time" ，s 开始于 indices[0] = 0 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[1] = "me" ，s 开始于 indices[1] = 2 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"
words[2] = "bell" ，s 开始于 indices[2] = 5 到下一个 '#' 结束的子字符串，如加粗部分所示 "time#bell#"

```java
class Solution {
    public int minimumLengthEncoding(String[] words) {
        HashSet<String> hashset = new HashSet<>(Arrays.asList(words));
        // 开始遍历
        for(String word:words){
            for(int i=1;i<word.length();i++){
                hashset.remove(word.substring(i));
            }
        }
        // 开始统计
        int len = 0;
        for(String word:hashset){
            len += word.length()+1;
        }
        return len;
    }
}
```

### [4.NC压缩算法](https://www.nowcoder.com/questionTerminal/c27561e5b7e0441493adb9a54071888d?orderByHotValue=1&page=1&onlyReference=false)

小Q想要给他的朋友发送一个神秘字符串，但是他发现字符串的过于长了，于是小Q发明了一种压缩算法对字符串中重复的部分进行了压缩，对于字符串中连续的m个相同字符串S将会压缩为[m|S](m为一个整数且1<=m<=100)，例如字符串ABCABCABC将会被压缩为[3|ABC]，现在小Q的同学收到了小Q发送过来的字符串，你能帮助他进行解压缩么？ 

**输入描述:**

```
输入第一行包含一个字符串s，代表压缩后的字符串。
S的长度<=1000;
S仅包含大写字母、[、]、|;
解压后的字符串长度不超过100000;
压缩递归层数不超过10层;
```

**输出描述:**

```
输出一个字符串，代表解压后的字符串。
```

示例1

**输入**

```
HG[3|B[2|CA]]F
```

**输出**

```
HGBCACABCACABCACAF
```

**说明**

```
HG[3|B[2|CA]]F−>HG[3|BCACA]F−>HGBCACABCACABCACAF
```

```java
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String next = scanner.next();
        scanner.close();
        System.out.println(decode(next));
    }
 
    public static String decode(String words){
        while (words.contains("]")){
            int right = words.indexOf("]");
            int left = words.lastIndexOf("[", right);
            String repeatStr = words.substring(left+1, right);
            String[] split = repeatStr.split("\\|");
            words = words.replace("["+repeatStr+"]",
                    String.join("", Collections.nCopies(Integer.parseInt(split[0]), split[1])));
        }
        return words;
    }
```

### [Leetcode089格雷编码](https://leetcode-cn.com/problems/gray-code/)

格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。

给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。

格雷编码序列必须以 0 开头。

 

示例 1:

输入: 2
输出: [0,1,3,2]
解释:
00 - 0
01 - 1
11 - 3
10 - 2

对于给定的 n，其格雷编码序列并不唯一。
例如，[0,2,3,1] 也是一个有效的格雷编码序列。

00 - 0
10 - 2
11 - 3
01 - 1

```java
class Solution {
    public List<Integer> grayCode(int n) {
        /**
        关键是搞清楚格雷编码的生成过程, G(i) = i ^ (i/2);
        如 n = 3: 
        G(0) = 000, 
        G(1) = 1 ^ 0 = 001 ^ 000 = 001
        G(2) = 2 ^ 1 = 010 ^ 001 = 011 
        G(3) = 3 ^ 1 = 011 ^ 001 = 010
        G(4) = 4 ^ 2 = 100 ^ 010 = 110
        G(5) = 5 ^ 2 = 101 ^ 010 = 111
        G(6) = 6 ^ 3 = 110 ^ 011 = 101
        G(7) = 7 ^ 3 = 111 ^ 011 = 100
        **/
        List<Integer> ret = new ArrayList<>();
        for(int i = 0; i < 1<<n; ++i)
            ret.add(i ^ i>>1);
        return ret;
    }
}
```







## 二分查找

### [NC105 二分查找-II查找左边界](https://www.nowcoder.com/practice/4f470d1d3b734f8aaf2afb014185b395?tpId=188&&tqId=38588&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

请实现有重复数字的升序数组的二分查找

给定一个 元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的第一个出现的target，如果目标值存在返回下标，否则返回 -1

**示例1**

输入：

```
[1,2,4,4,5],4
```

复制

返回值：

```
2
```

复制

说明：

```
从左到右，查找到第1个为4的，下标为2，返回2   
```

**示例2**

输入：

```
[1,2,4,4,5],3
```

复制

返回值：

```
-1
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 如果目标值存在返回下标，否则返回 -1
     * @param nums int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] nums, int target) {
        // write code here
        return binarySearchLeft(nums,target);
    }
    // 找左边界
    public int binarySearchLeft(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]>target){
                r = mid - 1;
            }else if(nums[mid]<target){
                l = mid + 1;
            }else if(nums[mid]==target){
                r = mid - 1;
            }   
        }
        if(l>=nums.length || nums[l]!=target){
            return -1;
        }
        return l;
    }
}
```

### 

### [1.排序数组搜索值- Leetcode035搜索插入的位置](https://leetcode-cn.com/problems/search-insert-position/)

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例 1:

输入: [1,3,5,6], 5
输出: 2

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        // 二分查找
        return binarySearch(nums,target);
    }

    // 二分
    public int binarySearch(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
                l = mid+1;
            }
        }
        // 返回按顺序插入的位置
        return l;
    }
}
```

### [2.排序数组搜索值-Leetcode034 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？


示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]

```java
class Solution {
    // 查找左边界和右边界
    public int[] searchRange(int[] nums, int target) {
        if(nums==null||nums.length==0){
            return new int[]{-1,-1};
        }
        int l = binarySearchLeft(nums,target);
        int r = binarySearchRight(nums,target);
        return new int[]{l,r};
    }
    // 查找左边界
    public int binarySearchLeft(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left+((right-left)>>1);
            if(nums[mid]==target){
                right = mid-1;
            }else if(nums[mid]<target){
                left = mid+1;
            }else if(nums[mid]>target){
                right = mid-1;
            }
        }
        // 判断
        if(left>=nums.length||nums[left]!=target){
            return -1;
        }
        return left;
    }
    // 查找右边界
    public int binarySearchRight(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left + ((right-left)>>1);
            if(nums[mid]==target){
                left = mid+1;
            }else if(nums[mid]>target){
                right = mid-1;
            }else if(nums[mid]<target){
                left = mid+1;
            }
        }
        if(right<0|| nums[right]!=target){
            return -1;
        }
        return right;
    }
}
```



### [3.旋转数组搜索值-Leetcode189旋转数组](https://leetcode-cn.com/problems/rotate-array/)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        // 三步走
        k = k%nums.length;
        reverse(nums,0,nums.length-1);
        reverse(nums,0,k-1);
        reverse(nums,k,nums.length-1);
    }
    // 反转
    public void reverse(int[] nums,int l,int r){
        while(l<=r){
            int temp = nums[l];
            nums[l] = nums[r];
            nums[r] = temp;
            l++;
            r--;
        }
    }
}
```

### [4.旋转数组最小值-Leetcode153寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

 

示例 1：

输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。

> 解题思路：多次旋转+排序数组+找最小值
>
> 注意：比较的移动以及if的比较

```java
class Solution {
    public int findMin(int[] nums) {
        return binarySearch(nums);
    }
    // 查找
    public int binarySearch(int[] nums){
        int l = 0;
        int r = nums.length-1;
        int mid = 0;
        while(l<=r){
            mid = l+((r-l)>>1);
            // 开始比较
            if(nums[mid]>=nums[r]){
                l = mid+1;
            }else if(nums[mid]<nums[r]){
                // 注意注意注意！！！
                r = mid;
            }
        }
        // 返回
        return nums[mid];
    }
}
```

### [5.旋转数组最小值-Leetcode154 寻找旋转排序数组中的最小值II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

 

示例 1：

输入：nums = [1,3,5]
输出：1

> 解题思路：相比较上题目，有重复的元素

```java
class Solution {
    public int findMin(int[] nums) {
        return binarySearch(nums);
    }
    // 二分查找
    public int binarySearch(int[] nums){
        int l = 0;
        int r = nums.length-1;
        int mid = 0;
        while(l<=r){
            mid = l+((r-l)>>1);
            if(nums[mid]>nums[r]){
                l = mid+1;
            }else if(nums[mid]<nums[r]){
                r = mid;
            }else if(nums[mid]==nums[r]){
                // 有重复的元素
                r--;
            }
        }
        return nums[mid];
    }
}
```



### [6.旋转数组搜索值-Leetcode033搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

 

示例 1：

输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4

> 解题思路：旋转数组搜索这个值的下标；
>
> 旋转一次；无重复值

```java
class Solution {
    public int search(int[] nums, int target) {
        return binarySearch(nums,target);
    }
    // 开始二分
    public int binarySearch(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            int mid = left + ((right-left)>>1);
            // 找到了
            if(nums[mid]==target){
                return mid;
            }

            // 开始查看哪边有序
            if(nums[mid]>=nums[left]){
                // 左边有序
                if(nums[left]<=target&&target<nums[mid]){
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }else if(nums[mid]<nums[left]){
                // 右边有序
                if(nums[mid]<target&&target<=nums[right]){
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }
        }
        return -1;
    }
}
```

### [7.旋转数组搜索值-Leetcode81 搜索旋转排序数组II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)


已知存在一个按非降序排列的整数数组 `nums` ，数组中的值不必互不相同。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转** ，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,4,4,5,6,6,7]` 在下标 `5` 处经旋转后可能变为 `[4,5,6,6,7,0,1,2,4,4]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 `nums` 中存在这个目标值 `target` ，则返回 `true` ，否则返回 `false` 。

 

**示例 1：**

```
输入：nums = [2,5,6,0,0,1,2], target = 0
输出：true
```

> 解题思路：
>
> 相比较上题目，不同点在于数组中有重复元素

```java
class Solution {
    public boolean search(int[] nums, int target) {
        return binarySearch(nums,target);
    }
    // 二分查找
    public boolean binarySearch(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            //去重
            while(left+1<=right&&nums[left]==nums[left+1]){
                left++;
            }
            while(right-1>=left&&nums[right]==nums[right-1]){
                right--;
            }

            int mid = left + ((right-left)>>1);
            // 找到了
            if(nums[mid]==target){
                return true;
            }
            // 在哪里找
            if(nums[mid]>=nums[left]){
                // 左边有序
                if(nums[left]<=target&&target<nums[mid]){
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }else{
                // 右边有序
                if(nums[mid]<target&&target<=nums[right]){
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }
        }
        return false;
    }
}
```

### [8.旋转数组搜索值-Leetcode10.03 搜索旋转数组](https://leetcode-cn.com/problems/search-rotate-array-lcci/)

搜索旋转数组。给定一个排序后的数组，包含n个整数，但这个数组已被旋转过很多次了，次数不详。请编写代码找出数组中的某个元素，假设数组元素原先是按升序排列的。若有多个相同元素，返回索引值最小的一个。

示例1:

 输入: arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 5
 输出: 8（元素5在该数组中的索引）
示例2:

 输入：arr = [15, 16, 19, 20, 25, 1, 3, 4, 5, 7, 10, 14], target = 11
 输出：-1 （没有找到）

> 解题思路：有多个相同元素，且返回索引值最小的那个，且旋转多次。

```java
class Solution {
    public int search(int[] arr, int target) {
        return binarySearch(arr,target);
    }
    // 二分查找
    public int binarySearch(int[] nums,int target){
        int left = 0;
        int right = nums.length-1;
        while(left<=right){
            if(nums[left]==target){
                return left;
            }
            int mid = left+((right-left)>>1);
            // 开始比较
            if(nums[mid]==target){
                right = mid;
            }else if(nums[mid]>nums[left]){
                // 左边有序
                if(nums[left]<=target&&target<nums[mid]){
                    right = mid-1;
                }else{
                    left = mid+1;
                }
            }else if(nums[mid]<nums[left]){
                // 右边有序
                if(nums[mid]<target&&target<=nums[right]){
                    left = mid+1;
                }else{
                    right = mid-1;
                }
            }else if(nums[mid]==nums[left]){
                left++;
            }
        }
        return -1;
    }
}
```



## 数学应用

### Leetcode162 寻找峰值

峰值元素是指其值大于左右相邻值的元素。

给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

 

示例 1：

输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
示例 2：

输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。

```java
class Solution {
    public int findPeakElement(int[] nums) {
        
        // 二分查找
        int l = 0;
        int r = nums.length-1;
        while(l<r){
            int mid = l + ((r-l)>>1);
            if(nums[mid]>nums[mid+1]){
                r= mid;
            }else{
                l = mid + 1;
            }
        }
        return l;
    }
}
```



### [Leetcode10正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

**描述**

请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串"aaa"与模式"a.a"和"ab*ac*a"匹配，但是与"aa.a"和"ab*a"均不匹配

**示例1**

输入：

```
"aaa","a*a"
```

复制

返回值：

```
true
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param str string字符串 
     * @param pattern string字符串 
     * @return bool布尔型
     */
    public boolean match (String s, String p) {
        // write code here
        int slen=s.length();
        int plen=p.length();
        if(slen==0&&plen==0)return true;
        //if(slen==0||plen==0)return false;

        boolean[][] dp=new boolean[slen+1][plen+1];
        //dp[i][j]表示s的0到i-1和p的0到j-1是否匹配
        dp[0][0]=true;
        //初始化s=0
        for(int j=1;j<=plen;j++){
            //当s为空时，a*b*c*可以匹配
            //当判断到下标j-1是*，j-2是b，b对应f，要看之前的能否匹配
            //比如a*b*下标依次为ftft，b之前的位t，所以j-1也是true
            //即dp[0][j]对应的下标j-1位true
            if(j==1)dp[0][j]=false;
            if(p.charAt(j-1)=='*'&&dp[0][j-2])dp[0][j]=true;
        }

        //for循环当s长度为1时能否匹配，一直到s长度为slen
        for(int i=1;i<=slen;i++){
            for(int j=1;j<=plen;j++){
                //最简单的两种情况   字符相等或者p的字符是‘.'
                if(s.charAt(i-1)==p.charAt(j-1)||p.charAt(j-1)=='.'){
                    dp[i][j]=dp[i-1][j-1];
                }
                //p当前字符是*时，要判断*前边一个字符和s当前字符   
                
                else if(p.charAt(j-1)=='*'){
                    if(j<2)dp[i][j]=false;
                     //如果p的*前边字符和s当前字符相等或者p的字符是‘.'
                     //三种可能
                     //匹配0个，比如aa aaa*也就是没有*和*之前的字符也可以匹配上（在你（a*）没来之前我们(aa)已经能匹配上了）dp[i][j]=dp[i][j-2]
                     //匹配1个，比如aab aab* 也就是*和*之前一个字符只匹配s串的当前一个字符就不看*号了  即 dp[i][j]=dp[i][j-1]
                     //匹配多个，比如aabb aab*  b*匹配了bb两个b  那么看aab 和aab*是否能匹配上就行了，即dp[i][j]=dp[i-1][j]
                     if(p.charAt(j-2)==s.charAt(i-1)||p.charAt(j-2)=='.'){
                        dp[i][j]=dp[i-1][j]||dp[i][j-1]||dp[i][j-2];
                    }
                    //如果p的*前边字符和s当前字符不相等或者p的字符不是‘.'，那就把*和*前边一个字符都不要了呗
                    //你会发现不管是这种情况还是上边的情况都会有dp[i][j]=dp[i][j-2];所以可以把下边剪枝，不用分开写了
                    //这里分开写是为了好理解
                    else if(p.charAt(j-2)!=s.charAt(i-1)&&p.charAt(j-2)!='.'){
                        dp[i][j]=dp[i][j-2];
                    }
                }
                //其他情况肯定不能匹配上了  直接false  比如 aba abb*c  
                else{
                    dp[i][j]=false;
                }
            }
        }
        return dp[slen][plen];
    }
}
```

### [Leetcode44通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

**描述**

请实现支持'?'and'*'.的通配符模式匹配

> '?' 可以匹配任何单个字符。
> '*' 可以匹配任何字符序列（包括空序列）。

返回两个字符串是否匹配

函数声明为：

bool isMatch(const char *s, const char *p)

下面给出一些样例：

> isMatch("aa","a") → false
> isMatch("aa","aa") → true
> isMatch("aaa","aa") → false
> isMatch("aa", "*") → true
> isMatch("aa", "a*") → true
> isMatch("ab", "?*") → true
> isMatch("aab", "d*a*b") → false

```java
public class Solution {
    public boolean isMatch(String s, String p) {
        int sn = s.length();
        int pn = p.length();
        int i = 0;
        int j = 0;
        int start = -1;
        int match = 0;
        while (i < sn) {
            if (j < pn && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '?')) {
                i++;
                j++;
            } else if (j < pn && p.charAt(j) == '*') {
                start = j;
                match = i;
                j++;
            } else if (start != -1) {
                j = start + 1;
                match++;
                i = match;
            } else {
                return false;
            }
        }
        while (j < pn) {
            if (p.charAt(j) != '*') return false;
            j++;
        }
        return true;
    }
}
```



### Leetcode69 x的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

输入: 4
输出: 2
示例 2:

输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。

```java
class Solution {
    public int mySqrt(int x) {
        if(x==0||x==1){
            return x;
        }
        // 二分查找
        return binarySearch(x);
    }
    // 二分查找
    public int binarySearch(int x){
        double left = 0;
        double right = x;
        double mid = left + (right-left)/2;
        while(Math.abs(mid*mid-x)>(Math.pow(10,-6))){
            mid = left + (right-left)/2;
            if(mid*mid>x){
                right = mid;
            }else if(mid*mid<x){
                left = mid;
            }
        } 
        return (int)mid;

    }
}
```

```java
class Solution {
    public int mySqrt(int x) {
        // 牛顿迭代法
        long n = x;
        while(n*n>x){
            n = (n+x/n)/2;
        }
        return (int)n;
    }
}
```

### 9.[应用-Pow(x,n)](https://leetcode-cn.com/problems/powx-n/)

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。

 

示例 1：

输入：x = 2.00000, n = 10
输出：1024.00000
示例 2：

输入：x = 2.10000, n = 3
输出：9.26100
示例 3：

输入：x = 2.00000, n = -2
输出：0.25000
解释：2-2 = 1/22 = 1/4 = 0.25

> 解题思路：快速幂

```java
class Solution {
    public double myPow(double x, int n) {
        // 快速幂
        long pow = n;
        if(n<0){
            pow = -1*pow;
            x = 1/x;
        }
        // 开始记录
        double res = 1;
        while(pow>0){
            if(pow%2==1){
                res *= x;
            }
            pow = pow/2;
            x = x*x;
        }
        return res;
    }
}
```

### [10.Leetcode1095 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/)

（这是一个 交互式问题 ）

给你一个 山脉数组 mountainArr，请你返回能够使得 mountainArr.get(index) 等于 target 最小 的下标 index 值。

如果不存在这样的下标 index，就请返回 -1。

 

何为山脉数组？如果数组 A 是一个山脉数组的话，那它满足如下条件：

首先，A.length >= 3

其次，在 0 < i < A.length - 1 条件下，存在 i 使得：

A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[A.length - 1]


你将 不能直接访问该山脉数组，必须通过 MountainArray 接口来获取数据：

MountainArray.get(k) - 会返回数组中索引为k 的元素（下标从 0 开始）
MountainArray.length() - 会返回该数组的长度

```java
/**
 * // This is MountainArray's API interface.
 * // You should not implement it, or speculate about its implementation
 * interface MountainArray {
 *     public int get(int index) {}
 *     public int length() {}
 * }
 */
 
class Solution {
    public int findInMountainArray(int target, MountainArray mountainArr) {
        int n  = mountainArr.length();
        // 1.扎到山顶的索引
        int peek = findPeek(0,n-1,mountainArr);    
        // 左边查找
        int leftRes = binarySearchLeft(target,0,peek,mountainArr);
        if(leftRes!=-1){
            return leftRes;
        }
        int rightRes = binarySearchRight(target,peek+1,n-1,mountainArr);
        return rightRes;
    }

    // 先找到山顶的索引
    public int findPeek(int left,int right,MountainArray mountainArr){
        while(left<right){
            int mid = left + ((right-left)>>1);
            if(mountainArr.get(mid)<mountainArr.get(mid+1)){
                left = mid + 1;
            }else{
                right = mid;
            }
        }
        return left;
    }

    public int binarySearchLeft(int target,int left,int right,MountainArray mountainArr){
        while(left<=right){
            int mid = left + ((right-left)>>1);
            if(target==mountainArr.get(mid)){
                return mid;
            }else if(target<mountainArr.get(mid)){
                right = mid-1;
            }else{
                left = mid + 1;
            }
        }
        return -1;
    }

    public int binarySearchRight(int target,int left,int right,MountainArray mountainArr){
        while(left<=right){
            int mid = left + ((right-left)>>1);
            if(target==mountainArr.get(mid)){
                return mid;
            }else if(target<mountainArr.get(mid)){
                left = mid+1;
            }else{
                right = mid-1;
            }
        }
        return -1;
    }

}
```



### 

## 位运算(可以用hashset或者hashmap来实现)

### [1.Leetcode136 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

输入: [2,2,1]
输出: 1
示例 2:

输入: [4,1,2,1,2]
输出: 4

> 解题思路：用异或运算

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for(int num:nums){
            res ^= num;
        }
        return res;
    }
}
```

### [1.Leetcode442 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)


给定一个整数数组 a，其中1 ≤ a[i] ≤ *n* （*n*为数组长度）, 其中有些元素出现**两次**而其他元素出现**一次**。

找到所有出现**两次**的元素。

你可以不用到任何额外空间并在O(*n*)时间复杂度内解决这个问题吗？

**示例：**

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

> 解题思路：可以在输入数组中用数字的正负来表示该位置所对应数字是否已经出现过。**遍历输入数组，给对应位置的数字取相反数，如果已经是负数，说明前面已经出现过，直接放入输出数组。**

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> res = new ArrayList<>();
        for(int i=0;i<nums.length;i++){
            int num = Math.abs(nums[i]);
            if(nums[num-1]>0){
                nums[num-1] *= -1;
            }else{
                res.add(num);
            }
        }
        return res;
    }
}
```



### [2.Leetcode137 只出现一次的数字II](https://leetcode-cn.com/problems/single-number-ii/)

给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。

 

示例 1：

输入：nums = [2,2,3,2]
输出：3
示例 2：

输入：nums = [0,1,0,1,0,1,99]
输出：99

```java
class Solution {
    public int singleNumber(int[] nums) {
        Map<Integer, Integer> freq = new HashMap<Integer, Integer>();
        for (int num : nums) {
            freq.put(num, freq.getOrDefault(num, 0) + 1);
        }
        int ans = 0;
        for (Map.Entry<Integer, Integer> entry : freq.entrySet()) {
            int num = entry.getKey(), occ = entry.getValue();
            if (occ == 1) {
                ans = num;
                break;
            }
        }
        return ans;
    }
}


```



```java
class Solution {
    public int singleNumber(int[] nums) {
        int ans = 0;
        for (int i = 0; i < 32; ++i) {
            int total = 0;
            for (int num: nums) {
                total += ((num >> i) & 1);
            }
            if (total % 3 != 0) {
                ans |= (1 << i);
            }
        }
        return ans;
    }
}

```

### [3.Leetcode260 只出现一次的数字III](https://leetcode-cn.com/problems/single-number-iii/)

给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。

 

进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？

 

示例 1：

输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
示例 2：

输入：nums = [-1,0]
输出：[-1,0]
示例 3：

输入：nums = [0,1]
输出：[1,0]

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        int ret = 0;
        for (int n : nums) {
            ret ^= n;
        }
        int div = 1;
        while ((div & ret) == 0) {
            div <<= 1;
        }
        int a = 0, b = 0;
        for (int n : nums) {
            if ((div & n) != 0) {
                a ^= n;
            } else {
                b ^= n;
            }
        }
        return new int[]{a, b};
    }
}

```



```java
class Solution {
    public int[] singleNumber(int[] nums) {
        HashMap<Integer, Integer> temp = new HashMap<>();
        for (int e : nums)
        {
            int count = temp.getOrDefault(e, 0) + 1;
            temp.put(e, count);
        }
        int[] result = new int[2];
        int i = 0;
        for (Map.Entry<Integer, Integer> entry : temp.entrySet())
        {
            if (entry.getValue() == 1)
            {
                result[i] = entry.getKey();
                i++;
            }
        }
        return result;
    }
}


```



## 栈和队列

### [NC9A0 包含min函数的栈](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=188&&tqId=38626&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数，并且调用 min函数、push函数 及 pop函数 的时间复杂度都是 O(1)

push(value):将value压入栈中

pop():弹出栈顶元素

top():获取栈顶元素

min():获取栈中最小元素

示例:

输入:  ["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]

输出:  -1,2,1,-1

解析:

"PSH-1"表示将-1压入栈中，栈中元素为-1

"PSH2"表示将2压入栈中，栈中元素为2，-1

“MIN”表示获取此时栈中最小元素==>返回-1

"TOP"表示获取栈顶元素==>返回2

"POP"表示弹出栈顶元素，弹出2，栈中元素为-1

"PSH-1"表示将1压入栈中，栈中元素为1，-1

"TOP"表示获取栈顶元素==>返回1

“MIN”表示获取此时栈中最小元素==>返回-1

**示例1**

输入：

```
 ["PSH-1","PSH2","MIN","TOP","POP","PSH1","TOP","MIN"]
```

复制

返回值：

```
-1,2,1,-1
```

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> s_min = new Stack<>();
    Stack<Integer> s_num = new Stack<>();
    
    public void push(int node) {
        s_num.push(node);
        if(s_min.isEmpty() || s_min.peek()>node){
            s_min.push(node);
        }else{
            s_min.push(s_min.peek());
        }
    }
    
    public void pop() {
        s_num.pop();
        s_min.pop();
    }
    
    public int top() {
        return s_num.peek();
    }
    
    public int min() {
        return s_min.peek();
    }
}
```

### 

### 0.设计简单的栈数据结构

请编写一个类来实现栈这样一种数据结构，实现如下能力：

- 压入数据；
- 弹出数据；
- 获取数据结构的长度

```java
package com.lcz.tencent_01;

public class MyStack {
	static final int default_capacity = 16;
	int[] data;
	int head;
	int size;
	
	/**
	 * 初始化
	 */
	public MyStack() {
		data = new int[default_capacity];
		head = 0;
		size = 0;
	}
	public MyStack(int n) {
		data = new int[n];
		head = 0;
		size = 0;
	}
	/**
	 * 入栈
	 * @param x
	 */
	public void push(int x) {
		// 判断是否栈满了
		if(isFull()) {
			//待处理
			resize();
		}
		data[head+size] = x;
		size++;
	}
	/**
	 * 出栈
	 * @return
	 */
	public int pop() {
		if(isEmpty()) {
			return -1;
		}
		int x = data[head+size-1];
		size--;
		return x;
	}
	/**
	 * 是否为空
	 * @return
	 */
	public boolean isEmpty() {
		return size==0;
	}
	/**
	 * 是否满了
	 */
	public boolean isFull() {
		return size==data.length;
	}
	/**
	 * 栈满了进行扩容
	 */
	public void resize() {
		// 扩容两倍
		int size = data.length>>1;
		int[] new_data = new int[size];
		// 开始复制
		for(int i=0;i<data.length;i++) {
			new_data[i] = data[i];
		}
		// 重新赋值
		data = new_data;
	}
}

```



### [1.Leetcode232 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

```java
class MyQueue {
    Stack<Integer> s1;
    Stack<Integer> s2;
    /** Initialize your data structure here. */
    public MyQueue() {
         s1 = new Stack<>();
         s2 = new Stack<>();
    }
    
    /** Push element x to the back of queue. */
    //将元素x推到队列的末尾
    public void push(int x) {
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    // 从队列的开头移除并返回元素
    public int pop() {
        if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }
        return s2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
         if(s2.isEmpty()){
            while(!s1.isEmpty()){
                s2.push(s1.pop());
            }
        }
        return s2.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s1.isEmpty()&&s2.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

### [2.Leetcode225 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

```java
class MyStack {
    Queue<Integer> q_in;
    Queue<Integer> q_out;
    /** Initialize your data structure here. */
    public MyStack() {
        q_in = new LinkedList<>();
        q_out = new LinkedList<>();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        // 保持in为空
        q_in.offer(x);
        while(!q_out.isEmpty()){
            q_in.offer(q_out.poll());
        }
        // 交换
        Queue temp = q_in;
        q_in = q_out;
        q_out = temp;
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        return q_out.poll();
    }
    
    /** Get the top element. */
    public int top() {
        return q_out.peek();
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q_out.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



### [3.Leetcode155 最小栈](https://leetcode-cn.com/problems/min-stack/)

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

push(x) —— 将元素 x 推入栈中。
pop() —— 删除栈顶的元素。
top() —— 获取栈顶元素。
getMin() —— 检索栈中的最小元素。

```java
class MinStack {
    // 最小栈
    Stack<Integer> s_data;
    Stack<Integer> s_min;
    /** initialize your data structure here. */
    public MinStack() {
        s_data = new Stack<>();
        s_min = new Stack<>();
    }   
    
    public void push(int val) {
        s_data.push(val);
        // 判断
        if(s_min.isEmpty()||s_min.peek()>val){
            s_min.push(val);
        }else{
            s_min.push(s_min.peek());
        }
    }
    
    public void pop() {
        s_min.pop();
        s_data.pop();
    }
    
    public int top() {
        return s_data.peek();
    }
    
    public int getMin() {
        return s_min.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### 最大栈

```java
使用辅助栈：
public class MaxStack{
    private Stack<Integer> stack;
    private Stack<Integer> helper;
    public MaxStack(){
        stack = new Stack<>();
        helper = new Stack<>();
    }
    public void push(int x) {
        if(helper.isEmpty() || helper.peek() <= x){
            helper.push(x);
        }
        stack.push(x);
    }
    public void pop(){
        if(stack.peek() == helper.peek()){
            helper.pop();
        }
        stack.pop();
    }
    public int peek(){
        if(!helper.isEmpty()){
            return stack.peek();
        }
        throw new RuntimeException("栈中元素为空");
        
    }
    public int getMax(){
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException("最大值栈中元素为空");
    }
}
用最大值标记，存入数据栈中，空间复杂度降到O(1)
public class MaxStack {
    private Stack<Integer> stack;
    public MaxStack(){
        stack = new Stack<>();
    }
    int max = Integer.MIN_VALUE;
    public void push(int x){
        if(max <= x){
            if(!stack.isEmpty()){
                stack.push(max);
            }
            max = x;
        }
        stack.push(x);
    }
    public void pop(){
        if(stack.peek() == max){
            stack.pop();
            max = stack.pop();
        }else{
            stack.pop();
        }
    }
    public int getMax(){
        return max;
    }
}
```

### 链表实现一个栈

```java
public class ListNode{
    int val;
    ListNode next;
    ListNode(int val){
        this.val =val;
    }
}
public class ListToStack{
    public ListToStack(){
        ListNode head;
    }
    public void push(int x){
        ListNode node = new ListNode(x);
        node.next = head.next;
        head.next = node;
    }
    public int pop(){
        ListNode node = head.next;
        head.next = node.next;
        node.next = null;
        return node.val;
    }
    public int peek(){
        return head.next.val;
    }
}

```



### 4.双栈排序

给定一个乱序的栈，设计算法将其升序排列。

ps: 允许额外使用一个栈来辅助操作

> 输入
> [4, 2, 1, 3]
> 输出
> [1, 2, 3, 4]

可以这么做：**维护辅助栈为单调递增栈。**

简单说，就是保证“倒腾”过程的任何时候，辅助栈的元素都是从小到大排序的！

经过若干次“倒腾”，便可将所有元素存至辅助栈。

由于每次“倒腾”，辅助栈都是有序的，因此最终的辅助栈就是我们要的结果。

用[4, 2, 1, 3]数组举个例子，模拟一下“倒腾”的过程。

再强调一遍，“倒腾”时要确保辅助栈是从小到大排序的！

如图，将3出栈，存至辅助栈。

![image-20210715231759761](E:/笔记/面试高频/imgs/472.png)

接着，如果将1移至辅助栈就破坏了辅助栈升序排列的约定，因此不能直接将1挪到辅助栈。

而应该如下图所示，将1存到临时变量中。

然后将辅助栈的元素弹到原始栈中，直到1可以挪到辅助栈为止。

![image-20210715231835488](E:/笔记/面试高频/imgs/473.png)

循环执行上面描述的操作，当原始栈为空时，辅助栈便满足[1, 2, 3, 4]。

```java
stack<int> stackSort(stack<int> &stk) {
    stack<int> tmp;
    while (!stk.empty()) {
        int peak = stk.top();
        stk.pop();
        while (!tmp.empty() && tmp.top() > peak) {
            int t = tmp.top();
            tmp.pop();
            stk.push(t);
        }
        tmp.push(peak);
    }
    return tmp;
}
```

### 

### [5.Leetcode1047 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

 

示例：

输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

> 解题思路：删除相邻重复项栈

```java
class Solution {
    public String removeDuplicates(String s) {
        // 转为数组
        char[] arr = s.toCharArray();
        // 结果存储
        StringBuilder res = new StringBuilder();
        int index = -1;
        for(int i=0;i<arr.length;i++){
            // 判断
            if(index>=0&&arr[i]==res.charAt(index)){
                // 删除之前的字符
                res.deleteCharAt(index);
                index--;
            }else{
                //不重复
                res.append(arr[i]);
                index++;
            }
        }
        return res.toString();
    }
}
```

### [6.Leetcode消消乐问题]

问题1：消消乐，对输入的字符串例如aabbccc变换成aabb；aabbcccb->aa

```java
package com.lcz.contest.alibaba;

import java.util.Scanner;


public class Code_XXL {
  
    
    // 消消乐消除大于等于3的字母
    public static String elimate(String str) {
    	while(true) {
    		//aabbcccb
    		// 记录当前的len
    		int length = str.length();
    		// 开始处理
    		for(int i=0;i<str.length();i++) {
    			int cur = i;
    			int j = i+1;
    			// 计算相同的字符个数
    			while(j<str.length()&&str.charAt(j)==str.charAt(i)) {
    				j++;
    			}
    			// 连续的大于等于3个了
    			if(j-i>2) {
    				// 去除
    				str = str.substring(0,i)+str.substring(j);
    				// 接着处理
    				i = cur; 	
    			}  
    			// 继续判断前一个
    			
    		}
			// 结束的条件若找不到连续的大于等于3个就结束
			if(str.length()==length) {
				break;
			}
    	}
    	return str;
    }
    
    
    public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			String str = sc.next();
			System.out.println("消消乐之前的结果" +str+"消消乐之后的结果："+elimate(str));
		}
	}
}

```



### [8.Leetcode946 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/)

给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。

 

示例 1：

输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
输出：true
解释：我们可以按以下顺序执行：
push(1), push(2), push(3), push(4), pop() -> 4,
push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：

输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
输出：false
解释：1 不能在 2 之前弹出。

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        // 用栈来辅助判断
        Stack<Integer> stack = new Stack<>();
        // poped数组的下标索引
        int j = 0;
        // 对pushed数组遍历
        for(int i=0;i<pushed.length;i++){
            stack.push(pushed[i]);
            while(!stack.isEmpty()&&popped[j]==stack.peek()){
                stack.pop();
                j++;
            }
        }
        return stack.isEmpty();
    }
}
```

### [9.Leetcode_面试题03.05 栈排序](https://leetcode-cn.com/problems/sort-of-stacks-lcci/)

栈排序。 编写程序，对栈进行排序使最小元素位于栈顶。最多只能使用一个其他的临时栈存放数据，但不得将元素复制到别的数据结构（如数组）中。该栈支持如下操作：push、pop、peek 和 isEmpty。当栈为空时，peek 返回 -1。

示例1:

 输入：
["SortedStack", "push", "push", "peek", "pop", "peek"]
[[], [1], [2], [], [], []]
 输出：
[null,null,null,1,null,2]
示例2:

 输入： 
["SortedStack", "pop", "pop", "push", "pop", "isEmpty"]
[[], [], [], [1], [], []]
 输出：
[null,null,null,null,null,true]

```java
class SortedStack {
    Stack<Integer> stack_num;
    Stack<Integer> stack_assist;
    public SortedStack() {
        stack_num = new Stack<>();
        stack_assist = new Stack<>();
    }
    
    public void push(int val) {
        // 判断
        while(!stack_num.isEmpty()&&stack_num.peek()<val){
            stack_assist.push(stack_num.pop());
        }
        stack_num.push(val);
        while(!stack_assist.isEmpty()){
            stack_num.push(stack_assist.pop());
        }
    }
    
    public void pop() {
        if(stack_num.isEmpty()){
            return;
        }
        stack_num.pop();
    }
    
    public int peek() {
        if(stack_num.isEmpty()){
            return -1;
        }
        return stack_num.peek();
    }
    
    public boolean isEmpty() {
        return stack_num.isEmpty();
    }
}

/**
 * Your SortedStack object will be instantiated and called as such:
 * SortedStack obj = new SortedStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.isEmpty();
 */
```

### [10.Leetcode1472 设计游览器历史记录](https://leetcode-cn.com/problems/design-browser-history/)

你有一个只支持单个标签页的 浏览器 ，最开始你浏览的网页是 homepage ，你可以访问其他的网站 url ，也可以在浏览历史中后退 steps 步或前进 steps 步。

请你实现 BrowserHistory 类：

BrowserHistory(string homepage) ，用 homepage 初始化浏览器类。
void visit(string url) 从当前页跳转访问 url 对应的页面  。执行此操作会把浏览历史前进的记录全部删除。
string back(int steps) 在浏览历史中后退 steps 步。如果你只能在浏览历史中后退至多 x 步且 steps > x ，那么你只后退 x 步。请返回后退 至多 steps 步以后的 url 。
string forward(int steps) 在浏览历史中前进 steps 步。如果你只能在浏览历史中前进至多 x 步且 steps > x ，那么你只前进 x 步。请返回前进 至多 steps步以后的 url 。


示例：

输入：
["BrowserHistory","visit","visit","visit","back","back","forward","visit","forward","back","back"]
[["leetcode.com"],["google.com"],["facebook.com"],["youtube.com"],[1],[1],[1],["linkedin.com"],[2],[2],[7]]
输出：
[null,null,null,null,"facebook.com","google.com","facebook.com",null,"linkedin.com","google.com","leetcode.com"]

解释：
BrowserHistory browserHistory = new BrowserHistory("leetcode.com");
browserHistory.visit("google.com");       // 你原本在浏览 "leetcode.com" 。访问 "google.com"
browserHistory.visit("facebook.com");     // 你原本在浏览 "google.com" 。访问 "facebook.com"
browserHistory.visit("youtube.com");      // 你原本在浏览 "facebook.com" 。访问 "youtube.com"
browserHistory.back(1);                   // 你原本在浏览 "youtube.com" ，后退到 "facebook.com" 并返回 "facebook.com"
browserHistory.back(1);                   // 你原本在浏览 "facebook.com" ，后退到 "google.com" 并返回 "google.com"
browserHistory.forward(1);                // 你原本在浏览 "google.com" ，前进到 "facebook.com" 并返回 "facebook.com"
browserHistory.visit("linkedin.com");     // 你原本在浏览 "facebook.com" 。 访问 "linkedin.com"
browserHistory.forward(2);                // 你原本在浏览 "linkedin.com" ，你无法前进任何步数。
browserHistory.back(2);                   // 你原本在浏览 "linkedin.com" ，后退两步依次先到 "facebook.com" ，然后到 "google.com" ，并返回 "google.com"
browserHistory.back(7);                   // 你原本在浏览 "google.com"， 你只能后退一步到 "leetcode.com" ，并返回 "leetcode.com"

```java
class BrowserHistory {
    int front = -1;
    int end = -1;
    String[] history;
    public BrowserHistory(String homepage) {
        history = new String[5001];
        visit(homepage);
    }
    
    public void visit(String url) {
        history[++front] = url;
        end = front;
    }
    //返回
    public String back(int steps) {
        front -= Math.min(steps,front);
        return history[front];
    }
    //前进
    public String forward(int steps) {
        front += Math.min(steps,end-front);
        return history[front];
    }
}

/**
 * Your BrowserHistory object will be instantiated and called as such:
 * BrowserHistory obj = new BrowserHistory(homepage);
 * obj.visit(url);
 * String param_2 = obj.back(steps);
 * String param_3 = obj.forward(steps);
 */
```

### [11.Leetcode1381 设计一个支持增量操作的栈](https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/)

请你设计一个支持下述操作的栈。

实现自定义栈类 CustomStack ：

CustomStack(int maxSize)：用 maxSize 初始化对象，maxSize 是栈中最多能容纳的元素数量，栈在增长到 maxSize 之后则不支持 push 操作。
void push(int x)：如果栈还未增长到 maxSize ，就将 x 添加到栈顶。
int pop()：弹出栈顶元素，并返回栈顶的值，或栈为空时返回 -1 。
void inc(int k, int val)：栈底的 k 个元素的值都增加 val 。如果栈中元素总数小于 k ，则栈中的所有元素都增加 val 。


示例：

输入：
["CustomStack","push","push","pop","push","push","push","increment","increment","pop","pop","pop","pop"]
[[3],[1],[2],[],[2],[3],[4],[5,100],[2,100],[],[],[],[]]
输出：
[null,null,null,2,null,null,null,null,null,103,202,201,-1]
解释：
CustomStack customStack = new CustomStack(3); // 栈是空的 []
customStack.push(1);                          // 栈变为 [1]
customStack.push(2);                          // 栈变为 [1, 2]
customStack.pop();                            // 返回 2 --> 返回栈顶值 2，栈变为 [1]
customStack.push(2);                          // 栈变为 [1, 2]
customStack.push(3);                          // 栈变为 [1, 2, 3]
customStack.push(4);                          // 栈仍然是 [1, 2, 3]，不能添加其他元素使栈大小变为 4
customStack.increment(5, 100);                // 栈变为 [101, 102, 103]
customStack.increment(2, 100);                // 栈变为 [201, 202, 103]
customStack.pop();                            // 返回 103 --> 返回栈顶值 103，栈变为 [201, 202]
customStack.pop();                            // 返回 202 --> 返回栈顶值 202，栈变为 [201]
customStack.pop();                            // 返回 201 --> 返回栈顶值 201，栈变为 []
customStack.pop();                            // 返回 -1 --> 栈为空，返回 -1

```java
class CustomStack {
    // 增量操作的o(1)操作
    private int[] stack;
    private int[] incre;
    private int top;
    public CustomStack(int maxSize) {
        // 初始化
        stack = new int[maxSize];
        incre = new int[maxSize];
        top   = -1;
    }
    // 放入其值
    public void push(int x) {
        // 防止满了
        if(top==stack.length-1){
            return;
        }
        ++top;
        stack[top] = x;    
    }
    // 排出该值
    public int pop() {
        // 如果为空
        if(top==-1){
            return -1;
        }        
        int data = stack[top] + incre[top];
       if(top!=0){
            // 下一个top值防止越界
            incre[top-1] += incre[top];
       }

        incre[top] = 0;
        --top;
        return data;
    }
    // 增加
    public void increment(int k, int val) {
        // 先给top加上，k的范围
        int limit = Math.min(k-1,top);
        if(limit>=0){
            // 累加
            incre[limit] += val;
        }
    }
}

/**
 * Your CustomStack object will be instantiated and called as such:
 * CustomStack obj = new CustomStack(maxSize);
 * obj.push(x);
 * int param_2 = obj.pop();
 * obj.increment(k,val);
 */
```

### [12.Leetcode622 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。


示例：

MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4

```java
class MyCircularQueue {
    int[] arr;
    int capacity;
    int size;
    // 指针
    int head;
    public MyCircularQueue(int k) {
        arr = new int[k];
        capacity = k;
        size = 0;
        head = 0;
    }
    // 入队列
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        int index = (head+size)%capacity;
        arr[index] = value;
        size++;
        return true;
    }
    // 出队列
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        head = (head+1)%capacity;
        size--;
        return true;
    }
    // 返回头部
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        return arr[head];
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        int index = (head+size-1)%capacity;
        return arr[index];
    }
    
    public boolean isEmpty() {
        return size==0;
    }
    
    public boolean isFull() {
        return size==capacity;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```

### [13.Leetcode641 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

设计实现双端队列。
你的实现需要支持以下操作：

MyCircularDeque(k)：构造函数,双端队列的大小为k。
insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
isEmpty()：检查双端队列是否为空。
isFull()：检查双端队列是否满了。
示例：

MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4

```java
class MyCircularDeque {
    int[] elements;
    int size;
    // 双指针
    int head;
    int tail;
    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        elements = new int[k];
        size = 0;
        head = 0;
        tail = k-1;
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if(isFull()){
            return false;
        }
        // 插入新值
        elements[head=head==0?elements.length-1:head-1] = value;
        size++;
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if(isFull()){
            return false;
        }
        elements[tail=tail==elements.length-1?0:tail+1]=value;
        size++;
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if(isEmpty()){
            return false;
        }
        head = head==elements.length-1?0:head+1;
        size--;
        return true;
    }   
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if(isEmpty()){
            return false;
        }
        tail = tail==0?elements.length-1:tail-1;
        size--;
        return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if(isEmpty()){
            return -1;
        }
        return elements[head];
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if(isEmpty()){
            return -1;
        }
        return elements[tail];
    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return size==0;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return size==elements.length;
    }
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque obj = new MyCircularDeque(k);
 * boolean param_1 = obj.insertFront(value);
 * boolean param_2 = obj.insertLast(value);
 * boolean param_3 = obj.deleteFront();
 * boolean param_4 = obj.deleteLast();
 * int param_5 = obj.getFront();
 * int param_6 = obj.getRear();
 * boolean param_7 = obj.isEmpty();
 * boolean param_8 = obj.isFull();
 */
```

### [14.Leetcode1670 设计前中后队列](https://leetcode-cn.com/problems/design-front-middle-back-queue/)

请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。

请你完成 FrontMiddleBack 类：

FrontMiddleBack() 初始化队列。
void pushFront(int val) 将 val 添加到队列的 最前面 。
void pushMiddle(int val) 将 val 添加到队列的 正中间 。
void pushBack(int val) 将 val 添加到队里的 最后面 。
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：

将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。


示例 1：

输入：
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：
[null, null, null, null, null, 1, 3, 4, 2, -1]

解释：
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -> [4, 3, 2]
q.popMiddle();    // 返回 3 -> [4, 2]
q.popMiddle();    // 返回 4 -> [2]
q.popBack();      // 返回 2 -> []
q.popFront();     // 返回 -1 -> [] （队列为空）

```java
class FrontMiddleBackQueue {
    // 设计前中后队列
    List<Integer> list;
    public FrontMiddleBackQueue() {
        list = new ArrayList<>();
    }
    
    // val添加到队列的最前面
    public void pushFront(int val) {
        int index = 0;
        list.add(index,val);
    }
    // val添加队列的正中间
    public void pushMiddle(int val) {
        int index = list.size()/2;
        list.add(index,val);
    }
    // val添加到队列的最后面
    public void pushBack(int val) {
        int index = list.size();
        list.add(index,val);
    }
    // 最前面删除并返回
    public int popFront() {
        if(list.isEmpty()){
            return -1;
        }
        int index = 0;
        int val = list.get(index);
        list.remove(index);
        return val;
    }
    
    public int popMiddle() {
        if(list.isEmpty()){
            return -1;
        }
        int index = 0;
        if(list.size()%2==0){
            index = list.size()/2-1;
        }else{
            index = list.size()/2;
        }
        int val = list.get(index);
        list.remove(index);
        return val;
    }
    
    public int popBack() {
        if(list.isEmpty()){
            return -1;
        }
        int index = list.size()-1;
        int val = list.get(index);
        list.remove(index);
        return val;
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();
 */
```

### [1.Leetcode 面试题08.09 括号](https://leetcode-cn.com/problems/bracket-lcci/)

括号。设计一种算法，打印n对括号的所有合法的（例如，开闭一一对应）组合。

说明：解集不能包含重复的子集。

例如，给出 n = 3，生成结果为：

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

> 【**解题思路**】使用递归来生成括号
>
> - 若在生成过程中右括号数量大于左括号数量则终止递归，或者左括号超过限定数目`n`则终止递归
> - 若左括号等于右括号等于`n`，则添加至结果集并且终止递归

```java
class Solution {
    // 结果
    List<String> res;
    public List<String> generateParenthesis(int n) {
        res = new ArrayList<>();
        // 回溯
        dfs("",n,n);
        return res;
    }
    public void dfs(String str,int left,int right){
        // 如果左括号剩余的数量大于了
        if(left>right || left<0){
            return;
        }
        //符合条件
        if(left==0 && right==0){
            res.add(new String(str));
            return;
        }
        // 继续
        dfs(str+"(",left-1,right);
        dfs(str+")",left,right-1);
    }
}
```

### [2.Leetcode20有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。


示例 1：

输入：s = "()"
输出：true
示例 2：

输入：s = "()[]{}"
输出：true
示例 3：

输入：s = "(]"
输出：false

> 有效字符串需满足：
>
> - 左括号必须用相同类型的右括号闭合。
> - 左括号必须以正确的顺序闭合。
>
> 注意空字符串可被认为是有效字符串

```java
class Solution {
    public boolean isValid(String s) {
        //字典来解题
        Map<Character,Character> dict = new HashMap<>();
        dict.put('(',')');
        dict.put('{','}');
        dict.put('[',']');
        // 继续
        Stack<Character> stack = new Stack<>();
        // 继续
        char[] arr = s.toCharArray();
        for(int i=0;i<arr.length;i++){
            if(dict.containsKey(arr[i])){
                //入栈
                stack.push(arr[i]);
            }else{
                if(stack.isEmpty()||arr[i]!=dict.get(stack.peek())){
                    return false;
                }
                stack.pop();
            }
        }
        return stack.isEmpty();
    }
}
```

### [3.Leetcode32 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)


给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

 

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

【解题思路】使用栈保存左括号下标，栈初始化为（-1）

对于左括号，入栈对应下标
对于右括号，出栈一个下标（表示出栈下标对应的左括号对应当前右括号）

- 若栈为空，则说明不能构成有效括号，入栈当前下标（已遍历最右端不能构成有效括号的下标）
- 若栈不为空，则说明出栈下标对应为有效括号，更新res = Math.max(res, i - stack.peek())

```java
class Solution {
    public int longestValidParentheses(String s) {
        char[] arr = s.toCharArray();
        int len = arr.length;
        // 栈
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        // 将结果
        int res = 0;
        for(int i=0;i<arr.length;i++){
            if(arr[i]=='('){
                stack.push(i);
            }else{
                //右括号
                stack.pop();
                //判断为空则更新
                if(stack.isEmpty()){
                    stack.push(i);
                }else{
                    //不为空则记录
                    res = Math.max(res,i-stack.peek());
                }
            }
        }
        return res;
    }
}
```

###  [4.Leetcode678 有效的括号字符串](https://leetcode-cn.com/problems/valid-parenthesis-string/)

给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：

任何左括号 ( 必须有相应的右括号 )。
任何右括号 ) 必须有相应的左括号 ( 。
左括号 ( 必须在对应的右括号之前 )。

* 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。
  一个空字符串也被视为有效字符串。
  示例 1:

输入: "()"
输出: True
示例 2:

输入: "(*)"
输出: True
示例 3:

输入: "(*))"
输出: True

【解题思路】

方法：双栈模拟，栈left保存左括号下标，栈star保存*下标，遍历字符串

- 若当前字符为（，则将下标i进栈left
- 若当前字符为*，则将其下标i进栈start*
- *若当前字符为），若left不为空，优先配对出栈；若left为空且star不为空，则star出栈（表示当前出栈的下标处*可以表示一个左括号）；若left和star均为空，则没有与其配对的，返回false

然后再来看left和star中元素，此时表示*代替右括号来配对left栈中剩余的左括号

- 若left栈顶元素大于star栈顶元素，表示*下标处于左括号下标左边，返回false
- 否则均出栈一个元素，表示配对

最后若left不为空，表示剩余左括号无法配对，返回false，若为空，返回true

```java
class Solution {
    public boolean checkValidString(String s) {
        // 两个栈模拟
        Stack<Integer> left = new Stack<Integer>();
        Stack<Integer> star = new Stack<Integer>();
        char[] arr = s.toCharArray();
        int len = arr.length;
        for(int i=0;i<len;i++){
            // 判断
            if(arr[i]=='('){
                left.push(i);
            }else if(arr[i]=='*'){
                star.push(i);
            }else{
                if(!left.isEmpty()){
                    left.pop();
                }else if(!star.isEmpty()){
                    star.pop();
                }else{
                    return false;
                }
            }
        }
        //都不为空再次判断
        while(!left.isEmpty()&&!star.isEmpty()){
            if(left.pop()>star.pop()){
                return false;
            }
        }   
        return left.isEmpty();
    }
}
```

### [5.Leetcode921 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。

从形式上讲，只有满足下面几点之一，括号字符串才是有效的：

它是一个空字符串，或者
它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者
它可以被写作 (A)，其中 A 是有效字符串。
给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。

 

示例 1：

输入："())"
输出：1
示例 2：

输入："((("
输出：3

```java
class Solution {
    public int minAddToMakeValid(String s) {
        //栈辅助
        Stack<Character> stack = new Stack<>();
        char[] arr = s.toCharArray();
        int len = arr.length;
        int op = 0;
        for(int i=0;i<len;i++){
            //判断
            if(arr[i]=='('){
                stack.push('(');
            }else{
                if(stack.isEmpty()){
                    op++;
                }else{
                    //判断
                    stack.pop();
                }
            }
        }
        return op+stack.size();
    }
}
```

### [6.Leetcode1111 有效括号的嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-two-valid-parentheses-strings/)

有效括号字符串 定义：对于每个左括号，都能找到与之对应的右括号，反之亦然。详情参见题末「有效括号字符串」部分。

嵌套深度 depth 定义：即有效括号字符串嵌套的层数，depth(A) 表示有效括号字符串 A 的嵌套深度。详情参见题末「嵌套深度」部分。

有效括号字符串类型与对应的嵌套深度计算方法如下图所示：



 

给你一个「有效括号字符串」 seq，请你将其分成两个不相交的有效括号字符串，A 和 B，并使这两个字符串的深度最小。

不相交：每个 seq[i] 只能分给 A 和 B 二者中的一个，不能既属于 A 也属于 B 。
A 或 B 中的元素在原字符串中可以不连续。
A.length + B.length = seq.length
深度最小：max(depth(A), depth(B)) 的可能取值最小。 
划分方案用一个长度为 seq.length 的答案数组 answer 表示，编码规则如下：

answer[i] = 0，seq[i] 分给 A 。
answer[i] = 1，seq[i] 分给 B 。
如果存在多个满足要求的答案，只需返回其中任意 一个 即可。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/04/01/1111.png)

示例 1：

输入：seq = "(()())"
输出：[0,1,1,1,1,0]
示例 2：

输入：seq = "()(())()"
输出：[0,0,0,1,1,0,1,1]
解释：本示例答案不唯一。
按此输出 A = "()()", B = "()()", max(depth(A), depth(B)) = 1，它们的深度最小。
像 [1,1,1,0,0,1,1,1]，也是正确结果，其中 A = "()()()", B = "()", max(depth(A), depth(B)) = 1 。 

```java
class Solution {
    public int[] maxDepthAfterSplit(String seq) {
        char[] arr = seq.toCharArray();
        int len = arr.length;
        // 结果
        int[] res = new int[len];
        // 辅助
        int d = 0;
        // 继续
        for(int i=0;i<len;i++){
            //判断
            if(arr[i]=='('){
                ++d;
                res[i] = d%2;
            }else{
                res[i] = d%2;
                --d;
            }
        }
        return res;
    }
}
```

### [Leetcode1614 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)

如果字符串满足以下条件之一，则可以称之为 有效括号字符串（valid parentheses string，可以简写为 VPS）：

字符串是一个空字符串 ""，或者是一个不为 "(" 或 ")" 的单字符。
字符串可以写为 AB（A 与 B 字符串连接），其中 A 和 B 都是 有效括号字符串 。
字符串可以写为 (A)，其中 A 是一个 有效括号字符串 。
类似地，可以定义任何有效括号字符串 S 的 嵌套深度 depth(S)：

depth("") = 0
depth(C) = 0，其中 C 是单个字符的字符串，且该字符不是 "(" 或者 ")"
depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是 有效括号字符串
depth("(" + A + ")") = 1 + depth(A)，其中 A 是一个 有效括号字符串
例如：""、"()()"、"()(()())" 都是 有效括号字符串（嵌套深度分别为 0、1、2），而 ")(" 、"(()" 都不是 有效括号字符串 。

给你一个 有效括号字符串 s，返回该字符串的 s 嵌套深度 。

 

示例 1：

输入：s = "(1+(2*3)+((8)/4))+1"
输出：3
解释：数字 8 在嵌套的 3 层括号中。
示例 2：

输入：s = "(1)+((2))+(((3)))"
输出：3
示例 3：

输入：s = "1+(2*3)/(2-1)"
输出：1

```java
class Solution {
    public int maxDepth(String s) {
        //括号的深度
        int depth = 0;
        //最大深度
        int max = 0;
        for (char c : s.toCharArray()) {
            if (c == '(') {
                //深度加1
                depth++;
                //更新最大值
                max = Math.max(depth, max);
            } else if (c == ')') {
                //深度减1
                depth--;
            }
        }
        return max;
    }
}
```

### 7.XML的嵌套深度

xml配置文件的配置项必须以"<配置项>"开始，以"</配置项>"结尾，可以嵌套，否则不合法。

请观察下面一段xml配置，abc等为配置项，合法的用程序计算嵌套深度，不合法的给出提示"invalid xml"。

如

(1) 输入：<a><b></b><c></c></a>

该xml片段最大深度：2

(2)输入：<d><f></d>

输出：invalid xml。

```java
package com.lcz.dangdang;

import java.util.Scanner;
import java.util.Stack;

public class Test2 {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		int depth = 0;
		int max = 0;
		Stack<Character> stack = new Stack<Character>();
		int i =0;
		while(i<str.length()) {
			//判断是否是开始标签
			if(str.charAt(i)=='<'&&
				i+1<str.length()&&Character.isAlphabetic(str.charAt(i+1))&&
				i+2<str.length()&&str.charAt(i+2)=='>') {
				depth++;
				max = Math.max(depth, max);
				//存储
				stack.push(str.charAt(i+1));
				i += 3;
			}else if(str.charAt(i)=='<'&&
					i+1<str.length()&&str.charAt(i+1)=='/'&&
					i+2<str.length()&&Character.isAlphabetic(str.charAt(i+2))&&
					i+3<str.length()&&str.charAt(i+3)=='>') {
				depth--;
				//再做一个判断
				if(!stack.isEmpty()&&stack.peek().equals(str.charAt(i+2))) {
					stack.pop();
				}else {
					System.out.println("invalid xml");
					return;
				}
				i += 4;
			}else {
				System.out.println("invalid xml");
				return;
			}
		}
		if(!stack.isEmpty()) {
			System.out.println("invalid xml");
			return;
		}
		System.out.println(max);
	}
}

```



### [7.Leetcode1190 反转每对括号间的子串](https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/)

给出一个字符串 s（仅含有小写英文字母和括号）。

请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。

注意，您的结果中 不应 包含任何括号。

 

示例 1：

输入：s = "(abcd)"
输出："dcba"
示例 2：

输入：s = "(u(love)i)"
输出："iloveu"
解释：先反转子字符串 "love" ，然后反转整个字符串。
示例 3：

输入：s = "(ed(et(oc))el)"
输出："leetcode"
解释：先反转子字符串 "oc" ，接着反转 "etco" ，然后反转整个字符串。

```java
class Solution {
    public String reverseParentheses(String s) {
        // 栈
        Stack<Integer> stack = new Stack<>();
        char[] arr = s.toCharArray();
        int len = arr.length;
        for(int i=0;i<len;i++){
            // 判断
            if(arr[i]=='('){
                stack.push(i);
            }else if(arr[i]==')'){
                reverse(arr,stack.pop(),i);
            }
        }
        StringBuilder res = new StringBuilder();
        for(int i=0;i<arr.length;i++){
            if(arr[i]!='('&&arr[i]!=')'){
                res.append(arr[i]);
            }
        }
        return res.toString();
    }

    //反转
    public void reverse(char[] arr,int i,int j){
        while(i<=j){
            char temp = arr[i];
            arr[i]    = arr[j];
            arr[j]    = temp;
            i++;
            j--;
        }
    }
}
```

### [Leetcode1249 移除无效的括号](https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/)

给你一个由 '('、')' 和小写字母组成的字符串 s。

你需要从字符串中删除最少数目的 '(' 或者 ')' （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。

请返回任意一个合法字符串。

有效「括号字符串」应当符合以下 任意一条 要求：

空字符串或只包含小写字母的字符串
可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」
可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」


示例 1：

输入：s = "lee(t(c)o)de)"
输出："lee(t(c)o)de"
解释："lee(t(co)de)" , "lee(t(c)ode)" 也是一个可行答案。
示例 2：

输入：s = "a)b(c)d"
输出："ab(c)d"

```java
class Solution {
    public String minRemoveToMakeValid(String s) {
        Set<Integer> indexesToRemove = new HashSet<>();
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } if (s.charAt(i) == ')') {
                if (stack.isEmpty()) {
                    indexesToRemove.add(i);
                } else {
                    stack.pop();
                }
            }
        }
        // Put any indexes remaining on stack into the set.
        while (!stack.isEmpty()) indexesToRemove.add(stack.pop());
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (!indexesToRemove.contains(i)) {
                sb.append(s.charAt(i));
            }
        }
        return sb.toString();
    }
}


```



### [牛客编程题-迷失的括号序列](https://www.nowcoder.com/questionTerminal/e7df3cc4a1534a499dcb1f6553e23799)

链接：https://www.nowcoder.com/questionTerminal/e7df3cc4a1534a499dcb1f6553e23799
来源：牛客网



牛妹有括号序列brackets，因为过了太久，导致里面有些括号看不清了，所以用???代替，她想知道这个括号序列能不能恢复成合法的括号序列。具体操作是将???改为'('或者')'。brackets只由'?','(',')'构成。

  合法的括号序列的定义： 

  1.空字符为合法括号序列
 2.(+合法括号序列+) 为合法括号序列
 3.()+合法括号序列为合法括号序列

  如果能构造出来则返回恢复后任意合法的括号序列，否则返回Impossible 


示例1

**输入**

```
"()?)"
```

**输出**

```
"()()"
```

**说明**

```
把?替换为(即可
```

```java
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param brackets string字符串 brackets
     * @return string字符串
     */
    string MissingBrackets(string brackets) {
        int left_count, right_count, n=brackets.size();
        for (int i=0;i<n;i++) {
            if (brackets[i]=='(') left_count++;
            if (brackets[i]==')') right_count++;
        }
        //从括号的个数和字符串的奇偶性判断是否可能。
        if (left_count*2>n || right_count*2>n || n%2==1) return "Impossible";
        //用need记录还需要几个左括号，而且左括号尽可能更早地出现在左边
        int need = n/2-left_count;
        for (int i=0;i<n;i++) {
            if (brackets[i]=='?') {
                if (need>0) {
                    need--;
                    brackets[i]='(';
                }
                else brackets[i]=')';
            }
        }
        //all来判断是否出现了右括号多于左括号的情况
        int all=0;
        for (int i=0;i<n;i++) {
            if (brackets[i]=='(') all++;
            if (brackets[i]==')') all--;
            //注意每次操作后都要判断一下
            if (all<0) return "Impossible";
        }
        if (all==0) return brackets;
        else return "Impossible";
    }
};
```











## 位图以及数据读写

### 1.统计不同号码个数

已知有一些文件，文件内包含一些电话号码，每个号码为8位数字，统计全部文件不同号码的个数。

备注：文件很多，总量很大，不足以一次全部读入到内存进行计算。

```java
package com.lcz.tencent_01;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class FileTest {
	// 获取数据
	public static int getData() throws IOException {
		// 使用arrayList来存储每行读取到的字符串
		int[] arr = new int[1000000000];
		// 读取一个目录下的文件
		File file = new File("D:\\000\\Leetcode刷题\\leetcode\\src\\com\\lcz\\tencent_01\\data");
		// 获取该目录下的所有文件
		File[] fileArray = file.listFiles();
		for(int i=0;i<fileArray.length;i++) {
			File filename = fileArray[i];
			// 读取该文件
			BufferedReader br = new BufferedReader(new FileReader(filename));
			// 按行获取字符串
			String str;
			while((str=br.readLine())!=null) {
				int number = Integer.valueOf(str);
				arr[number] = 1;
			}
		}
		// 最后对其进行统计
		int count = 0;
		for(int i=10000000;i<=99999999;i++) {
			if(arr[i]==1) {
				count++;
			}
		}
		return count;
	}
	
	public static void main(String[] args) {
		try {
			int number = getData();
			System.out.println(number);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}

```

### 2.代码题：Java实现bitmap，判断元素是否存在？

```java
class BitSet{
	// 常数表示存多大的数
	static final int N = 10000000;
	// 数组存储
	int[] bitMap;
	// 初始化
	public BitSet() {
		bitMap = new int[N/32+1];
	}
	//添加一个数字
	public void add(int value) {
		int index = value/32; // 位于数组bitmap中的index位置
		int offset = value%32-1; //这个int中的bit位置，offset是1移动多少位置
		// 放入
		bitMap[index] = bitMap[index] | 1<<offset;
	}
	// 判断一个数字是否存在
	public boolean isExist(int value) {
		int index = value/32;
		int offset = value%32-1;;
		boolean flag = ((bitMap[index]>>offset)&0x01)==0x01?true:false;
		return flag;
	}
	
	// 如何根据bitMap恢复原始数据
	public void reverseDigit() {
		for(int i=0;i<bitMap.length;i++) {
			int temp = bitMap[i];
			for(int j=0;j<32;j++) {
				boolean flag = ((temp>>j)&0x01)==0x01?true:false;
				if(flag) {
					int data = i*32+j+1;
				}
			}
		}
	}
}
```

### 3.Java给一个文件，输出其中每个单词输出的频次

```java
package com.lcz.thread;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

/**
 * java给定一个文件，输出其中每个单词输出的频次
 * 统计一个英文文档中各个单词出现的频率（由大到小排序），单词之间用”逗号，句号，空格隔开”,将结果输出至控制台。
 * @author LvChaoZhang
 *思路：
1、利用输入流实现对文件内容的输入；
2、将文件内容存入StringBuffer中；
3、利用String的split()方法将字符串分隔，并将其存入数组中；
4、遍历数组将其存入Map<String, Integer>中。其中，key中存放单词，value中存放key中单词出现的次数。
5、利用Collections的sort()方法对TreeMap的value进行排序(很多时候TreeMap是根据key的值来进行排序的，但是有时我们需要根据TreeMap的value来进行排序。对value排序我们就需要借助于Collections的sort(List<T> list, Comparator<? super T> c)方法，该方法根据指定比较器产生的顺序对指定列表进行排序。TreeMap默认是升序的，如果我们需要改变排序方式，则需要使用比较器：Comparator。Comparator可以对集合对象或者数组进行排序的比较器接口，实现该接口的public compare(T o1,T o2)方法即可实现排序，该方法主要是根据第一个参数o1,小于、等于或者大于o2分别返回负整数、0或者正整数。但是有一个前提条件，那就是所有的元素都必须能够根据所提供的比较器来进行比较。)

 */
public class Test24 {
	public static void main(String[] args) {
		// 文件
		File file = new File("D:\\dict.txt");
		// 读取文件
		try {
			BufferedReader br = new BufferedReader(new FileReader(file));
			// StringBuilder来存储
			StringBuilder sb = new StringBuilder();
			//按行读取
			String s;
			while((s=br.readLine())!=null) {
				sb.append(s);
			}
			// 开始处理 不区分大小写
			String str = sb.toString().toLowerCase();
			// 对字符进行分割
			String[] dict = str.split("[,.\\s+]");
			// hashmap统计频率
			Map<String,Integer> myTreeMap = new TreeMap<>();
			// 开始存放
			for(int i=0;i<dict.length;i++) {
				// 开始存放
				myTreeMap.put(dict[i], myTreeMap.getOrDefault(dict[i], 0)+1);
			}
			
			// 遍历输出结果
            System.out.println("直接遍历Map输出（无序）：");
			for(Map.Entry<String, Integer> entry:myTreeMap.entrySet()) {
				// 输出结果
				System.out.println(entry.getKey()+":"+entry.getValue());
			}
			// 对出现频率进行从排序输出
            System.out.println("对频率从大到小排序，然后输出：");
			// 框map.entrySet转为list
			List<Map.Entry<String,Integer>> list = new ArrayList<Map.Entry<String, Integer>>(myTreeMap.entrySet()); 
			// 排序
			Collections.sort(list,(entry1,entry2)->(entry2.getValue()-entry1.getValue()));
			for(Map.Entry<String, Integer> map : list) {
                System.out.println(map.getKey() + ":" + map.getValue());
            }
			

			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}

```





## 单调队列Deque

### [1.Leetcode239 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
示例 2：

输入：nums = [1], k = 1
输出：[1]

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // 滑动窗口中最大值
        Deque<Integer> queue = new LinkedList<>();
        // 结果存储
        int n =nums.length;
        int[] res = new int[n-k+1];
        // 开始
        for(int i=0;i<n;i++){
            //判断
            while(!queue.isEmpty()&&nums[i]>nums[queue.peekLast()]){
                queue.pollLast();
            }
            queue.offerLast(i);

            // 判断是否过期了
            if(queue.peekFirst()+k<=i){
                queue.pollFirst();
            }
            // 结果开始存储了
            if(i+1>=k){
                res[i+1-k] = nums[queue.peekFirst()];
            }
        }
        return res;
    }
}
```

### [Leetcode480 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

窗口位置                      中位数

---------------               -----

[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

 

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        // 1.维护一个排过序的滑动窗口数组
        // 2.使用二分查找检索删除的索引
        // 3.将需要删除的值替换为需要插入的值
        // 4.使用局部冒泡排序保证数组顺序
        int len = nums.length;
        int[] windows = new int[k];
        // 结果
        double[] res = new double[len-k+1];
        //给初始化的滑动窗口赋值
        for(int i=0;i<k;i++){
            windows[i] = nums[i];
        }
        // 对其排序
        Arrays.sort(windows);
        // 二分查找中间的值
        res[0] = getMid(windows);
        // 遍历其它的
        for(int i=0;i<len-k;i++){
            // 获取要删除的索引
            int index = binarySearch(windows,nums[i]);
            // 删除即替换
            windows[index] = nums[i+k];
            // 重新排序
            while(index<windows.length-1&&windows[index]>windows[index+1]){
                // 交换
                swap(windows,index,index+1);
                index++;
            }
            while(index>0&&windows[index]<windows[index-1]){
                swap(windows,index,index-1);
                index--;
            }
            // 重新寻找中位数
            res[i+1] = getMid(windows);
        }
        // 返回其值
        return res;
    }

    // 交换
    public void swap(int[] windows,int left,int right){
        int temp = windows[left];
        windows[left] = windows[right];
        windows[right] = temp;
    }
    // 二分查找
    public int binarySearch(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            // 判断
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
               l = mid+1; 
            }
        }
        return -1;
    }

    // 求数组的中位数
    public double getMid(int[] windows){
        int len = windows.length;
        if(len%2==0){
            // 避免溢出
            return windows[len/2]/2.0 +windows[len/2-1]/2.0;
        }else{
            return windows[len/2];
        }
    }
}
```

### [Leetcode643子数组最大平均数I](https://leetcode-cn.com/problems/maximum-average-subarray-i/)

给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。

 

示例：

输入：[1,12,-5,-6,50,3], k = 4
输出：12.75
解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75


提示：

1 <= k <= n <= 30,000。
所给数据范围 [-10,000，10,000]。

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        int n = nums.length;
        for(int i=0;i<k;i++){
            sum += nums[i];
        }
        // 最大值
        int maxSum = sum;
        for(int i=k;i<n;i++){
            sum = sum - nums[i-k]+nums[i];
            maxSum = Math.max(maxSum,sum);
        }
        return 1.0*maxSum/k;
    }
}
```

### 滑动窗口平均数最大增幅

求滑动窗口平均数最大增幅
时间限制： 3000MS
内存限制： 589824KB
题目描述：
一个自然数数组arr，有大小为k的数据滑动窗口从数组头部往数组尾部滑动，窗口每次滑动一位，窗口最后一位到达数组末尾时滑动结束。

窗口每次滑动后，窗口内k个整数的平均值相比滑动前会有一个变化幅度百分比p。



输入描述
输入数组和窗口大小k，数组和窗口大小用英文冒号分隔，数组内自然数用英文逗号分隔

输出描述
滑动开始到结束后出现的最大p值


样例输入
5,6,8,26,50,48,52,55,10,1,2,1,20,5:3
样例输出
475.00%

提示
过程如下：

滑动窗口位置                                                  窗口平均值        平均值增幅

----------------------------------       -------         --------

[5  6  8] 26  50  48  52  55  10  1  2  1  20  5          6.33 

 5 [6  8  26] 50  48  52  55  10  1  2  1  20  5          13.33                   110.53%

 5  6 [8  26  50] 48  52  55  10  1  2  1  20  5          28.00                   110.00%

 5  6  8 [26  50  48] 52  55  10  1  2  1  20  5          41.33                   47.62%

 5  6  8  26 [50  48  52] 55  10  1  2  1  20  5          50.00                   20.97%

 5  6  8  26  50 [48  52  55] 10  1  2  1  20  5          51.67                   3.33%

 5  6  8  26  50  48 [52  55  10] 1  2  1  20  5          39.00                   -24.52%

 5  6  8  26  50  48  52 [55  10  1] 2  1  20  5          22.00                   -43.59%

 5  6  8  26  50  48  52  55 [10  1  2] 1  20  5          4.33                     -80.30%

 5  6  8  26  50  48  52  55  10 [1  2  1] 20  5          1.33                     -69.23%

 5  6  8  26  50  48  52  55  10  1 [2  1  20] 5          7.67                     475.00%

 5  6  8  26  50  48  52  55  10  1  2 [1  20  5]        8.67                     13.04%

```java
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        int k = Integer.valueOf(str.split(":")[1]);
        String[] str_arr = str.split(":")[0].split(",");
        //将其转为数组
        int len = str_arr.length;
        int[] arr = new int[len];
        for(int i=0;i<len;i++){
            arr[i] = Integer.valueOf(str_arr[i]);
        }
        double sum = 0;
        for(int i=0;i<k;i++){
            sum += arr[i];
        }
        double preSum = sum;
        double maxP = 0;
        for(int i=k;i<len;i++){
            sum = sum-arr[i-k]+arr[i];
//            System.out.println(sum/k);
//            System.out.println(preSum/k);
//            System.out.println("--");
            maxP = Math.max(maxP,(( ( (sum/k)-(preSum/k))/(preSum/k)))*100);
            //更新
//            System.out.println(maxP);
//            System.out.println("--");
            preSum = sum;
        }
        System.out.println(String.format("%.2f", maxP)+"%");
        
    }
```



### [2.洛谷P1714切蛋糕]（前缀和+单调队列）

今天是小Z的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了N个相同的小块，每小块都有对应的幸运值。

小Z作为寿星，自然希望吃到的第一块蛋糕的幸运值总和最大，但小Z最多又只能吃M小块(M≤N)的蛋糕。

吃东西自然就不想思考了，于是小Z把这个任务扔给了学OI的你，请你帮他从这N小块中找出连续的k块蛋糕(k≤M)，使得其上的幸运值最大。

**输入格式**

输入文件cake.in的第一行是两个整数N,M。分别代表共有N小块蛋糕，小Z最多只能吃M小块。

第二行用空格隔开的N个整数，第i个整数Pi代表第i小块蛋糕的幸运值。

**输出格式**

输出文件cake.out只有一行，一个整数，为小Z能够得到的最大幸运值。

**输入输出样例**

**输入 #1**复制

```
5 2
1 2 3 4 5
```

**输出 #1**复制

```
9
```

**输入 #2**复制

```
6 3
1 -2 3 -4 5 -6
```

**输出 #2**复制

```
5
```

> 维护一个最小的值；在单调队列中，队首最小，队首到队尾单调递增

> 即在一段滑窗中，找子数组最大的。

```java

import java.util.*;


 class Main{
    // 主函数
public static void main(String[] args){
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    int m = sc.nextInt();
    int[] pre = new int[n];
    // 前缀数组
    for(int i=0;i<n;i++){
        pre[i] = sc.nextInt();
        if(i!=0) {
            pre[i] = pre[i] + pre[i-1];
        }
    }
    
    // 双端单调队列维护下标值
    Deque<Integer> queue = new LinkedList<>();
    int res = Integer.MIN_VALUE;
    // 滑动窗口 里面维护的一个最小的 即队首到队尾是递增的 队首是最小的
    for(int i=0;i<n;i++){
        while(!queue.isEmpty()&&pre[i]<pre[queue.getLast()]){
            // 队尾排出来
            queue.pollLast();
        }
        // 入队列
        queue.offerLast(i);
        // 控制最大值在滑窗范围内不在就排出来
        if(queue.peekFirst()+m<=i){
            queue.pollFirst();
        }
        
        // 不需要非得滑窗内记录值
        res = Math.max(res,pre[i]-pre[queue.peekFirst()]);
    }
    	// 输出结果
    	System.out.println(res);

    }
}
```

### [3.Leetcode862 和至少为K的最短子数组](https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k/)（前缀和+单调队列）


返回 `A` 的最短的非空连续子数组的**长度**，该子数组的和至少为 `K` 。

如果没有和至少为 `K` 的非空子数组，返回 `-1` 。

**示例 1：**

```
输入：A = [1], K = 1
输出：1
```

**示例 2：**

```
输入：A = [1,2], K = 4
输出：-1
```

**示例 3：**

```
输入：A = [2,-1,2], K = 3
输出：3
```

> 保证一个单调队列。
>
> 之后保证其k至少为k，之后缩短左边界记录

```java
class Solution {
    public int shortestSubarray(int[] nums, int k) {
        //前缀和结合单调队列
        int n = nums.length;
        int[] preSum = new int[n+1];
        for(int i=1;i<=n;i++){
            preSum[i] = preSum[i-1]+nums[i-1];
        }
        // 单调队列
        Deque<Integer> queue = new LinkedList<>();
        // 结果
        int res = n+1;
        for(int i=0;i<=n;i++){
            // 判断
            while(!queue.isEmpty()&&preSum[i]<=preSum[queue.peekLast()]){
                queue.pollLast();
            }
            queue.offerLast(i);
            // 找到最左边界并且使其保证至少为k的长度
            while(!queue.isEmpty()&&preSum[i]-preSum[queue.peekFirst()]>=k){
                res = Math.min(res,i-queue.pollFirst());
            }
        }
        return res == n+1?-1:res;

    }
}
```



## 单调栈

### 区间和*区间最小值的最大值是多少

挑选一个区间，区间值为区间和乘以区间内最小的数的值，求区间值最大的区间（2021.1 字节跳动-国际化-前端）
无序数组，求一个值最大的区间，区间计算方案为：区间和 * 区间最小值（2020.09 字节跳动-电商-后端）
[3,1,6,4,5,2]，对于任意子序列可以计算一个X值，X=sum(subArray) * min(subArray)，求最大X（2020.07 字节跳动-商业化-前端）

**题目分析：**

给定一个数组，要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和。

数组中的元素都是非负数。

输入两行，第一行n表示数组长度，第二行为数组序列。输出最大值。

输入
3
6 2 1
输出
36
解释：满足条件区间是[6] = 6 * 6 = 36;

**题目分析**

**方法一：暴力。**题目是找max(区间和 * 区间最小值)，而满足的区间最小值一定是数组的某个元素。因此可以枚举数组，枚举时每个元素（设为x）作为区间最小值，在x左右两侧找到第一个比x小的元素，分别记录左右边界的下标为l,r，寻找边界时计算当前区间的和。那么以x为区间最小值的最大计算区间一定是[l+1,r-1]区间和*x。整个算法的时间复杂度是O(N²)。

**方法二：单调栈。**方法一中找每个元素左右边界的复杂度是O(N)，通过单调栈的数据结构可以将其优化为O(1),因此优化后整个算法的时间复杂度可以达到O(N)。

```java
//单调栈，时间复杂度O(N)
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int N = 500000+10;
int a[N];
int dp[N];
stack<int> s;
int main()
{
    int n,res=0;
    cin >> n;
    for(int i = 0; i < n; i ++) cin >> a[i];
    //前缀和便于快速求区间和，例如求[l,r]区间和=dp[r+1]-dp[l]。l和r的取值范围是[0,n)
    for(int i = 1; i <= n; i ++) dp[i] = dp[i-1] + a[i-1]; 
    for(int i = 0; i < n; i ++) {
        while(!s.empty() && a[i] <= a[s.top()]) {
            int peak = a[s.top()];
            s.pop();
            int l = s.empty()? -1 : s.top();
            int r = i; 
            //l和r是边界，因此区间是[l+1,r-1]，其区间和dp[r+1]-dp[l]
            int dist = dp[r] - dp[l+1];
            res = max(res,peak*dist);
        }
        s.push(i);
    }
    while(!s.empty())
    {
        int peak = a[s.top()];
        s.pop();
        int l = s.empty()? -1 : s.top();
        int r = n; 
        
        int dist = dp[r] - dp[l+1];
        res = max(res,peak*dist);
    }
    cout << res << endl; 
}

```

### 

### [NC157 单调栈](https://www.nowcoder.com/practice/ae25fb47d34144a08a0f8ff67e8e7fb5?tpId=188&&tqId=38558&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定一个长度为 n*n* 的可能含有重复值的数组 arr*a**r**r* ，找到每一个 i*i* 位置左边和右边离 i*i* 位置最近且值比 arr_i*a**r**r**i* 小的位置。

请设计算法，返回一个二维数组，表示所有位置相应的信息。位置信息包括：两个数字 L*L* 和 R*R*，如果不存在，则值为 -1，下标从 0 开始。

数据范围：

1 \le n \le 10^51≤*n*≤105

-10^9 \le arr[i] \le 10^9−109≤*a**r**r*[*i*]≤109

**示例1**

输入：

```
[3,4,1,5,6,2,7]
```

复制

返回值：

```
[[-1,2],[0,2],[-1,-1],[2,5],[3,5],[2,-1],[5,-1]]
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int一维数组 
     * @return int二维数组
     */
    public int[][] foundMonotoneStack (int[] nums) {
        // write code here
        int len = nums.length;
        // 返回的数组构造
        int[][] ans = new int[len][2];
        // 用栈保存
        Stack<Integer> stack = new Stack<>();
        // 从左往右，依次进行入栈，保存从左到右的升序的值
        for(int i = 0; i < len; i++){
            // 如果栈里面的值都比其大，就pop
            while(!stack.isEmpty() && nums[stack.peek()] > nums[i]) stack.pop();
            // 栈空，说明nums[i]左边没有比他小的值
            if(stack.isEmpty()){
                ans[i][0] = -1;
            } else {
                // 如果有比他小的，那么栈中的第一个元素的值就是离他最近的
                ans[i][0] = stack.peek();
            } 
            stack.push(i);
        }
        // 思路跟上面的一样，从右往左，保存升序值
        stack.clear();
        for(int i = len - 1; i >= 0; i--){
            while(!stack.isEmpty() && nums[stack.peek()] > nums[i]) stack.pop();
            if(stack.isEmpty()){
                ans[i][1] = -1;
            } else {
                ans[i][1] = stack.peek();
            }
            stack.push(i);
        }
        return ans;
    }
}
```





```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int一维数组 
     * @return int二维数组
     */
    public int[][] foundMonotoneStack (int[] nums) {
        // write code here
        int[][] result = new int[nums.length][2];
        
        
        for(int i = 0; i < nums.length; i++){
            result[i][0] = -1;
            result[i][1] = -1; 
            int left = i, right = i;
            
            while(left >= 0){                
                if(nums[left] < nums[i]){
                    result[i][0] = left;
                    break;
                }
                left--;
            }
            
            while(right < nums.length){                
                if(nums[right] < nums[i]){
                    result[i][1] = right;
                    break;
                }
                right++;
            }            
        }
        return result;
    }
}
```

### 

### [1.Leetcode496 下一个更大的元素I](https://leetcode-cn.com/problems/next-greater-element-i/)

给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。

请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

 

示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。

```java
class Solution {
    public int[] nextGreaterElement(int[] nums1, int[] nums2) {
        // 单调栈
        Stack<Integer> stack = new Stack<>();
        // hashmap
        HashMap<Integer,Integer> dict = new HashMap<>();
        for(int i=nums2.length-1;i>=0;i--){
            while(!stack.isEmpty()&&nums2[i]>=nums2[stack.peek()]){
                stack.pop();
            }
            // 结果存储
            dict.put(nums2[i],stack.isEmpty()?-1:nums2[stack.peek()]);
            stack.push(i);
        }
        // 继续结果
        int[] res = new int[nums1.length];
        for(int i=0;i<nums1.length;i++){
            res[i] = dict.get(nums1[i]);
        }
        return res;
    }
}
```

### [2.Leetcode503 下一个更大元素II](https://leetcode-cn.com/problems/next-greater-element-ii/)

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。

> 数组改为循环的了。
>
> 不同点在于for循环以及取余求索引

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        // 单调栈
        Stack<Integer> stack =  new Stack<>();
        int n = nums.length;
        // 结果
        int[] res = new int[n];
        for(int i=2*n-1;i>=0;i--){
            while(!stack.isEmpty()&&nums[i%n]>=stack.peek()){
                stack.pop();
            }
            res[i%n] = stack.isEmpty()?-1:stack.peek();
            stack.push(nums[i%n]);
        }
        return res;
    }
}
```

### [3.Leetcode739 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        int n = temperatures.length;
        Stack<Integer> stack = new Stack<>();
        int[] res = new int[n];
        for(int i=n-1;i>=0;i--){
            while(!stack.isEmpty()&&temperatures[i]>=temperatures[stack.peek()]){
                stack.pop();
            }   
            res[i] = stack.isEmpty()?0:stack.peek()-i;
            stack.push(i);
        }
        return res;
    }
}
```



### [3.Leetcode1856 子数组最小乘积的最大值](https://leetcode-cn.com/problems/maximum-subarray-min-product/)

一个数组的 最小乘积 定义为这个数组中 最小值 乘以 数组的 和 。

比方说，数组 [3,2,5] （最小值是 2）的最小乘积为 2 * (3+2+5) = 2 * 10 = 20 。
给你一个正整数数组 nums ，请你返回 nums 任意 非空子数组 的最小乘积 的 最大值 。由于答案可能很大，请你返回答案对  109 + 7 取余 的结果。

请注意，最小乘积的最大值考虑的是取余操作 之前 的结果。题目保证最小乘积的最大值在 不取余 的情况下可以用 64 位有符号整数 保存。

子数组 定义为一个数组的 连续 部分。

 

示例 1：

输入：nums = [1,2,3,2]
输出：14
解释：最小乘积的最大值由子数组 [2,3,2] （最小值是 2）得到。
2 * (2+3+2) = 2 * 7 = 14 。

```java
class Solution {
    public int maxSumMinProduct(int[] nums) {
        //  子数组最小乘积的最大值
        long res = Long.MIN_VALUE;
        long mod = 1000000007;
        // 继续
        for(int i=0;i<nums.length;i++){
            // 临时值
            long sum = nums[i];
            int L = i;
            int R = i;
            // 开始
            while(L-1>=0&&nums[L-1]>=nums[i]){
                L--;
                sum += nums[L];
            }
            while(R+1<nums.length&&nums[R+1]>=nums[i]){
                R++;
                sum += nums[R]; 
            }

            res = Math.max(res,nums[i]*sum);
        }
        return (int)(res%mod);
    }
}
```

### [4.剑指Offer33 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

输入一个整数数组**，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。**

 

参考以下这颗二叉搜索树：

     5
    / \

   2   6
  / \
 1   3
示例 1：

输入: [1,6,3,2,5]
输出: false
示例 2：

输入: [1,3,2,6,5]
输出: true

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        //单调栈来解决二叉搜索树的后序遍历问题
        Stack<Integer> stack = new Stack<>();
        Integer preSum = Integer.MAX_VALUE;
        // 遍历
        int n = postorder.length-1;
        for(int i=n;i>=0;i--){
            //判断
            if(postorder[i]>preSum){
                return false;
            }
            // 继续判断
            while(!stack.isEmpty()&&stack.peek()>postorder[i]){
                preSum = stack.pop();
            }
            // 放进去
            stack.push(postorder[i]);
        }
        return true;
    }
}
```

## 优先级队列

### [最大堆-Leetcode1046 最后一块石头的重量](https://leetcode-cn.com/problems/last-stone-weight/)

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

 

示例：

输入：[2,7,4,1,8,1]
输出：1
解释：
先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，
再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，
接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，
最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->(b-a));
        for(int stone:stones){
            queue.offer(stone);
        }
        // 继续
        while(queue.size()>1){
            int a = queue.poll();
            int b = queue.poll();
            if(a>b){
                queue.offer(a-b);
            }
        }
        return queue.isEmpty()?0:queue.poll();
    }
}
```

### [最大堆和最小堆-Leetcode295数据流的中位数](https://leetcode-cn.com/problems/find-median-from-data-stream/)

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例：

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 

```java
class MedianFinder {
    // 两个堆
    PriorityQueue<Integer> large;
    PriorityQueue<Integer> small;
    /** initialize your data structure here. */
    public MedianFinder() {
        large = new PriorityQueue<>((a,b)->(b-a));
        small = new PriorityQueue<>((a,b)->(a-b));
    }
    //添加数据
    public void addNum(int num) {
        if(large.size()>=small.size()){
            large.offer(num);
            small.offer(large.poll());
        }else{
            small.offer(num);
            large.offer(small.poll());
        }
    }
    // 找中位数
    public double findMedian() {
        if(small.size()>large.size()){
            return small.peek();
        }
        if(small.size()<large.size()){
            return large.peek();
        }
        return (small.peek()+large.peek())/2.0;
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

### [Leetcode480 滑动窗口中位数](https://leetcode-cn.com/problems/sliding-window-median/)

中位数是有序序列最中间的那个数。如果序列的长度是偶数，则没有最中间的数；此时中位数是最中间的两个数的平均数。

例如：

[2,3,4]，中位数是 3
[2,3]，中位数是 (2 + 3) / 2 = 2.5
给你一个数组 nums，有一个长度为 k 的窗口从最左端滑动到最右端。窗口中有 k 个数，每次窗口向右移动 1 位。你的任务是找出每次窗口移动后得到的新窗口中元素的中位数，并输出由它们组成的数组。

 

示例：

给出 nums = [1,3,-1,-3,5,3,6,7]，以及 k = 3。

窗口位置                      中位数

---------------               -----

[1  3  -1] -3  5  3  6  7       1
 1 [3  -1  -3] 5  3  6  7      -1
 1  3 [-1  -3  5] 3  6  7      -1
 1  3  -1 [-3  5  3] 6  7       3
 1  3  -1  -3 [5  3  6] 7       5
 1  3  -1  -3  5 [3  6  7]      6
 因此，返回该滑动窗口的中位数数组 [1,-1,-1,3,5,6]。

 

```java
class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        // 1.维护一个排过序的滑动窗口数组
        // 2.使用二分查找检索删除的索引
        // 3.将需要删除的值替换为需要插入的值
        // 4.使用局部冒泡排序保证数组顺序
        int len = nums.length;
        int[] windows = new int[k];
        // 结果
        double[] res = new double[len-k+1];
        //给初始化的滑动窗口赋值
        for(int i=0;i<k;i++){
            windows[i] = nums[i];
        }
        // 对其排序
        Arrays.sort(windows);
        // 二分查找中间的值
        res[0] = getMid(windows);
        // 遍历其它的
        for(int i=0;i<len-k;i++){
            // 获取要删除的索引
            int index = binarySearch(windows,nums[i]);
            // 删除即替换
            windows[index] = nums[i+k];
            // 重新排序
            while(index<windows.length-1&&windows[index]>windows[index+1]){
                // 交换
                swap(windows,index,index+1);
                index++;
            }
            while(index>0&&windows[index]<windows[index-1]){
                swap(windows,index,index-1);
                index--;
            }
            // 重新寻找中位数
            res[i+1] = getMid(windows);
        }
        // 返回其值
        return res;
    }

    // 交换
    public void swap(int[] windows,int left,int right){
        int temp = windows[left];
        windows[left] = windows[right];
        windows[right] = temp;
    }
    // 二分查找
    public int binarySearch(int[] nums,int target){
        int l = 0;
        int r = nums.length-1;
        while(l<=r){
            int mid = l + ((r-l)>>1);
            // 判断
            if(nums[mid]==target){
                return mid;
            }else if(nums[mid]>target){
                r = mid-1;
            }else if(nums[mid]<target){
               l = mid+1; 
            }
        }
        return -1;
    }

    // 求数组的中位数
    public double getMid(int[] windows){
        int len = windows.length;
        if(len%2==0){
            // 避免溢出
            return windows[len/2]/2.0 +windows[len/2-1]/2.0;
        }else{
            return windows[len/2];
        }
    }
}
```

### [Leetcode239滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

 

示例 1：

输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> queue = new LinkedList<>();
        int len = nums.length;
        //注意这个
        if(len==0 || k==0){
            return new int[]{};
        }
        // 结果
        int[] res = new int[len-k+1];
        int i = 0;
        while(i<len){
            // 开始
            while(!queue.isEmpty()&&nums[i]>nums[queue.peekLast()]){
                queue.pollLast();
            }
            // 存入其值
            queue.offerLast(i);
            // 判断是否过期
            if(k+queue.peekFirst()<=i){
                queue.pollFirst();
            }
            // 结果存储
            if(i+1>=k){
                res[i+1-k] = nums[queue.peekFirst()];
            }
            i++;
        }
        return res;
    }
}
```



### [Leetcode1882 使用服务器处理任务](https://leetcode-cn.com/problems/process-tasks-using-servers/)

给你两个 下标从 0 开始 的整数数组 servers 和 tasks ，长度分别为 n 和 m 。servers[i] 是第 i 台服务器的 权重 ，而 tasks[j] 是处理第 j 项任务 所需要的时间（单位：秒）。

你正在运行一个仿真系统，在处理完所有任务后，该系统将会关闭。每台服务器只能同时处理一项任务。第 0 项任务在第 0 秒可以开始处理，相应地，第 j 项任务在第 j 秒可以开始处理。处理第 j 项任务时，你需要为它分配一台 权重最小 的空闲服务器。如果存在多台相同权重的空闲服务器，请选择 下标最小 的服务器。如果一台空闲服务器在第 t 秒分配到第 j 项任务，那么在 t + tasks[j] 时它将恢复空闲状态。

如果没有空闲服务器，则必须等待，直到出现一台空闲服务器，并 尽可能早 地处理剩余任务。 如果有多项任务等待分配，则按照 下标递增 的顺序完成分配。

如果同一时刻存在多台空闲服务器，可以同时将多项任务分别分配给它们。

构建长度为 m 的答案数组 ans ，其中 ans[j] 是第 j 项任务分配的服务器的下标。

返回答案数组 ans 。

 

示例 1：

输入：servers = [3,3,2], tasks = [1,2,3,2,1,2]
输出：[2,2,0,2,1,2]
解释：事件按时间顺序如下：

- 0 秒时，第 0 项任务加入到任务队列，使用第 2 台服务器处理到 1 秒。
- 1 秒时，第 2 台服务器空闲，第 1 项任务加入到任务队列，使用第 2 台服务器处理到 3 秒。
- 2 秒时，第 2 项任务加入到任务队列，使用第 0 台服务器处理到 5 秒。
- 3 秒时，第 2 台服务器空闲，第 3 项任务加入到任务队列，使用第 2 台服务器处理到 5 秒。
- 4 秒时，第 4 项任务加入到任务队列，使用第 1 台服务器处理到 5 秒。
- 5 秒时，所有服务器都空闲，第 5 项任务加入到任务队列，使用第 2 台服务器处理到 7 秒。

```java
class Server{
    int weight;
    int index;
    int time;
    public Server(int weight,int index,int time){
        this.weight = weight;
        this.index = index;
        this.time = time;
    }
}
// 两个优先级队列
// 一个优先级队列存储空闲的服务器，排序规则为权重，序号
// 一个优先级队列存储正在运行的服务器：排序骨子额为结束时间
class Solution {
    public int[] assignTasks(int[] servers, int[] tasks) {
        PriorityQueue<Server> active = new PriorityQueue<>((o1, o2) -> o1.weight - o2.weight == 0?o1.index-o2.index:o1.weight-o2.weight);
        PriorityQueue<Server> waste = new PriorityQueue<>((o1,o2)->(o1.time-o2.time));
        for (int i = 0; i < servers.length; i++) {
            active.add(new Server(servers[i], i, 0));
        }
        int[] res = new int[tasks.length];
        int index = 0;
        int globalTime = -1;
        while (index < res.length) {
            while (true) {
                globalTime++;
                while (!waste.isEmpty() && waste.peek().time == globalTime) {
                    active.offer(waste.poll());
                }
                if (!active.isEmpty()) {
                    break;
                } else {
                    globalTime = waste.peek().time - 1;
                }
            }
            while (!active.isEmpty() && index <= globalTime && index < res.length) {
                Server server = active.poll();
                server.time = globalTime + tasks[index];
                res[index] = server.index;
                waste.offer(server);
                index++;
            }
        }
        return res;
    }
}
```

### [Leetcode1834 单线程CPU](https://leetcode-cn.com/problems/single-threaded-cpu/)

给你一个二维数组 tasks ，用于表示 n 项从 0 到 n - 1 编号的任务。其中 tasks[i] = [enqueueTimei, processingTimei] 意味着第 i 项任务将会于 enqueueTimei 时进入任务队列，需要 processingTimei 的时长完成执行。

现有一个单线程 CPU ，同一时间只能执行 最多一项 任务，该 CPU 将会按照下述方式运行：

如果 CPU 空闲，且任务队列中没有需要执行的任务，则 CPU 保持空闲状态。
如果 CPU 空闲，但任务队列中有需要执行的任务，则 CPU 将会选择 执行时间最短 的任务开始执行。如果多个任务具有同样的最短执行时间，则选择下标最小的任务开始执行。
一旦某项任务开始执行，CPU 在 执行完整个任务 前都不会停止。
CPU 可以在完成一项任务后，立即开始执行一项新任务。
返回 CPU 处理任务的顺序。

 

示例 1：

输入：tasks = [[1,2],[2,4],[3,2],[4,1]]
输出：[0,2,3,1]
解释：事件按下述流程运行： 

- time = 1 ，任务 0 进入任务队列，可执行任务项 = {0}
- 同样在 time = 1 ，空闲状态的 CPU 开始执行任务 0 ，可执行任务项 = {}
- time = 2 ，任务 1 进入任务队列，可执行任务项 = {1}
- time = 3 ，任务 2 进入任务队列，可执行任务项 = {1, 2}
- 同样在 time = 3 ，CPU 完成任务 0 并开始执行队列中用时最短的任务 2 ，可执行任务项 = {1}
- time = 4 ，任务 3 进入任务队列，可执行任务项 = {1, 3}
- time = 5 ，CPU 完成任务 2 并开始执行队列中用时最短的任务 3 ，可执行任务项 = {1}
- time = 6 ，CPU 完成任务 3 并开始执行任务 1 ，可执行任务项 = {}
- time = 10 ，CPU 完成任务 1 并进入空闲状态
  示例 2：

输入：tasks = [[7,10],[7,12],[7,5],[7,4],[7,2]]
输出：[4,3,2,0,1]
解释：事件按下述流程运行： 

- time = 7 ，所有任务同时进入任务队列，可执行任务项  = {0,1,2,3,4}
- 同样在 time = 7 ，空闲状态的 CPU 开始执行任务 4 ，可执行任务项 = {0,1,2,3}
- time = 9 ，CPU 完成任务 4 并开始执行任务 3 ，可执行任务项 = {0,1,2}
- time = 13 ，CPU 完成任务 3 并开始执行任务 2 ，可执行任务项 = {0,1}
- time = 18 ，CPU 完成任务 2 并开始执行任务 0 ，可执行任务项 = {1}
- time = 28 ，CPU 完成任务 0 并开始执行任务 1 ，可执行任务项 = {}
- time = 40 ，CPU 完成任务 1 并进入空闲状态

> 操作系统：短作业优先

```java
class Solution {
    class Task{
        int id;
        int enqueueTime;
        int processingTime;
        
        public Task(int id, int enqueueTime, int processingTime){
            this.id = id;
            this.enqueueTime = enqueueTime;
            this.processingTime = processingTime;
        }
    }
    public int[] getOrder(int[][] tasks) {
        int len = tasks.length;
        List<Task> taskList = new ArrayList<>();
        for(int i=0; i<len; i++){
            taskList.add(new Task(i, tasks[i][0], tasks[i][1]));
        }
        //按入队时间排序
        Collections.sort(taskList, (t1,t2) -> t1.enqueueTime - t2.enqueueTime);
        //利用最小堆获取下个要执行的任务
        PriorityQueue<Task> minHeap = new PriorityQueue<>((t1,t2) -> {
            if(t1.processingTime == t2.processingTime){
                //当执行时间相同时，根据id升序
                return t1.id - t2.id;
            }else{
                //当执行时间不同时，根据执行时间升序
                return t1.processingTime - t2.processingTime;
            }
        });
        long now = 0;//当前时间，使用long防止int溢出
        int i = 0;//taskList的坐标
        int[] ret = new int[len];
        int p = 0;//ret的坐标
        while(i<len){//taskList中还有任务没有放入堆时
            //将所有入队时间<=当前时间的任务放入堆中
            while(i<len && taskList.get(i).enqueueTime<=now){
                minHeap.offer(taskList.get(i));
                i++;
            }
            //当堆中没有任务，即当前cpu空闲
            if(minHeap.isEmpty()){
                //当前时间置为任务队列taskList中入队时间最小的时间
                now = (long)taskList.get(i).enqueueTime;
                while(i<len && taskList.get(i).enqueueTime<=now){
                    minHeap.offer(taskList.get(i));
                    i++;
                }
            }
            //此时保证堆中有任务待执行，取出执行即可
            Task task = minHeap.poll();
            ret[p++] = task.id;
            now += task.processingTime;
        }
        //当任务列表taskList中的全部任务已经入堆
        while(!minHeap.isEmpty()){
            //按顺序取出任务执行即可
            ret[p++] = minHeap.poll().id;
        }
        return ret;
    }
}

```

### [5.Leetcode373 查找和最小的top k对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

给定两个以升序排列的整形数组 nums1 和 nums2, 以及一个整数 k。

定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2。

找到和最小的 k 对数字 (u1,v1), (u2,v2) ... (uk,vk)。

示例 1:

输入: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
输出: [1,2],[1,4],[1,6]
解释: 返回序列中的前 3 对数：
     [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
示例 2:

输入: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
输出: [1,1],[1,1]
解释: 返回序列中的前 2 对数：
     [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        //构建数组对
        List<List<Integer>> res = new ArrayList<>();
        // 大顶堆
        PriorityQueue<int[]> queue = new PriorityQueue<>(k,((a,b)->compare(a,b)));
        // 开始
        for(int i:nums1){
            for(int j:nums2){
                int[] arr = new int[]{i,j};
                if(k>queue.size()){
                    queue.offer(arr);
                }else if(compare(arr,queue.peek())>0){
                    queue.poll();
                    queue.offer(arr);
                }
            }
        }
        // 结果
        while(!queue.isEmpty()){
            int[] poll = queue.poll();
            res.add(0,Arrays.asList(poll[0],poll[1]));
        }
        return res;
    }
    // 定义比较函数
    private int compare(int[] arr1,int[] arr2){
        return (arr2[0]+arr2[1])-(arr1[0]+arr1[1]);
    }
}
```

### 6.两个有序数组的topK问题

给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组 

  按照降序输出 

  [要求] 

  时间复杂度为O(klog⁡k)O(k \log k)O(klogk)  

**输入描述:**

```
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
```

**输出描述:**

```
输出K个整数表示答案
```

示例1

**输入**

```
5 4
1 2 3 4 5
3 5 7 9 11
```

**输出**

```
16 15 14 14
```

```java
import java.util.*;
public class Main {
    //放入大根堆中的结构
    static class Node {
        public int index1;  //arr1中的位置
        public int index2;  //arr2中的位置
        public int sum;     //arr1[index1]+arr2[index2]
        public Node(int i1, int i2, int s) {
            index1 = i1;
            index2 = i2;
            sum = s;
        }
    }

    public static int[] topKSum(Integer[] arr1, Integer[] arr2, int topK) {
        if (arr1 == null || arr2 == null || topK < 1) {
            return null;
        }
        topK = Math.min(topK, arr1.length * arr2.length);
        int[] res = new int[topK];
        int resIndex = 0;
        //自定义比较器，实现大根堆
        PriorityQueue<Node> maxHeap = new PriorityQueue<>((N1, N2) -> N2.sum - N1.sum);
        // set[i][j] == false , arr1[i] arr2[j] 之前没进过堆
        // set[i][j] == true , arr1[i] arr2[j] 之前进过堆
        //boolean[][] set = new boolean[arr1.length][arr2.length];
        //使用hashset解决超内存问题
        HashSet<String> positionSet = new HashSet<>();
        //从右下角开始
        int i1 = arr1.length - 1;
        int i2 = arr2.length - 1;
        maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
        //set[i1][i2] = true;
        positionSet.add(i1 + "_" + i2);
        while (resIndex != topK) {
            Node curNode = maxHeap.poll();
            res[resIndex++] = curNode.sum;
            i1 = curNode.index1;
            i2 = curNode.index2;
//            if (i1 - 1 >= 0 && set[i1 - 1][i2] == false) {
//                set[i1 - 1][i2] = true;
//                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
//            }
//            if (i2 - 1 >= 0 && set[i1][i2 - 1] == false) {
//                set[i1][i2 - 1] = true;
//                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
//            }
            if (i1 - 1 >= 0 && !positionSet.contains(i1 - 1 + "_" + i2)) {
                positionSet.add(i1 - 1 + "_" + i2);
                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
            }
            if (i2 - 1 >= 0 && !positionSet.contains(i1 + "_" + (i2 - 1))) {
                positionSet.add(i1 + "_" + (i2 - 1));
                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
            }
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        Integer[] arr1 = new Integer[n];
        Integer[] arr2 = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = in.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arr2[i] = in.nextInt();
        }
        //要将输入的两个数字排序
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        int[] res = topKSum(arr1, arr2, k);
        for (int re : res) {
            System.out.print(re + " ");
        }
    }
}
```

### [7.Leetcode1792 最大平均通过率](https://leetcode-cn.com/problems/maximum-average-pass-ratio/)

一所学校里有一些班级，每个班级里有一些学生，现在每个班都会进行一场期末考试。给你一个二维数组 classes ，其中 classes[i] = [passi, totali] ，表示你提前知道了第 i 个班级总共有 totali 个学生，其中只有 passi 个学生可以通过考试。

给你一个整数 extraStudents ，表示额外有 extraStudents 个聪明的学生，他们 一定 能通过任何班级的期末考。你需要给这 extraStudents 个学生每人都安排一个班级，使得 所有 班级的 平均 通过率 最大 。

一个班级的 通过率 等于这个班级通过考试的学生人数除以这个班级的总人数。平均通过率 是所有班级的通过率之和除以班级数目。

请你返回在安排这 extraStudents 个学生去对应班级后的 最大 平均通过率。与标准答案误差范围在 10-5 以内的结果都会视为正确结果。

 

示例 1：

输入：classes = [[1,2],[3,5],[2,2]], extraStudents = 2
输出：0.78333
解释：你可以将额外的两个学生都安排到第一个班级，平均通过率为 (3/4 + 3/5 + 2/2) / 3 = 0.78333 。

```java
class Solution {
    //优先级队列+贪心策略
    public double maxAverageRatio(int[][] classes, int extraStudents) {
        int len = classes.length;
        //定义优先级队列，优先级增加1名学生之后能够产生的最大贡献来排序
        PriorityQueue<double[]> queue = new PriorityQueue<>( (o1,o2)->{
            double x = ( (o2[0]+1) / (o2[1]+1) - o2[0]/o2[1] );
            double y = ( (o1[0]+1) / (o1[1]+1) - o1[0]/o1[1] );
            if(x>y)return 1;
            if(x<y)return -1;;
            return 0;
        }   );
        //转换为double方便小数计算
        for(int[] c:classes){
            queue.offer(new double[]{c[0],c[1]});
        }
        //分配学生，每次分配1名
        while(extraStudents>0){
            //取出能够产生最大影响的班级
            double[] maxClasses = queue.poll();;
            //通过的人数
            maxClasses[0] += 1.0;
            maxClasses[1] += 1.0;
            //将更新后的重新加入队列中
            queue.offer(maxClasses);
            extraStudents--;
        }
        //计算最终结果
        double res = 0;
        while(!queue.isEmpty()){
            double[] c= queue.poll();
            res += (c[0]/c[1]);
        }
        return res/len;

    }
}
```



## 前缀和

### [1.Leetcode724寻找数组的中心索引](https://leetcode-cn.com/problems/find-pivot-index/)

给你一个整数数组 nums，请编写一个能够返回数组 “中心下标” 的方法。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心下标，返回 -1 。如果数组有多个中心下标，应该返回最靠近左边的那一个。

注意：中心下标可能出现在数组的两端。

 

示例 1：

输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 (1 + 7 + 3 = 11)，
右侧数之和 (5 + 6 = 11) ，二者相等。

```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        for(int num:nums){
            sum += num;
        }
        int leftSum = 0;
        for(int i=0;i<nums.length;i++){
            if(leftSum==sum-leftSum-nums[i]){
                return i;
            }
            leftSum += nums[i];
        }
        return -1;
    }
}
```

### [2.Leetcode560 和为K的连续子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :

输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。

> hashmap来得到和为k的连续子数组

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        // 用hashmap
        HashMap<Integer,Integer> dict = new HashMap<>();
        dict.put(0,1);
        // 继续
        int preSum = 0;
        // 计数
        int count = 0;
        for(int i=0;i<nums.length;i++){
            preSum += nums[i];
            if(dict.containsKey(preSum-k)){
                count += dict.get(preSum-k);
            }
            dict.put(preSum,dict.getOrDefault(preSum,0)+1);
        }
        return count;
    }
}
```

### [3.Leetcode1248 统计优美子数组](https://leetcode-cn.com/problems/count-number-of-nice-subarrays/)

给你一个整数数组 nums 和一个整数 k。

如果某个 连续 子数组中恰好有 k 个奇数数字，我们就认为这个子数组是「优美子数组」。

请返回这个数组中「优美子数组」的数目。

 

示例 1：

输入：nums = [1,1,2,1,1], k = 3
输出：2
解释：包含 3 个奇数的子数组是 [1,1,2,1] 和 [1,2,1,1] 。
示例 2：

输入：nums = [2,4,6], k = 1
输出：0
解释：数列中不包含任何奇数，所以不存在优美子数组。

> 前缀和+hashmap

```java
class Solution {
    public int numberOfSubarrays(int[] nums, int k) {
        HashMap<Integer,Integer> dict = new HashMap<>();
        dict.put(0,1);
        // 统计
        int oddSum = 0;
        // 计数
        int count = 0;
        for(int i=0;i<nums.length;i++){
            oddSum += nums[i] & 1;
            if(dict.containsKey(oddSum-k)){
                count += dict.get(oddSum-k);
            }
            dict.put(oddSum,dict.getOrDefault(oddSum,0)+1);
        }
        return count;
    }
}
```

### [4.Leetcode523 连续的子数组和](https://leetcode-cn.com/problems/continuous-subarray-sum/)

给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：

子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。

如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

 

示例 1：

输入：nums = [23,2,4,6,7], k = 6
输出：true
解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。
示例 2：

输入：nums = [23,2,6,4,7], k = 6
输出：true
解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 
42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。

```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = 0;

        // key：区间 [0..i] 里所有元素的和 % k
        // value：下标 i
        Map<Integer, Integer> map = new HashMap<>();
        // 理解初始化的意义
        map.put(0, -1);
        int len = nums.length;
        for (int i = 0; i < len; i++) {
            sum += nums[i];
            if (k != 0) {
                sum = sum % k;
            }
            
            if (map.containsKey(sum)) {
                if (i - map.get(sum) > 1) {
                    return true;
                }
            } else {
                map.put(sum, i);
            }

        }
        return false;

    }
}
```

## 哈希表与排序

### [1.Leetcode001 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：

输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：

输入：nums = [3,3], target = 6
输出：[0,1]

> 哈希表

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        //两数之和
        HashMap<Integer,Integer> dict = new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(!dict.isEmpty()&&dict.containsKey(target-nums[i])){
                int prev = dict.get(target-nums[i]);
                int cur = i;
                return new int[]{prev,cur};
            }
            dict.put(nums[i],i);
        }
        return new int[]{-1,-1};
    }
}
```

### [2.Leetcode167 两数之和II-输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

给定一个已按照 升序排列  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 <= answer[0] < answer[1] <= numbers.length 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。


示例 1：

输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
示例 2：

输入：numbers = [2,3,4], target = 6
输出：[1,3]
示例 3：

输入：numbers = [-1,0], target = -1
输出：[1,2]

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        // 有序数组用双指针
        int left = 0 ;
        int right = numbers.length-1;
        while(left<=right){
            //临时值
            int sum = numbers[left] + numbers[right];
            if(sum==target){
                return new int[]{left+1,right+1};
            }else if(sum>target){
                right--;
            }else if(sum<target){
                left++;
            }
        }
        return new int[]{0,0};
    }
}
```

### [3.Leetcode015 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

 

示例 1：

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
示例 2：

输入：nums = []
输出：[]
示例 3：

输入：nums = [0]
输出：[]

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        //结果存储
        List<List<Integer>> res = new ArrayList<>();
        if(nums.length<3){
            return res;
        }
        // 继续
        Arrays.sort(nums);
        for(int i=0;i<nums.length-2;i++){
            int left = i+1;
            int right = nums.length-1;
            // 去重
            if(i!=0&&nums[i]==nums[i-1]){
                continue;
            }
            // 继续
            while(left<right){
                int sum = nums[i] + nums[left] + nums[right];
                if(sum==0){
                    List<Integer> temp = new ArrayList<>();
                    temp.add(nums[i]);
                    temp.add(nums[left]);
                    temp.add(nums[right]);
                    res.add(new ArrayList<>(temp));
                    while(left<right&&nums[left+1]==nums[left]){
                        left++;
                    }
                    left++;
                    while(left<right&&nums[right-1]==nums[right]){
                        right--;
                    }
                    right--;
                }else if(sum>0){
                    right--;
                }else{
                    left++;
                }
            }
        }
        return res;
    }
}
```

### [4.Leetcode018 四数之和](https://leetcode-cn.com/problems/4sum/)

给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

注意：答案中不可以包含重复的四元组。

 

示例 1：

输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
示例 2：

输入：nums = [], target = 0
输出：[]

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        // 结果存储
        HashSet res = new HashSet<>();
        if(nums.length<4){
            return new ArrayList<>(res);
        }
        Arrays.sort(nums);
        for(int i=0;i<nums.length-3;i++){
            for(int j=i+1;j<nums.length-2;j++){
                int left = j+1;
                int right = nums.length-1;
                // 剪枝
                if(nums[i]+nums[j]+nums[j+1]+nums[j+2]>target){
                    break;
                }
                if(nums[i]+nums[j]+nums[nums.length-1]+nums[nums.length-2]<target){
                    continue;
                }
                while(left<right){
                    int cur = nums[i]+nums[j]+nums[left]+nums[right];
                    if(cur==target){
                        List<Integer> temp = new ArrayList<>();
                        temp.add(nums[i]);
                        temp.add(nums[j]);
                        temp.add(nums[left]);
                        temp.add(nums[right]);
                        res.add(temp);
                        left++;
                        right--;
                    }else if(cur>target){
                        right--;
                    }else if(cur<target){
                        left++;
                    }
                }
            }
        }
        return new ArrayList<>(res);
    }
}
```

### [5.Leetcode016 最接近的三数之和](https://leetcode-cn.com/problems/3sum-closest/)

给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。

 

示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。

> 三数和的临时值都是在while中计算



```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        Arrays.sort(nums);
        // 结果
        int closeSum = nums[0]+nums[1]+nums[2];
        for(int i=0;i<nums.length-2;i++){
            int left = i+1;
            int right = nums.length-1;
            while(left<right){
                int curSum = nums[i] + nums[left] + nums[right]; 
                //判断
                if(Math.abs(curSum-target)<Math.abs(closeSum-target)){
                    closeSum = curSum;
                }
                // 继续
                if(curSum==target){
                    return curSum;
                }else if(curSum>target){
                    right--;
                }else if(curSum<target){
                    left++;
                }
            }
        }
        return closeSum;
    }
}
```

### [6.Leetcode611 有效三角形的个数](https://leetcode-cn.com/problems/valid-triangle-number/)

给定一个包含非负整数的数组，你的任务是统计其中可以组成三角形三条边的三元组个数。

示例 1:

输入: [2,2,3,4]
输出: 3
解释:
有效的组合是: 
2,3,4 (使用第一个 2)
2,3,4 (使用第二个 2)
2,2,3

```java
class Solution {
    public int triangleNumber(int[] nums) {
        // 结果
        int res = 0;
        // 排序
        Arrays.sort(nums);
        for(int i=2;i<nums.length;i++){
            int left = 0;
            int right = i-1;
            // 开始
            while(left<right){
                //判断
                if(nums[left]+nums[right]>nums[i]){
                    res += (right-left);
                    right--;
                }else if(nums[left]+nums[right]<=nums[i]){
                    left++;
                }
            }
        }
        return res;
    }
}
```

### [7.Leetcode976 三角形的最大周长](https://leetcode-cn.com/problems/largest-perimeter-triangle/)

给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。

如果不能形成任何面积不为零的三角形，返回 0。

 

示例 1：

输入：[2,1,2]
输出：5
示例 2：

输入：[1,2,1]
输出：0
示例 3：

输入：[3,2,3,4]
输出：10
示例 4：

输入：[3,6,2,3]
输出：8

```java
class Solution {
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        for(int i=nums.length-1;i>=2;i--){
            int left = i-1;
            int right = i-2;
            if(nums[left]+nums[right]>nums[i]){
                return nums[left]+nums[right]+nums[i];
            }
        }
        return 0;
    }
}
```



## 设计类

### Leetcode295 数据流的中位数

中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。

例如，

[2,3,4] 的中位数是 3

[2,3] 的中位数是 (2 + 3) / 2 = 2.5

设计一个支持以下两种操作的数据结构：

void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。
示例：

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3) 
findMedian() -> 2

```java
class MedianFinder {
    //中位数
    PriorityQueue<Integer> small;
    PriorityQueue<Integer> big; 
    /** initialize your data structure here. */
    public MedianFinder() {
        small = new PriorityQueue<>((a,b)->(b-a));
        big   = new PriorityQueue<>((a,b)->(a-b)); 
    }
    
    public void addNum(int num) {
        if(small.size()>big.size()){
            small.offer(num);
            big.offer(small.poll());
        }else{
            big.offer(num);
            small.offer(big.poll());
        }
    }
    
    public double findMedian() {
        if(small.size()>big.size()){
            return small.peek();
        }else if(small.size()<big.size()){
            return big.peek();
        }else{
            return (small.peek()+big.peek())/2.0;
        }
    }
}

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```



### 剑指Offer59-II队列的最大值

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]

```java
class MaxQueue {
    // 单调队列的
    Queue<Integer> queue_num;
    Deque<Integer> queue_max;
    public MaxQueue() {
        queue_num = new LinkedList<>();
        queue_max = new LinkedList<>();
    }
    
    public int max_value() {
        if(queue_max.isEmpty()){
            return -1;
        }
        return queue_max.peekFirst();
    }
    
    public void push_back(int value) {
        queue_num.offer(value);
        while(!queue_max.isEmpty()&&queue_max.peekLast()<value){
            queue_max.pollLast();
        }
        queue_max.offerLast(value);
    }
    
    public int pop_front() {
        if(queue_num.isEmpty()){
            return -1;
        }
        int res = queue_num.poll();
        if(res==queue_max.peekFirst()){
            queue_max.pollFirst();
        }
        return res;
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```



### [设计一个单调栈](https://blog.csdn.net/weixin_40374341/article/details/100055210?utm_term=%E5%8D%95%E8%B0%83%E6%A0%88%E7%BB%93%E6%9E%84&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-2-100055210&spm=3001.4430)

```java
import java.util.*;

public class Main {
	// 核心代码
	public static int[][] getNearLessNoRepeat(int[] arr) {
		ArrayDeque<Integer> stack = new ArrayDeque<>();
		int[][] res = new int[arr.length][2];
		for (int i = 0; i < arr.length; i++) {
			while (!stack.isEmpty() && arr[i] < arr[stack.peek()]) {
				int top = stack.pop();
				int leftIdx = stack.isEmpty() ? -1 : stack.peek();
			    res[top][0] = leftIdx;
                res[top][1] = i;
			}
			stack.push(i);
		}
		while (!stack.isEmpty()) {
			int top = stack.pop();
            int leftIdx = stack.isEmpty() ? -1 : stack.peek();
			res[top][0] = leftIdx;
            res[top][1] = -1;
		}
		return res;
	}

	// for test
	public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
		int[][] res = getNearLessNoRepeat(arr);

		for (int i = 0; i < res.length; i++) {
			System.out.println(res[i][0] + " " + res[i][1]);
		}
	}
}

```

### [双栈排序]





给定一个int[] **numbers**(C++中为vector&ltint>)，其中第一个元素为栈顶，请编写程序将栈进行升序排列（即最大元素位于栈顶），返回排序后的栈。要求最多使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。并注意这是一个栈，意味着排序过程中只能访问到最后一个元素。 

  测试样例： 

```
[1,2,3,4,5]
返回：[5,4,3,2,1]
```



```java


import java.util.*;

public class TwoStacks {
    public ArrayList<Integer> twoStacksSort(int[] numbers) {

        ArrayList<Integer> list = new ArrayList<Integer>();

        //构建栈，并初始化栈
        Stack<Integer> initStack = new Stack<>();
        for (int i = 0 ; i < numbers.length; i++){
            initStack.push(numbers[i]);
        }

        //构建辅助栈,用来存放排好序的数
        Stack<Integer> tempStack = new Stack<>();
        while(!initStack.isEmpty()){

            if (tempStack.isEmpty()){
                tempStack.push(initStack.pop());
            }else {
                //新建变量，存储原始栈中待排序的栈
                int tmp = initStack.pop();

                //将辅助栈中的排好序中的大于tmp的数放入原始栈中
                while (!tempStack.isEmpty() && tempStack.peek() > tmp){
                    initStack.push(tempStack.pop());
                }
                //辅助栈存储之前保存的变量
                tempStack.push(tmp);

            }


        }

        while(!tempStack.isEmpty()){
            list.add(tempStack.pop());
        }

        return list;
    }
}
```

### [栈和排序](https://www.nowcoder.com/questionTerminal/b10a7ac681e9429e89a6a510e5799647)



给你一个1->n的排列和一个栈，入栈顺序给定 

 你要在不打乱入栈顺序的情况下，对数组进行从大到小排序 

 当无法完全排序时，请输出字典序最大的出栈序列 

**输入描述:**

```
第一行一个数n
第二行n个数，表示入栈的顺序，用空格隔开，结尾无空格
```

**输出描述:**

```
输出一行n个数表示答案，用空格隔开，结尾无空格
```

示例1

**输入**

```
5
2 1 5 3 4
```

**输出**

```
5 4 3 1 2
```

**说明**

```
2入栈；1入栈；5入栈；5出栈；3入栈；4入栈；4出栈；3出栈；1出栈；2出栈
```

```java
public int[] solve (int[] a) {
        int n=a.length;
        Stack<Integer>stack=new Stack<>();
        int[]dp=new int[n];
        dp[n-1]=a[n-1];
        for(int i=n-2;i>=0;i--)
            dp[i]=Math.max(dp[i+1],a[i]);  //用一个数组记录第i个及之后最大元素
        int[]res=new int[n];
        int j=0;
        for(int i=0;i<n;i++){
            stack.push(a[i]);
            while(!stack.isEmpty()&&i<n-1&&stack.peek()>=dp[i+1]) 
                res[j++]=stack.pop();//如果栈顶元素比后面的都大，那么出栈
        }
        while(!stack.isEmpty()) res[j++]=stack.pop(); //最后在栈中的按顺序弹出
        return res;
    }
```





### [NC93 设计LRU缓存结构](https://www.nowcoder.com/practice/e3769a5f49894d49b871c09cadd13a61?tpId=188&&tqId=38550&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

设计LRU(最近最少使用)缓存结构，该结构在构造时确定大小，假设大小为K，并有如下两个功能

\1. set(key, value)：将记录(key, value)插入该结构

\2. get(key)：返回key对应的value值

提示:

1.某个key的set或get操作一旦发生，认为这个key的记录成了最常使用的，然后都会刷新缓存。

2.当缓存的大小超过K时，移除最不经常使用的记录。

3.输入一个二维数组与K，二维数组每一维有2个或者3个数字，第1个数字为opt，第2，3个数字为key，value

  若opt=1，接下来两个整数key, value，表示set(key, value)
  若opt=2，接下来一个整数key，表示get(key)，若key未出现过或已被移除，则返回-1
  对于每个opt=2，输出一个答案

4.为了方便区分缓存里key与value，下面说明的缓存里key用""号包裹

进阶:你是否可以在O(1)的时间复杂度完成set和get操作

**示例1**

输入：

```
[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3
```

复制

返回值：

```
[1,-1]
```

复制

说明：

```
[1,1,1]，第一个1表示opt=1，要set(1,1)，即将(1,1)插入缓存，缓存是{"1"=1}
[1,2,2]，第一个1表示opt=1，要set(2,2)，即将(2,2)插入缓存，缓存是{"1"=1,"2"=2}
[1,3,2]，第一个1表示opt=1，要set(3,2)，即将(3,2)插入缓存，缓存是{"1"=1,"2"=2,"3"=2}
[2,1]，第一个2表示opt=2，要get(1)，返回是[1]，因为get(1)操作，缓存更新，缓存是{"2"=2,"3"=2,"1"=1}
[1,4,4]，第一个1表示opt=1，要set(4,4)，即将(4,4)插入缓存，但是缓存已经达到最大容量3，移除最不经常使用的{"2"=2}，插入{"4"=4}，缓存是{"3"=2,"1"=1,"4"=4}
[2,2]，第一个2表示opt=2，要get(2)，查找不到，返回是[1,-1]  
```

**示例2**

输入：

```
[[1,1,1],[1,2,2],[2,1],[1,3,3],[2,2],[1,4,4],[2,1],[2,3],[2,4]],2
```

复制

返回值：

```
[1,-1,-1,3,4]
```

```java
import java.util.*;


public class Solution {
    /**
     * lru design
     * @param operators int整型二维数组 the ops
     * @param k int整型 the k
     * @return int整型一维数组
     */
    public int[] LRU (int[][] operators, int k) {
        // write code here
        Map<Integer,Integer> dict = new LinkedHashMap<>();
        List<Integer> list = new LinkedList<>();
        // 结果遍历
        for(int[] opera:operators){
            int key = opera[1];
            switch(opera[0]){
                case 1:
                    int value = opera[2];
                    if(dict.size()<k){
                        dict.put(key,value);
                    }else{
                        Iterator it = dict.keySet().iterator();
                        dict.remove(it.next());
                        dict.put(key,value);
                    }
                    break;
                case 2:
                    if(dict.containsKey(key)){
                        int val = dict.get(key);
                        list.add(val);
                        dict.remove(key);
                        dict.put(key,val);
                    }else{
                        list.add(-1);
                    }
                    break;
                default:
            }
        }
        int[] res = new int[list.size()];
        int i = 0;
        for(int val:list){
            res[i++] = val;
        }
        return res;
    }
}
```



### [剑指Offer59-II队列的最大值](https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/)

请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。

若队列为空，pop_front 和 max_value 需要返回 -1

示例 1：

输入: 
["MaxQueue","push_back","push_back","max_value","pop_front","max_value"]
[[],[1],[2],[],[],[]]
输出: [null,null,null,2,1,2]
示例 2：

输入: 
["MaxQueue","pop_front","max_value"]
[[],[],[]]
输出: [null,-1,-1]

```java
class MaxQueue {
    // 单调队列的
    Queue<Integer> queue_num;
    Deque<Integer> queue_max;
    public MaxQueue() {
        queue_num = new LinkedList<>();
        queue_max = new LinkedList<>();
    }
    
    public int max_value() {
        if(queue_max.isEmpty()){
            return -1;
        }
        return queue_max.peekFirst();
    }
    
    public void push_back(int value) {
        queue_num.offer(value);
        while(!queue_max.isEmpty()&&queue_max.peekLast()<value){
            queue_max.pollLast();
        }
        queue_max.offerLast(value);
    }
    
    public int pop_front() {
        if(queue_num.isEmpty()){
            return -1;
        }
        int res = queue_num.poll();
        if(res==queue_max.peekFirst()){
            queue_max.pollFirst();
        }
        return res;
    }
}

/**
 * Your MaxQueue object will be instantiated and called as such:
 * MaxQueue obj = new MaxQueue();
 * int param_1 = obj.max_value();
 * obj.push_back(value);
 * int param_3 = obj.pop_front();
 */
```



### [1.Leetcode146 LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。
实现 LRUCache 类：

LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。


进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？

 

示例：

输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4

> 直接继承LinkedHashMap

```java
class LRUCache extends LinkedHashMap<Integer,Integer>{
    private int capacity;
    public LRUCache(int capacity) {
        super(capacity,0.75F,true);
        this.capacity = capacity;
    }
    
    public int get(int key) {
        return super.getOrDefault(key,-1);
    }
    
    public void put(int key, int value) {
        super.put(key,value);
    }
    // 重写
    public boolean removeEldestEntry(Map.Entry<Integer,Integer> eldest){
        return this.size()>capacity;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

```JAVA
class DLNode{
    int key;
    int value;
    DLNode prev;
    DLNode next;
    public DLNode(int key,int value){
        this.key = key;
        this.value = value;
    }
    public DLNode(){

    }
}
class LRUCache {
    // 变量
    private HashMap<Integer,DLNode> dict;
    private int size;
    private int capacity;
    private DLNode head;
    private DLNode tail;

    public LRUCache(int capacity) {
        dict = new HashMap<>();
        head = new DLNode();
        tail = new DLNode();
        head.next = tail;
        tail.prev = head;
        this.size = 0;
        this.capacity = capacity;
        
    }
    // 取值
    public int get(int key) {
        DLNode node = dict.get(key);
        if(node==null){
            return -1;
        }else{
            // 更新
            moveToHead(node);
        }
        return node.value;
    }
    //放值
    public void put(int key, int value) {
        DLNode node = dict.get(key);
        // 查看是否存在
        if(node==null){
            node = new DLNode(key,value);
            // 判断此时
            if(size>=capacity){
                // 满了
                DLNode temp = removeNode();
                dict.remove(temp.key);
                size--;
            }
            // 放入
            dict.put(key,node);
            addToHead(node);
            size++;
        }else{
            // 更新其值
            node.value = value;
            // 移动其值
            moveToHead(node);
        }

    }
    // 移动结点到头结点
    public void moveToHead(DLNode node){
        deleteNode(node);
        addToHead(node);
    }
    public DLNode removeNode(){
        DLNode temp = tail.prev;
        deleteNode(temp);
        return temp;
    }
    // 删除某个结点
    public void deleteNode(DLNode node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    // 添加结点到头结点
    public void addToHead(DLNode node){
        DLNode next = head.next;

        node.prev = head;
        node.next = next;

        next.prev = node;
        head.next = node;
    }
}

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache obj = new LRUCache(capacity);
 * int param_1 = obj.get(key);
 * obj.put(key,value);
 */
```

### [2.Leetcode707 设计链表](https://leetcode-cn.com/problems/design-linked-list/)


设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。

在链表类中实现这些功能：

- get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。
- addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
- addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。
- addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

 

**示例：**

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```



```java
// 用链表实现
class LNode{
    int val;
    LNode next;
    public LNode(){

    }
    public LNode(int val){
        this.val = val;
    }

    public LNode(int val,LNode next){
        this.val = val;
        this.next = next;
    }
}
class MyLinkedList {
    LNode dummy;
    int size;
    /** Initialize your data structure here. */
    public MyLinkedList() {
        dummy = new LNode(-1);
        size = 0;
    }
    
    /** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */
    public int get(int index) {
        // 判断索引是否有效
        if(index<0 || index>=size){
            return -1;
        }
        LNode node = dummy.next;
        for(int i=0;i<index;i++){
            node = node.next;
        }
        return node.val;
    }
    
    /** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */
    public void addAtHead(int val) {
        addAtIndex(0,val);
    }
    
    /** Append a node of value val to the last element of the linked list. */
    public void addAtTail(int val) {
        addAtIndex(size,val);
    }
    
    /** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */
    public void addAtIndex(int index, int val) {
        if(index>size){
            return;
        }
        if(index<0){
            index = 0;
        }
        LNode node = dummy;
        for(int i=0;i<index;i++){
            node = node.next;
        }
        LNode newNode = new LNode(val);
        LNode next = node.next;
        // 插入
        node.next = newNode;
        newNode.next = next;
        size++;
    }
    
    /** Delete the index-th node in the linked list, if the index is valid. */
    public void deleteAtIndex(int index) {
        if(index<0 || index>=size){
            return;
        }
        LNode node = dummy;
        for(int i=0;i<index;i++){
            node = node.next;
        }
        node.next = node.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

### [3.Leetcode1670设计前中后队列](https://leetcode-cn.com/problems/design-front-middle-back-queue/)

请你设计一个队列，支持在前，中，后三个位置的 push 和 pop 操作。

请你完成 FrontMiddleBack 类：

FrontMiddleBack() 初始化队列。
void pushFront(int val) 将 val 添加到队列的 最前面 。
void pushMiddle(int val) 将 val 添加到队列的 正中间 。
void pushBack(int val) 将 val 添加到队里的 最后面 。
int popFront() 将 最前面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popMiddle() 将 正中间 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
int popBack() 将 最后面 的元素从队列中删除并返回值，如果删除之前队列为空，那么返回 -1 。
请注意当有 两个 中间位置的时候，选择靠前面的位置进行操作。比方说：

将 6 添加到 [1, 2, 3, 4, 5] 的中间位置，结果数组为 [1, 2, 6, 3, 4, 5] 。
从 [1, 2, 3, 4, 5, 6] 的中间位置弹出元素，返回 3 ，数组变为 [1, 2, 4, 5, 6] 。


示例 1：

输入：
["FrontMiddleBackQueue", "pushFront", "pushBack", "pushMiddle", "pushMiddle", "popFront", "popMiddle", "popMiddle", "popBack", "popFront"]
[[], [1], [2], [3], [4], [], [], [], [], []]
输出：
[null, null, null, null, null, 1, 3, 4, 2, -1]

解释：
FrontMiddleBackQueue q = new FrontMiddleBackQueue();
q.pushFront(1);   // [1]
q.pushBack(2);    // [1, 2]
q.pushMiddle(3);  // [1, 3, 2]
q.pushMiddle(4);  // [1, 4, 3, 2]
q.popFront();     // 返回 1 -> [4, 3, 2]
q.popMiddle();    // 返回 3 -> [4, 2]
q.popMiddle();    // 返回 4 -> [2]
q.popBack();      // 返回 2 -> []
q.popFront();     // 返回 -1 -> [] （队列为空）

```java
class FrontMiddleBackQueue {
    List<Integer> list;

    public FrontMiddleBackQueue() {
        list = new ArrayList<>();
    }
    // 将val添加到队列的最前面
    public void pushFront(int val) {
        int index = 0;
        list.add(index,val);
    }
    // 将val添加到队列的正中间
    public void pushMiddle(int val) {
        int index = list.size()/2;
        list.add(index,val);
    }
    // 将val添加到队列的最后面
    public void pushBack(int val) {
        int index = list.size();
        list.add(index,val);
    }
    // 将最前面的元素从队列中删除并返回值
    public int popFront() {
        if(list.isEmpty()){
            return -1;
        }
        int index = 0;
        int val = list.get(index);
        list.remove(index);
        return val;
    }
    
    public int popMiddle() {
        if(list.isEmpty()){
            return -1;
        }
        int index = 0;
        if(list.size()%2==0){
            index = list.size()/2-1;
        }else{
            index = list.size()/2;
        }
        int val = list.get(index);
        list.remove(index);
        return val;
    }
    
    public int popBack() {
        if(list.isEmpty()){
            return -1;
        }
        int index = list.size()-1;
        int val = list.get(index);
        list.remove(index);
        return val;
    }
}

/**
 * Your FrontMiddleBackQueue object will be instantiated and called as such:
 * FrontMiddleBackQueue obj = new FrontMiddleBackQueue();
 * obj.pushFront(val);
 * obj.pushMiddle(val);
 * obj.pushBack(val);
 * int param_4 = obj.popFront();
 * int param_5 = obj.popMiddle();
 * int param_6 = obj.popBack();
 */
```

### [4.Leetcode622 设计循环队列](https://leetcode-cn.com/problems/design-circular-queue/)

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

MyCircularQueue(k): 构造器，设置队列长度为 k 。
Front: 从队首获取元素。如果队列为空，返回 -1 。
Rear: 获取队尾元素。如果队列为空，返回 -1 。
enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。
deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。
isEmpty(): 检查循环队列是否为空。
isFull(): 检查循环队列是否已满。

示例：

MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4

```java
class MyCircularQueue {
    //  循环队列的设计
    int[] arr;
    int count;
    int capacticy;
    int headIndex;
    public MyCircularQueue(int k) {
        // 初始化
        arr = new int[k];
        count = 0;
        capacticy = k;
        headIndex = 0;
    }
    // 从循环队列中插入一个元素，成功插入则返回真
    public boolean enQueue(int value) {
        if(isFull()){
            return false;
        }
        int index = (headIndex+count)%capacticy;
        arr[index] = value;

        count++;
        return true;
    }
    
    public boolean deQueue() {
        if(isEmpty()){
            return false;
        }
        // 出队
        headIndex = (headIndex+1)%capacticy;

        count--;
        return true;
    }
    
    // 返回头元素
    public int Front() {
        if(isEmpty()){
            return -1;
        }
        return arr[headIndex];
    }
    
    public int Rear() {
        if(isEmpty()){
            return -1;
        }
        int index = (headIndex+count-1)%capacticy;
        return arr[index];
    }
    
    public boolean isEmpty() {
        return count==0;
    }
    
    public boolean isFull() {
        return count==capacticy;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```

### [5.Leetcode641 设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque/)

设计实现双端队列。
你的实现需要支持以下操作：

MyCircularDeque(k)：构造函数,双端队列的大小为k。
insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。
insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。
deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。
deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。
getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。
getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。
isEmpty()：检查双端队列是否为空。
isFull()：检查双端队列是否满了。
示例：

MyCircularDeque circularDeque = new MycircularDeque(3); // 设置容量大小为3
circularDeque.insertLast(1);			        // 返回 true
circularDeque.insertLast(2);			        // 返回 true
circularDeque.insertFront(3);			        // 返回 true
circularDeque.insertFront(4);			        // 已经满了，返回 false
circularDeque.getRear();  				// 返回 2
circularDeque.isFull();				        // 返回 true
circularDeque.deleteLast();			        // 返回 true
circularDeque.insertFront(4);			        // 返回 true
circularDeque.getFront();				// 返回 4

```java
class MyCircularDeque {
    int[] elements;
    int size;
    // 双指针
    int head;
    int tail;
    /** Initialize your data structure here. Set the size of the deque to be k. */
    public MyCircularDeque(int k) {
        elements = new int[k];
        size = 0;
        head = 0;
        tail = k-1;
    }
    
    /** Adds an item at the front of Deque. Return true if the operation is successful. */
    public boolean insertFront(int value) {
        if(isFull()){
            return false;
        }
        // 插入新值
        elements[head=head==0?elements.length-1:head-1] = value;
        size++;
        return true;
    }
    
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */
    public boolean insertLast(int value) {
        if(isFull()){
            return false;
        }
        elements[tail=tail==elements.length-1?0:tail+1]=value;
        size++;
        return true;
    }
    
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */
    public boolean deleteFront() {
        if(isEmpty()){
            return false;
        }
        head = head==elements.length-1?0:head+1;
        size--;
        return true;
    }   
    
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */
    public boolean deleteLast() {
        if(isEmpty()){
            return false;
        }
        tail = tail==0?elements.length-1:tail-1;
        size--;
        return true;
    }
    
    /** Get the front item from the deque. */
    public int getFront() {
        if(isEmpty()){
            return -1;
        }
        return elements[head];
    }
    
    /** Get the last item from the deque. */
    public int getRear() {
        if(isEmpty()){
            return -1;
        }
        return elements[tail];
    }
    
    /** Checks whether the circular deque is empty or not. */
    public boolean isEmpty() {
        return size==0;
    }
    
    /** Checks whether the circular deque is full or not. */
    public boolean isFull() {
        return size==elements.length;
    }
}

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque obj = new MyCircularDeque(k);
 * boolean param_1 = obj.insertFront(value);
 * boolean param_2 = obj.insertLast(value);
 * boolean param_3 = obj.deleteFront();
 * boolean param_4 = obj.deleteLast();
 * int param_5 = obj.getFront();
 * int param_6 = obj.getRear();
 * boolean param_7 = obj.isEmpty();
 * boolean param_8 = obj.isFull();
 */
```



### [6.Leetcode380 O(1)时间插入、删除和获取随机元素](https://leetcode-cn.com/problems/insert-delete-getrandom-o1/)


设计一个支持在*平均* 时间复杂度 **O(1)** 下，执行以下操作的数据结构。

1. `insert(val)`：当元素 val 不存在时，向集合中插入该项。
2. `remove(val)`：元素 val 存在时，从集合中移除该项。
3. `getRandom`：随机返回现有集合中的一项。每个元素应该有**相同的概率**被返回。

**示例 :**

```
// 初始化一个空的集合。
RandomizedSet randomSet = new RandomizedSet();

// 向集合中插入 1 。返回 true 表示 1 被成功地插入。
randomSet.insert(1);

// 返回 false ，表示集合中不存在 2 。
randomSet.remove(2);

// 向集合中插入 2 。返回 true 。集合现在包含 [1,2] 。
randomSet.insert(2);

// getRandom 应随机返回 1 或 2 。
randomSet.getRandom();

// 从集合中移除 1 ，返回 true 。集合现在包含 [2] 。
randomSet.remove(1);

// 2 已在集合中，所以返回 false 。
randomSet.insert(2);

// 由于 2 是集合中唯一的数字，getRandom 总是返回 2 。
randomSet.getRandom();
```

```java
class RandomizedSet {
    List<Integer> list;
    HashMap<Integer,Integer> dict;
    Random random;
    /** Initialize your data structure here. */
    public RandomizedSet() {
        // 初始化
        list = new ArrayList<>();
        dict = new HashMap<>();
        random = new Random();
    }
    
    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    public boolean insert(int val) {
        // 插入元素
        if(dict.containsKey(val)){
            return false;
        }
        // 不存在插入
        list.add(val);
        dict.put(val,list.size()-1);
        return true;
    }
    
    /** Removes a value from the set. Returns true if the set contained the specified element. */
    public boolean remove(int val) {
        // 移除元素
        if(!dict.containsKey(val)){
            return false;
        }
        // 最后一个替代之前的即可
        // 要删除元素的下标
        int index = dict.get(val);
        int lastIndexVal = list.get(list.size()-1);
        //替换
        list.set(index,lastIndexVal);
        dict.put(lastIndexVal,index);
        // 删除
        list.remove(list.size()-1);
        dict.remove(val);
        return true; 
    }
    
    /** Get a random element from the set. */
    public int getRandom() {
        return list.get(random.nextInt(list.size()));
    }
}

/**
 * Your RandomizedSet object will be instantiated and called as such:
 * RandomizedSet obj = new RandomizedSet();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

### [7.Leetcode381 O(1)时间插入、删除和获取随机元素-允许重复](https://leetcode-cn.com/problems/insert-delete-getrandom-o1-duplicates-allowed/)

设计一个支持在平均 时间复杂度 O(1) 下， 执行以下操作的数据结构。

注意: 允许出现重复元素。

insert(val)：向集合中插入元素 val。
remove(val)：当 val 存在时，从集合中移除一个 val。
getRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。
示例:

// 初始化一个空的集合。
RandomizedCollection collection = new RandomizedCollection();

// 向集合中插入 1 。返回 true 表示集合不包含 1 。
collection.insert(1);

// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。
collection.insert(1);

// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。
collection.insert(2);

// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。
collection.getRandom();

// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。
collection.remove(1);

// getRandom 应有相同概率返回 1 和 2 。
collection.getRandom();

```java
class RandomizedCollection {
    List<Integer> list;
    Map<Integer,Set<Integer>> dict;
    Random random;
    /** Initialize your data structure here. */
    public RandomizedCollection() {
        // 初始化
        list = new ArrayList<>();
        dict = new HashMap<>();
        random = new Random();

    }
    
    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */
    public boolean insert(int val) {
        list.add(val);
        Set<Integer> set = dict.getOrDefault(val,new HashSet<>());
        set.add(list.size()-1);
        dict.put(val,set);
        
        return set.size()==1;
    }
    
    /** Removes a value from the collection. Returns true if the collection contained the specified element. */
    public boolean remove(int val) {
        if(!dict.containsKey(val)){
            return false;
        }
        // 获取最后的元素
        int lastVal = list.get(list.size()-1);
        // 获取要删除元素的下标
        Set<Integer> set = dict.get(val);
        int index = set.iterator().next();
        // 数组重新设置
        list.set(index,lastVal);
        // 删除
        dict.get(val).remove(index);
        dict.get(lastVal).remove(list.size()-1);
        if(index<list.size()-1){
            dict.get(lastVal).add(index);
        }
        // 移除
        if(dict.get(val).size()==0){
            dict.remove(val);
        }
        list.remove(list.size()-1);
        return true;
    
    }
    
    /** Get a random element from the collection. */
    public int getRandom() {
        return list.get(random.nextInt(list.size()));
    }
}

/**
 * Your RandomizedCollection object will be instantiated and called as such:
 * RandomizedCollection obj = new RandomizedCollection();
 * boolean param_1 = obj.insert(val);
 * boolean param_2 = obj.remove(val);
 * int param_3 = obj.getRandom();
 */
```

### [8.Leetcode432 全O(1)的数据结构](https://leetcode-cn.com/problems/all-oone-data-structure/)

请你实现一个数据结构支持以下操作：

Inc(key) - 插入一个新的值为 1 的 key。或者使一个存在的 key 增加一，保证 key 不为空字符串。
Dec(key) - 如果这个 key 的值是 1，那么把他从数据结构中移除掉。否则使一个存在的 key 值减一。如果这个 key 不存在，这个函数不做任何事情。key 保证不为空字符串。
GetMaxKey() - 返回 key 中值最大的任意一个。如果没有元素存在，返回一个空字符串"" 。
GetMinKey() - 返回 key 中值最小的任意一个。如果没有元素存在，返回一个空字符串""。

```java
public class AllOne {
    /**
     * k-v查找节点
     */
    private final Map<String, ListNode> map = new HashMap<>();
    /**
     * key - 节点的值；
     * value - 链表中第一个值为key的节点。
     */
    private final Map<Integer, ListNode> first = new HashMap<>();
    /**
     * key - 节点的值；
     * value - 链表中最后一个值为key的节点。
     */
    private final Map<Integer, ListNode> last = new HashMap<>();

    /**
     * 链表伪头节点
     */
    private final ListNode head = new ListNode(null, 0);
    /**
     * 链表伪尾节点
     */
    private final ListNode tail = new ListNode(null, 0);

    AllOne() {
        head.next = tail;
        tail.prev = head;
    }

    private class ListNode { // 链表节点
        ListNode prev, next;
        String key;
        int val;

        public ListNode(String key, int val) {
            this.key = key;
            this.val = val;
        }
    }

    /**
     * 将节点 [insert] 插入到 n1 与 n2 之间
     */
    private void insert(ListNode n1, ListNode n2, ListNode insert) {
        n1.next = insert;
        n2.prev = insert;
        insert.prev = n1;
        insert.next = n2;
    }

    /**
     * 删除链表节点[n]
     */
    private void remove(ListNode n) {
        ListNode prev = n.prev;
        ListNode next = n.next;
        prev.next = next;
        next.prev = prev;
        n.prev = null;
        n.next = null;
    }

    /**
     * 将节点node移动到prev与next之间
     */
    private void move(ListNode node, ListNode prev, ListNode next) {
        remove(node);
        insert(prev, next, node);
    }

    /**
     * 将[node]设置为新的val值起始点
     */
    private void newFirst(int val, ListNode node) {
        first.put(val, node);
        if (!last.containsKey(val)) last.put(val, node);
    }

    /**
     * 将[node]设置为新的val值终止点
     */
    private void newLast(int val, ListNode node) {
        last.put(val, node);
        if (!first.containsKey(val)) first.put(val, node);
    }

    /**
     * Inserts a new key <Key> with value 1. Or increments an existing key by 1.
     * <p>
     * 值加一后，当前节点会往左移动。
     * 如果当前key不存在，那就把这个节点插入到链表尾部.
     */
    public void inc(String key) {
        if (!map.containsKey(key)) { // 当前key不存在，插入到链表末尾
            ListNode node = new ListNode(key, 1);
            map.put(key, node);
            insert(tail.prev, tail, node); // 插入
            if (!first.containsKey(1)) newFirst(1, node); // 更新first
            newLast(1, node); // 更新last
        } else {
            ListNode node = map.get(key); // 当前节点
            int val = node.val; // 旧值
            int newVal = val + 1; // 新值
            ListNode firstNode = first.get(val); // 链表中第一个值为val的节点
            ListNode lastNode = last.get(val); // 链表中最后一个值为val的节点

            // 1. 找位置
            node.val = newVal;
            if (firstNode == lastNode) { // 当前节点是唯一一个值为val的节点
                first.remove(val); // 没有值为val的节点了
                last.remove(val); // 没有值为val的节点了
                newLast(newVal, node); // 更新last
            } else if (node == firstNode) { // 该节点是链表中第一个值为val的节点
                // 不动
                newLast(newVal, node);
                newFirst(val, node.next);
            } else {
                if (node == lastNode) newLast(val, node.prev); // 是最后一个值val的节点
                // 这个时候，节点应该移动到链表中第一个值为val的节点之前
                move(node, firstNode.prev, firstNode);
                newLast(newVal, node);
            }
        }
    }

    /**
     * Decrements an existing key by 1. If Key's value is 1, remove it from the data structure.
     * 
     * 值减一之后，节点在链表中的位置会往右移动
     */
    public void dec(String key) {
        // 与inc类似，不过多了一个值为1删除的判断
        ListNode node = map.get(key);
        if (node == null) return;

        int val = node.val;
        int newVal = val - 1;
        ListNode firstNode = first.get(val);
        ListNode lastNode = last.get(val);

        if (val == 1) { // 值为1，删除这个节点
            if (firstNode == lastNode) { // 没有值为1的节点了
                first.remove(1);
                last.remove(1);
            } else if (node == firstNode) { // 起始值右移
                first.put(1, node.next);
            } else if (node == lastNode) { // 终结值左移
                last.put(1, node.prev);
            }
            remove(node);
            map.remove(key);
        } else {
            node.val = newVal;
            if (firstNode == lastNode) { // 唯一值为val的节点
                // 位置不变，成为newVal的首位
                first.remove(val);
                last.remove(val);
                newFirst(newVal, node);
            } else if (node == lastNode) { // 是最后一项val值的节点
                // 位置不变，成为newVal的首位，并且prev成为val的最后一位
                newFirst(newVal, node);
                newLast(val, node.prev);
            } else {
                if (node == firstNode) newFirst(val, node.next); // 是第一项val值的节点
                move(node, lastNode, lastNode.next); // 移动到lastNode之后
                newFirst(newVal, node);
            }
        }
    }

    /**
     * Returns one of the keys with maximal value.
     * 返回链表头
     */
    public String getMaxKey() {
        return head.next == tail ? "" : head.next.key;
    }

    /**
     * Returns one of the keys with Minimal value.
     * 返回链表尾
     */
    public String getMinKey() {
        return tail.prev == head ? "" : tail.prev.key;
    }
}
```

### [9.Leetcode1348 推文计数](https://leetcode-cn.com/problems/tweet-counts-per-frequency/)

请你实现一个能够支持以下两种方法的推文计数类 TweetCounts：

1. recordTweet(string tweetName, int time)

记录推文发布情况：用户 tweetName 在 time（以 秒 为单位）时刻发布了一条推文。

2. getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)

返回从开始时间 startTime（以 秒 为单位）到结束时间 endTime（以 秒 为单位）内，每 分 minute，时 hour 或者 日 day （取决于 freq）内指定用户 tweetName 发布的推文总数。
freq 的值始终为 分 minute，时 hour 或者 日 day 之一，表示获取指定用户 tweetName 发布推文次数的时间间隔。
第一个时间间隔始终从 startTime 开始，因此时间间隔为 [startTime, startTime + delta*1>,  [startTime + delta*1, startTime + delta*2>, [startTime + delta*2, startTime + delta*3>, ... , [startTime + delta*i, min(startTime + delta*(i+1), endTime + 1)>，其中 i 和 delta（取决于 freq）都是非负整数。


示例：

输入：
["TweetCounts","recordTweet","recordTweet","recordTweet","getTweetCountsPerFrequency","getTweetCountsPerFrequency","recordTweet","getTweetCountsPerFrequency"]
[[],["tweet3",0],["tweet3",60],["tweet3",10],["minute","tweet3",0,59],["minute","tweet3",0,60],["tweet3",120],["hour","tweet3",0,210]]

输出：
[null,null,null,null,[2],[2,1],null,[4]]

解释：
TweetCounts tweetCounts = new TweetCounts();
tweetCounts.recordTweet("tweet3", 0);
tweetCounts.recordTweet("tweet3", 60);
tweetCounts.recordTweet("tweet3", 10);                             // "tweet3" 发布推文的时间分别是 0, 10 和 60 。
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 59); // 返回 [2]。统计频率是每分钟（60 秒），因此只有一个有效时间间隔 [0,60> - > 2 条推文。
tweetCounts.getTweetCountsPerFrequency("minute", "tweet3", 0, 60); // 返回 [2,1]。统计频率是每分钟（60 秒），因此有两个有效时间间隔 1) [0,60> - > 2 条推文，和 2) [60,61> - > 1 条推文。 
tweetCounts.recordTweet("tweet3", 120);                            // "tweet3" 发布推文的时间分别是 0, 10, 60 和 120 。
tweetCounts.getTweetCountsPerFrequency("hour", "tweet3", 0, 210);  // 返回 [4]。统计频率是每小时（3600 秒），因此只有一个有效时间间隔 [0,211> - > 4 条推文。

```java
class TweetCounts {

    private Map<String, TreeMap<Integer, Integer>> tweetMap;

    public TweetCounts() {
        tweetMap = new HashMap<>();
    }

    public void recordTweet(String tweetName, int time) {
        TreeMap<Integer, Integer> treeMap = tweetMap.computeIfAbsent(tweetName, v -> new TreeMap<>());
        treeMap.put(time, treeMap.getOrDefault(time, 0) + 1);
    }

    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {
        List<Integer> res = new ArrayList<>();
        int interval;
        if ("minute".equals(freq)) {
            interval = 60;
        } else if ("hour".equals(freq)) {
            interval = 60 * 60;
        } else {
            interval = 60 * 60 * 24;
        }
        TreeMap<Integer, Integer> userTweets = tweetMap.get(tweetName);
        for (int time = startTime; time <= endTime; time += interval) {
            int end = Math.min(time + interval, endTime + 1);
            Map.Entry<Integer, Integer> entry = userTweets.ceilingEntry(time);
            int count = 0;
            while (entry != null && entry.getKey() < end) {
                count += entry.getValue();
                entry = userTweets.higherEntry(entry.getKey());
            }
            res.add(count);
        }
        return res;
    }
}
```

### [10.实现一个约瑟夫环](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/submissions/) 剑指Offer62 圆圈中最后剩下的数字

已知n个人(以编号1,2,3,...n分别表示)，围坐在一张圆桌周围，从编号1的开始报数，数到k的那个人出列，它的下一个又从出列的后面第一个人开始报数，数到k的那个人出列，依次重复下去，直到圆桌的人全部出列，求出列顺序。

输入：n和k

输出：出列顺序

~~~java
### 2.约瑟夫环的书写

约瑟夫环是给定 n个人，从1开始数，数到m时，m将被去掉，下一个数是重新从1开始数，直到剩下一个即可。

```java
public class Code_01 {
	// 约瑟夫环 传入n和m
	public static int ysf_func(int n,int m) {
		// 用List来存储
		LinkedList<Integer> list= new LinkedList<>();
		for(int i=0;i<n;i++) {
			// 添加人的编码1-n
			list.add(i+1);
		}
		// 第一个索引是
		int index = 0;
		while(list.size()>1) {
			// 开始数数
			for(int i=1;i<m;i++) {
				index = (index+1)%list.size();
			}
			list.remove(index);
		}
		// 最后剩了一个
		return list.get(0);
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			int n = sc.nextInt();
			int m = sc.nextInt();
			// 开始处理
			System.out.println(ysf_func(n, m));
		}
	}
}
~~~

### [11.实现一个计数器 O(1)复杂度]

实现一种计数器，记录最近 N个数字，
包含push、getAverage方法（输出当前计数器内平均值），o1复杂度。
实现另一种计数器，可以对最近N个数字做排序。

```java
package com.lcz.tencent;
/**
 * 实现一种计数器，记录最近 N个数字，
 * 包含push、getAverage方法（输出当前计数器内平均值），o1复杂度。
 
   实现另一种计数器，可以对最近N个数字做排序。
 * @author LvChaoZhang
 *
 */
public class Digit {
	int[] s_data;
	double s_avg;
	int n;
	int size;
	// 开始的下标索引
	int head = 0;
	public Digit() {
		
	}
	
	public Digit(int n) {
		this.n = n;
		this.size = 0;
		s_data = new int[n];
		s_avg = 0;
	}
	
	// 插入方法
	public void push(int x) {
		if(size==n) {
			int temp = s_data[head];
			s_data[head]=x;
			head++;
			// 更新
			s_avg = ((s_avg*size-temp)+x)/size;
			// 如果head到最后了
			if(head==size) {
				head = 0;
			}
			
		}else {
			// 容器未满的情况
			s_data[size] = x;
			size++;
			if(size==1) {
				// 之前没有
				s_avg = x;
			}else {
				s_avg = (s_avg*(size-1) + x)/(size);
			}
		}
	}
	
	// 获取当前计数器内平均值
	public double getAverage() {
		return s_avg;
	}
	
	// 打印方法
	public void print() {
		for(int i=0;i<size;i++) {
			System.out.print(s_data[i] + " ");
		}
		System.out.print("平均数为："+s_avg);
		System.out.println();
	}
}


```

```java
package com.lcz.tencent;

public class Other_Digit extends Digit{
	public Other_Digit(int n) {
		super(n);
	}
	// 对N个数字进行排序
	public void sort() {
		// 插入排序 
		for(int i=1;i<size;i++) {
			for(int j=i-1;j>=0&&s_data[j]>s_data[j+1];j--) {
				// 交换
				swap(s_data,j,j+1);
			}
		}
	}
	
	public void swap(int[] nums,int i,int j) {
		int temp = nums[i];
		nums[i]  = nums[j];
		nums[j]  = temp;
	}
}


```

### 12.实现一个阻塞队列

阻塞队列：poll出队 put入队；要求put和poll都是线程安全的，并且队列满的时候put操作阻塞，队列空的时候poll阻塞

```java
class BlockingQueue{
	// 阻塞队列
	Queue<Integer> list;
	int size;
	public BlockingQueue(int n) {
		list = new LinkedList<>();
		size = n;
	}
	// 入队
	public void put(int data) throws InterruptedException {
		// 防止多个
		synchronized (list) {
			// 判断
			while(list.size()==size) {
				list.wait();
			}
			// 放入元素
			list.offer(data);
			// 通知其他
			list.notifyAll();
		}
	}
	// 出队
	public int poll() throws InterruptedException {
		synchronized (list) {
			// 判断
			if(list.size()==0) {
				list.wait();
			}
			int res = list.poll();
			//通知其他
			list.notifyAll();
			return res;
		}
	}
}
```

### [13.Leetcode211 添加与搜索单词-数据结构设计](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)

请你设计一个数据结构，支持 添加新单词 和 查找字符串是否与任何先前添加的字符串匹配 。

实现词典类 WordDictionary ：

WordDictionary() 初始化词典对象
void addWord(word) 将 word 添加到数据结构中，之后可以对它进行匹配
bool search(word) 如果数据结构中存在字符串与 word 匹配，则返回 true ；否则，返回  false 。word 中可能包含一些 '.' ，每个 . 都可以表示任何一个字母。


示例：

输入：
["WordDictionary","addWord","addWord","addWord","search","search","search","search"]
[[],["bad"],["dad"],["mad"],["pad"],["bad"],[".ad"],["b.."]]
输出：
[null,null,null,null,false,true,true,true]

解释：
WordDictionary wordDictionary = new WordDictionary();
wordDictionary.addWord("bad");
wordDictionary.addWord("dad");
wordDictionary.addWord("mad");
wordDictionary.search("pad"); // return False
wordDictionary.search("bad"); // return True
wordDictionary.search(".ad"); // return True
wordDictionary.search("b.."); // return True

```java
class WordDictionary {
    //根据字符串长度分开存放
    Map<Integer,Set<String>> dict = new HashMap<>();
    /** Initialize your data structure here. */
    public WordDictionary() {

    }
    //添加单词
    public void addWord(String word) {
        int length = word.length();
        //判断
        if(dict.get(length)!=null){
            dict.get(length).add(word);
        }else{
            Set<String> set = new HashSet<>();
            set.add(word);
            dict.put(length,set);
        }
    }
    
    // 查找
    public boolean search(String word) {
        Set<String> set = dict.get(word.length());
        if(set==null){
            return false;
        }
        if(set.contains(word)){
            return true;
        }
        // 匹配其余的
        char[] arr = word.toCharArray();
        p:for(String s:set){
            if(arr.length!=s.length()){
                continue;
            }
            // 继续判断
            char[] template = s.toCharArray();
            // 逐个字符对比
            for(int i=0;i<template.length;i++){
                if(arr[i]!='.'&&template[i]!=arr[i]){
                    continue p;
                }
            }
            //添加进来
            set.add(word);
            return true;
        }
        return false;
    }
}

/**
 * Your WordDictionary object will be instantiated and called as such:
 * WordDictionary obj = new WordDictionary();
 * obj.addWord(word);
 * boolean param_2 = obj.search(word);
 */
```

### [Leetcode535 TinyURL的加密与解密](https://leetcode-cn.com/problems/encode-and-decode-tinyurl/)

URL https://leetcode.com/problems/design-tinyurl 时，它将返回一个简化的URL http://tinyurl.com/4e9iAk.

要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。

**计数**

为了加密 URL，我们使用计数器 (ii) ，每遇到一个新的 URL 都加一。我们将 URL 与它的次数 ii 放在哈希表 HashMap 中，这样我们在稍后的解密中可以轻易地获得原本的 URL。

**出现次数加密**

```java
public class Codec {

    String chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    HashMap<String, String> map = new HashMap<>();
    int count = 1;

    public String getString() {
        int c = count;
        StringBuilder sb = new StringBuilder();
        while (c > 0) {
            c--;
            sb.append(chars.charAt(c % 62));
            c /= 62;
        }
        return sb.toString();
    }

    public String encode(String longUrl) {
        String key = getString();
        map.put(key, longUrl);
        return "http://tinyurl.com/" + key;
    }

    public String decode(String shortUrl) {
        return map.get(shortUrl.replace("http://tinyurl.com/", ""));
    }
}

```

**hashcode**

```java

public class Codec {
    Map<Integer, String> map = new HashMap<>();

    public String encode(String longUrl) {
        map.put(longUrl.hashCode(), longUrl);
        return "http://tinyurl.com/" + longUrl.hashCode();
    }

    public String decode(String shortUrl) {
        return map.get(Integer.parseInt(shortUrl.replace("http://tinyurl.com/", "")));
    }
}

```

### Leetcode303 区域和检索-数组不可变

给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。

实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点（也就是 sum(nums[i], nums[i + 1], ... , nums[j])）


示例：

输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))

```java
class NumArray {

    private int[] sums;

    public NumArray(int[] nums) {
        sums = new int[nums.length+1];

        sums[0] = 0;
        for (int i = 1; i <= nums.length; i++) {
            sums[i] += sums[i-1] + nums[i-1];
        }
    }

    public int sumRange(int i, int j) {
            return sums[j+1] - sums[i];
    }

}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
```

### Leetcode359 日志速率限制器

请你设计一个日志系统，可以流式接收消息以及它的时间戳。每条 不重复 的消息最多只能每 10 秒打印一次。也就是说，如果在时间戳 t 打印某条消息，那么相同内容的消息直到时间戳变为 t + 10 之前都不会被打印。

所有消息都按时间顺序发送。多条消息可能到达同一时间戳。

实现 Logger 类：

Logger() 初始化 logger 对象
bool shouldPrintMessage(int timestamp, string message) 如果这条消息 message 在给定的时间戳 timestamp 应该被打印出来，则返回 true ，否则请返回 false 。


示例：

输入：
["Logger", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage", "shouldPrintMessage"]
[[], [1, "foo"], [2, "bar"], [3, "foo"], [8, "bar"], [10, "foo"], [11, "foo"]]
输出：
[null, true, true, false, false, false, true]

解释：
Logger logger = new Logger();
logger.shouldPrintMessage(1, "foo");  // 返回 true ，下一次 "foo" 可以打印的时间戳是 1 + 10 = 11
logger.shouldPrintMessage(2, "bar");  // 返回 true ，下一次 "bar" 可以打印的时间戳是 2 + 10 = 12
logger.shouldPrintMessage(3, "foo");  // 3 < 11 ，返回 false
logger.shouldPrintMessage(8, "bar");  // 8 < 12 ，返回 false
logger.shouldPrintMessage(10, "foo"); // 10 < 11 ，返回 false
logger.shouldPrintMessage(11, "foo"); // 11 >= 11 ，返回 true ，下一次 "foo" 可以打印的时间戳是 11 + 10 = 21

```java
class Logger {
    Map<String, Integer> map;

    public Logger() {
        map = new HashMap<>();
    }
    
    public boolean shouldPrintMessage(int timestamp, String message) {
        var time = map.get(message);
        if (time == null || timestamp - 10 >= time) {
            map.put(message, timestamp);
            time = null;
        }
        return time == null;
    }
}

/**
 * Your Logger object will be instantiated and called as such:
 * Logger obj = new Logger();
 * boolean param_1 = obj.shouldPrintMessage(timestamp,message);
 */
```



## 双指针（山脉数组 分发糖果 峰值）

### [1.Leetcode392 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

 

示例 1：

输入：s = "abc", t = "ahbgdc"
输出：true

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        // 双指针的解题思路
        int len1 = s.length();
        int len2 = t.length();
        int l1 = 0;
        int l2 = 0;
        while(l1<len1&&l2<len2){
            // 开始比较
            if(s.charAt(l1)==t.charAt(l2)){
                l1++;
            }
            l2++;
        }
        // 最后查看
        return l1==len1;
    }
}
```

### [2.Leetcode判断是否为回文数]

```java
/**
	 * 判断一个数是否为回文数
	 * @param n
	 * @return
	 */
	public static boolean isDigit(int n) {
		int sum = 0;
		int pre = n;
		// 123321
		while(n>0) {
			int temp = n%10;
			sum = sum*10 + temp;
			n = n/10;
			
		}
		// 判断
		return sum==pre;
	}
	/**
	 * 数字转为字符串
	 * 123321
	 * @param n
	 * @return
	 */
	public static boolean isDigit_2(int n) {
		//负数的情况
		if(n<0) {
			return false;
		}
		String a = String.valueOf(n);
		
		StringBuilder s1 = new StringBuilder(n);
		s1 = s1.reverse();
		
		StringBuilder s2 = new StringBuilder(n);
		System.out.println(s1==s2);
		
		return true;
	}
	
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		while(sc.hasNext()) {
			int n = sc.nextInt();
			boolean res = isDigit(n);
			System.out.println(res);
			boolean res_2 = isDigit_2(n);
			System.out.println(res_2);
		}
	}
```

### [3.Leetcode350 求两个数组的交集II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

给定两个数组，编写一个函数来计算它们的交集。



示例 1：

输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
示例 2:

输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]


说明：

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。
- 我们可以不考虑输出结果的顺序。

进阶：

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小很多，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

> 解题思路：与之前两个数组的交集不一样，不一样的地方在于Leetcode349中数组中的元素是唯一的，而这个元素不是唯一的。



> 一种是 通过HashMap来解题；
>
> 另一种是通过排序+双指针的思路来解题；

**解法一、HashMap的解题思路**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 解题思路一、HashMap
        // 让num1的length最小，
        if(nums1.length>nums2.length){
            return intersect(nums2,nums1);
        }

        HashMap<Integer,Integer> hashMap = new HashMap<>();
        // 先遍历num1来存储
        for(int num:nums1){
            hashMap.put(num,hashMap.getOrDefault(num,0)+1);
        }
        // 结果
        int[] in_arr = new int[nums1.length];
        int index = 0;
        // 遍历nums2
        for(int num:nums2){
            // 计算次数
            int count = hashMap.getOrDefault(num,0);
            // 如果有就是交集
            if(count>0){
                // 存储
                in_arr[index++] = num;
                // 判断是否还有了
                if(count>0){
                    hashMap.put(num,count-1);
                }else{
                    // 没了的话 删除
                    hashMap.remove(num);
                }
            }
        }
        return Arrays.copyOfRange(in_arr,0,index);
    }
}
```

**解法二、排序+双指针的解题思路**

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        // 排序
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        // 结果存储
        int len1 = nums1.length;
        int len2 = nums2.length;
        int len = len1>len2?len2:len1;
        int[] res = new int[len];
        // 双指针
        int index1 = 0;
        int index2 = 0;
        int index = 0;
        while(index1<len1&&index2<len2){
            if(nums1[index1]>nums2[index2]){
                index2++;
            }else if(nums1[index1]<nums2[index2]){
                index1++;
            }else if(nums1[index1]==nums2[index2]){
                res[index++] = nums1[index1]; 
                index1++;
                index2++;
            }
        }
        return Arrays.copyOfRange(res,0,index);

    }
}
```

进阶三问：

- 如果给定的数组已经拍好序了，那么用解法二即可

  其复杂度为O（mlogm+nlogn）如果有序就变为O(m+n)

- 如果nums1的大小比nums2小很多，哪种方法更优呢？

  将较小的数组哈希奇数，随后在另一个数组中根据哈希来找即解法一更适合。时间复杂度为O(max(n,m))

- 如果nums2的元素存储在磁盘上，内存是有限的，并且不能一次性加载所有元素到内存中，该怎么办呢？

  归并排序。可以将可以将分割后的子数组写到单个文件中，归并时将小文件合并为更大的文件。当两个数组均排序完成生成两个大文件后，即可使用双指针遍历两个文件，如此可以使空间复杂度最低。





### [3.Leetcode376 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

 

示例 1：

输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int up = 1;
        int down = 1;
        int res = 1;
        for(int i=1;i<nums.length;i++){
            if(nums[i]>nums[i-1]){
                up = down + 1;
            }else if(nums[i]<nums[i-1]){
                down = up + 1;
            }
            res = Math.max(down,up);
        }
        return res;
    }
}
```

### [3.Leetcode852 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/)

符合下列属性的数组 arr 称为 山脉数组 ：
arr.length >= 3
存在 i（0 < i < arr.length - 1）使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]
给你由整数组成的山脉数组 arr ，返回任何满足 arr[0] < arr[1] < ... arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1] 的下标 i 。

 

示例 1：

输入：arr = [0,1,0]
输出：1
示例 2：

输入：arr = [0,2,1,0]
输出：1

```java
class Solution {
    public int peakIndexInMountainArray(int[] arr) {
        int res = -1;
        for(int i=0;i<arr.length-1;i++){
            if(arr[i]>arr[i+1]){
                res = i;
                break;
            }
        }
        return res;
    }
}
```

### [4.Leetcode941 有效的山脉数组](https://leetcode-cn.com/problems/valid-mountain-array/)

给定一个整数数组 arr，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：

arr.length >= 3
在 0 < i < arr.length - 1 条件下，存在 i 使得：
arr[0] < arr[1] < ... arr[i-1] < arr[i]
arr[i] > arr[i+1] > ... > arr[arr.length - 1]



![img](https://assets.leetcode.com/uploads/2019/10/20/hint_valid_mountain_array.png)


示例 1：

输入：arr = [2,1]
输出：false
示例 2：

输入：arr = [3,5,5]
输出：false

```java
class Solution {
    public boolean validMountainArray(int[] arr) {
        int n = arr.length;
        int l = 0;
        int r = n-1;
        while(l<n-1&&arr[l]<arr[l+1]){
            l++;
        }
        while(r>=1&&arr[r]<arr[r-1]){
            r--;
        }
        //排除特殊情况
        if(l==0||r==n-1){
            return false;
        }
        return l==r;
    }
}
```

### [5.Leetcode845 数组中的最长山脉](https://leetcode-cn.com/problems/longest-mountain-in-array/)

我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

B.length >= 3
存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
（注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 “山脉” 的长度。

如果不含有 “山脉” 则返回 0。

 

示例 1：

输入：[2,1,4,7,3,2,5]
输出：5
解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n = arr.length;
        // 左边有多少个连续递减的数
        int[] left = new int[n];
        // 右边有多少个连续递减的数
        int[] right = new int[n];
        // 开始
        for(int i=1;i<n;i++){
            if(arr[i]>arr[i-1]){
                left[i] = left[i-1] + 1;
            }
        }
        for(int i=n-2;i>=0;i--){
            if(arr[i]>arr[i+1]){
                right[i] = right[i+1] + 1;
            }
        }
        int res = 0;
        for(int i=0;i<n;i++){
            if(left[i]>0&&right[i]>0){
                res = Math.max(res,left[i]+right[i]+1);
            }
        }
        return res;
    }
}
```

### [6.Leetcode_面试题10.11 峰与谷](https://leetcode-cn.com/problems/peaks-and-valleys-lcci/)

在一个整数数组中，“峰”是大于或等于相邻整数的元素，相应地，“谷”是小于或等于相邻整数的元素。例如，在数组{5, 8, 4, 2, 3, 4, 6}中，{8, 6}是峰， {5, 2}是谷。现在给定一个整数数组，将该数组按峰与谷的交替顺序排序。

示例:

输入: [5, 3, 1, 2, 3]
输出: [5, 1, 3, 2, 3]
提示：

nums.length <= 10000

```java
class Solution {
    public void wiggleSort(int[] nums) {
        int[] arr = Arrays.copyOf(nums,nums.length);
        // 先排序
        Arrays.sort(arr);
        // 双指针
        int left = 0;
        int right = nums.length-1;
        // 新的索引
        int k = 0;
        boolean f = true;
        while(left<=right){
            if(f){
                nums[k++] = arr[right];
                right--;
                f = false;
            }else{
                nums[k++] = arr[left];
                left++;
                f = true;
            }
        }
    }
}
```

### [NC107 寻找峰值](https://www.nowcoder.com/practice/1af528f68adc4c20bf5d1456eddb080a?tpId=117&&tqId=37831&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

山峰元素是指其值大于或等于左右相邻值的元素。给定一个输入数组nums，任意两个相邻元素值不相等，数组可能包含多个山峰。找到索引最大的那个山峰元素并返回其索引。

假设 nums[-1] = nums[n] = -∞。

**示例1**

输入：

```
[2,4,1,2,7,8,4]
```

复制

返回值：

```
5
```

```java
import java.util.*;


public class Solution {
    /**
     * 寻找最后的山峰
     * @param a int整型一维数组 
     * @return int整型
     */
    public int solve (int[] a) {
        // write code here
         int n=a.length,po=-1;
        for(int i=0;i<n;++i){
            if(i==0&&a[i]>=a[i+1]){
                po=i;
            }
            else if(i==n-1&&a[i]>=a[i-1]){
                po=i;
            }
            else if(i>0&&i<n-1&&a[i]>=a[i-1]&&a[i]>=a[i+1]){
                po=i;
            }
        }
        return po;
    }
}
```

## 常见应用题（分发糖果 接雨水 盛最多水  最大矩形  柱状图 最大正方形 八皇后 太平洋大西洋）

### [Leetcode135 分发糖果](https://leetcode-cn.com/problems/candy/)

老师想给孩子们分发糖果，有 N 个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分。

你需要按照以下要求，帮助老师给这些孩子分发糖果：

每个孩子至少分配到 1 个糖果。
评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。
那么这样下来，老师至少需要准备多少颗糖果呢？

 

示例 1：

输入：[1,0,2]
输出：5
解释：你可以分别给这三个孩子分发 2、1、2 颗糖果。
示例 2：

输入：[1,2,2]
输出：4
解释：你可以分别给这三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这已满足上述两个条件。

```java
class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        int[] left = new int[len];
        for(int i=0;i<len;i++){
            if(i>0&&ratings[i]>ratings[i-1]){
                left[i] = left[i-1] + 1;
            }else{
                left[i] = 1;
            }
        }
        int res = 0;
        int right = 0;
        for(int i=len-1;i>=0;i--){
            if(i<len-1&&ratings[i]>ratings[i+1]){
                right++;
            }else{
                right = 1;
            }
            res += Math.max(left[i],right);
        }
        return res;
    }
}
```



### [7.Leetcode042 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)


给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

**示例 1：**

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

```java
class Solution {
    public int trap(int[] height) {
        if(height.length<=0){
            return 0;
        }
        // 两个
        int n = height.length;
        int[] left = new int[n];
        int[] right = new int[n];
        // 初始化
        left[0] = height[0];
        for(int i=1;i<n;i++){
            left[i] = Math.max(left[i-1],height[i]);
        }
        right[n-1] = height[n-1];
        for(int i=n-2;i>=0;i--){
            right[i] = Math.max(right[i+1],height[i]);
        }
        // 继续
        int res = 0;
        for(int i=1;i<n-1;i++){
            res += Math.min(left[i],right[i])-height[i];
        }
        return res;
    }
}
```

```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length-1;
        int leftMax = 0;
        int rightMax = 0;
        int count = 0;
        while(left<right){
            leftMax = Math.max(leftMax,height[left]);
            rightMax = Math.max(rightMax,height[right]);
            if(leftMax<rightMax){
                count+= leftMax-height[left];
                left++;
            }else{
                count += rightMax-height[right];
                right--;
            }
        }
        return count;
    }
}
```



### [8.Leetcode011 盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

给给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

 

示例 1：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
示例 2：

输入：height = [1,1]
输出：1

```java
class Solution {
    public int maxArea(int[] height) {
        int n = height.length;
        int res = 0;
        int left = 0;
        int right = n-1;
        // 开始
        while(left<right){
            int temp = Math.min(height[left],height[right])*(right-left);
            res = Math.max(res,temp);
            if(height[left]<height[right]){
                left++;
            }else{
                right--;
            }
        }
        return res;
    }
}
```

### [9.Leetcode84 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)



以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)



图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

 

示例:

输入: [2,1,5,6,2,3]
输出: 10

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int res = 0;
        for(int i=0;i<heights.length;i++){
            int curHeight = heights[i];
            int left = i-1;
            while(left>=0&&heights[left]>=curHeight){
                left--;
            }
            left++;

            int right = i+1;
            while(right<heights.length&&heights[right]>=curHeight){
                right++;
            }
            right--;

            int width = right-left+1;
	    	res = Math.max(res, width*curHeight);
        }
        return res;
    }
}
```

**单调栈**

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        // 单调栈
        Stack<Integer> stack = new Stack<>();
        int[] newheights = new int[heights.length+2];
        // 复制
        System.arraycopy(heights,0,newheights,1,heights.length);
        int res = 0;
        // 开始遍历
        for(int i=0;i<newheights.length;i++){
            while(!stack.isEmpty()&&newheights[stack.peek()]>newheights[i]){
                int curIndex = stack.pop();
                res = Math.max(res,(i-stack.peek()-1)*newheights[curIndex]);
            }
            stack.push(i);
        }
        return res;
    }
}
```

### [10.Leetcode85 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)


输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。

```java
class Solution {
    public int maximalRectangle(char[][] matrix) {
        // 利用之前求柱形的最大面积
        if(matrix.length==0 || matrix[0].length==0){
            return 0;
        }
        int row = matrix.length;
        int col = matrix[0].length;
        int[] height = new int[col];
        // 结果
        int res = 0;
        for(int i=0;i<row;i++){
            for(int j=0;j<col;j++){
                if(matrix[i][j]=='1'){
                    height[j] += 1;
                }else{
                    height[j] = 0;
                }
            }
            // 开始计算
            res = Math.max(res,largestRectangle(height));
        }
        return res;
    }
    // 单调栈
	    public int largestRectangle(int[] heights) {
	    	// 结果返回
	    	int res = 0;
	    	Deque<Integer> stack = new ArrayDeque<>();
	    	// 方便计算扩充
	    	int[] new_heights = new int[heights.length+2];
            for (int i = 1; i < heights.length + 1; i++) {
                new_heights[i] = heights[i - 1];
            }	    	// 遍历
	    	for(int i=0;i<new_heights.length;i++) {
	    		while(!stack.isEmpty()&&new_heights[stack.peek()]>new_heights[i]) {
	    			// 计算每个i后面的连续递增，找到一个不满足的结束 不需要全部计算，单调栈剩余都是小数
	    			int curIndex = stack.pop();
	    			res = Math.max(res, (i-stack.peek()-1)*new_heights[curIndex]);
	    		}
	    		
	    		stack.push(i);
	    	}
	    	return res;
	    }


}
```

### [Leetcode221最大正方形](https://leetcode-cn.com/problems/maximal-square/)

在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。

 ![img](https://assets.leetcode.com/uploads/2020/11/26/max1grid.jpg)

示例 1：


输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：4

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        // 找到最大边即可
	    	int maxSide = 0;
	    	// 动态规划
	    	int rows = matrix.length;
	    	int cols = matrix[0].length;
	    	int[][] dp = new int[rows][cols];
	    	for(int i=0;i<rows;i++) {
	    		for(int j=0;j<cols;j++) {
	    			// 判断
	    			if(matrix[i][j]=='1') {
	    				if(i==0||j==0) {
	    					dp[i][j] = 1;
	    				}else {
	    					dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
	    				}
	    				maxSide = Math.max(maxSide, dp[i][j]);
	    			}
	    		}
	    	}
	    	
	    	
	    	return maxSide * maxSide;
    }
}
```

### [NC108 最大正方形](https://www.nowcoder.com/practice/0058c4092cec44c2975e38223f10470e?tpId=117&&tqId=37832&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给定一个由'0'和'1'组成的2维矩阵，返回该矩阵中最大的由'1'组成的正方形的面积

**示例1**

输入：

```
[[1,0,1,0,0],[1,0,1,1,1],[1,1,1,1,1],[1,0,0,1,0]]
```

复制

返回值：

```
4
```

```java
import java.util.*;


public class Solution {
    /**
     * 最大正方形
     * @param matrix char字符型二维数组 
     * @return int整型
     */
    public int solve (char[][] matrix) {
        // write code here
        int maxSize = 0;
        //动态规划
        int rows = matrix.length;
        int cols = matrix[0].length;
        int[][] dp = new int[rows][cols];
        //动态规划
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                //判断
                if(matrix[i][j]=='1'){
                    if(i==0 ||j==0){
                        dp[i][j] = 1;
                    }else{
                        dp[i][j] = Math.min(Math.min(dp[i-1][j],dp[i][j-1]),dp[i-1][j-1])+1;
                    }
                    maxSize = Math.max(maxSize,dp[i][j]);
                }
            }
        }
        return maxSize*maxSize;
    }
}
```

### [面试题17.24 最大子矩阵](https://leetcode-cn.com/problems/max-submatrix-lcci/)

给定一个正整数、负整数和 0 组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。

返回一个数组 [r1, c1, r2, c2]，其中 r1, c1 分别代表子矩阵左上角的行号和列号，r2, c2 分别代表右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。

注意：本题相对书上原题稍作改动

示例：

输入：
[
   [-1,0],
   [0,-1]
]
输出：[0,1,0,1]
解释：输入中标粗的元素即为输出所表示的矩阵

```java
class Solution {
    public int[] getMaxMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int max = matrix[0][0];
        int[] res = new int[4];
        // 构造列的前缀和
        int[][] preSum = new int[m + 1][n];
        for (int i = 1; i < m + 1; i++) {
            for (int j = 0; j < n; j++) {
                preSum[i][j] = preSum[i - 1][j] + matrix[i - 1][j];
            }
        }
        // 合并行
        for (int top = 0; top < m; top++) {
            for (int bottom = top; bottom < m; bottom++) {
                // 构造一维矩阵
                int[] arr = new int[n];
                for (int i = 0; i < n; i++) {
                    arr[i] = preSum[bottom + 1][i] - preSum[top][i];
                }
                // 最大子数组问题
                int start = 0;
                int sum = arr[0];
                for (int i = 1; i < n; i++) {
                    if (sum > 0) {
                        sum += arr[i];
                    } else {
                        sum = arr[i];
                        start = i;
                    }
                    if (sum > max) {
                        max = sum;
                        res[0] = top;
                        res[1] = start;
                        res[2] = bottom;
                        res[3] = i;
                    }
                }
            }
        }

        return res;
    }
}
```



### [NC39 N皇后问题](https://www.nowcoder.com/practice/c76408782512486d91eea181107293b6?tpId=117&&tqId=37811&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

N*N*皇后问题是指在N*N*N*∗*N*的棋盘上要摆N*N*个皇后，
要求：任何两个皇后不同行，不同列也不再同一条斜线上，
求给一个整数N*N*，返回N*N*皇后的摆法数。

**示例1**

输入：

```
1
```

复制

返回值：

```
1
```

复制

**示例2**

输入：

```
8
```

复制

返回值：

```
92
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param n int整型 the n
     * @return int整型
     */
    int res = 0;
    public int Nqueen (int n) {
        // write code here
        // 构建棋盘
        char[][] chess = new char[n][n];
        for(int i=0;i<n;i++) {
            for(int j=0;j<n;j++) {
                chess[i][j] = '.';
            }
        }
        // 开始回溯 第0行开始
        dfs(chess,0);
        return res;
    }

    // 回溯
    public void dfs(char[][] chess,int row) {
        // 递归结束条件
        if(row==chess.length) {
            res+=1;
            return;
        }
        // 回溯
        for(int col=0;col<chess[0].length;col++) {
            // 判断能否放下去
            if(valid(chess,row,col)) {
                chess[row][col] = 'Q';
                dfs(chess,row+1);
                chess[row][col] = '.';
            }
        }
    }
	    
    // 判断合法性
    public boolean valid(char[][] chess,int row,int col) {
        // 判断其上面 其左上角 右上角

        for(int i=0;i<row;i++) {
            if(chess[i][col]=='Q') {
                return false;
            }
        }

        for(int i=row-1,j=col+1;i>=0&&j<chess[0].length;i--,j++) {
            if(chess[i][j]=='Q') {
                return false;
            }
        }

        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--) {
            if(chess[i][j]=='Q') {
                return false;
            }
        }
        return true;
    }
    
}
```

### Leetcode807 保持城市天际线


在二维数组`grid`中，`grid[i][j]`代表位于某处的建筑物的高度。 我们被允许增加任何数量（不同建筑物的数量可能不同）的建筑物的高度。 高度 0 也被认为是建筑物。

最后，从新数组的所有四个方向（即顶部，底部，左侧和右侧）观看的“天际线”必须与原始数组的天际线相同。 城市的天际线是从远处观看时，由所有建筑物形成的矩形的外部轮廓。 请看下面的例子。

建筑物高度可以增加的最大总和是多少？

```
例子：
输入： grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
输出： 35
解释： 
The grid is:
[ [3, 0, 8, 4], 
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

从数组竖直方向（即顶部，底部）看“天际线”是：[9, 4, 8, 7]
从水平水平方向（即左侧，右侧）看“天际线”是：[8, 7, 9, 3]

在不影响天际线的情况下对建筑物进行增高后，新数组如下：

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
```

```java
class Solution {
    public int maxIncreaseKeepingSkyline(int[][] grid) {
         int N = grid.length;
        int[] rowMaxes = new int[N];
        int[] colMaxes = new int[N];

        for (int r = 0; r < N; ++r)
            for (int c = 0; c < N; ++c) {
                rowMaxes[r] = Math.max(rowMaxes[r], grid[r][c]);
                colMaxes[c] = Math.max(colMaxes[c], grid[r][c]);
        }

        int ans = 0;
        for (int r = 0; r < N; ++r)
            for (int c = 0; c < N; ++c)
                ans += Math.min(rowMaxes[r], colMaxes[c]) - grid[r][c];

        return ans;

    }
}
```

### [面试题08.12 八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)

设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。

注意：本题相对原题做了扩展

示例:

 输入：4
 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
 解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] grid = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = '.';
            }
        }
        boolean[] col = new boolean[n];
        boolean[] dg = new boolean[n + n];
        boolean[] udg = new boolean[n + n];
        dfs(0, n, grid, col, dg, udg);

        return res;
    }

    private void dfs(int h, int n, char[][] grid, boolean[] col, boolean[] dg, boolean[] udg) {
        if (h == n) {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < grid.length; i++) {
                list.add(new String(grid[i]));
            }
            res.add(list);
            return;
        }
        for (int j = 0; j < n; j++) {
            if (!col[j] && !dg[n - h + j] && !udg[h + j]) {
                grid[h][j] = 'Q';
                col[j] = dg[n - h + j] = udg[h + j] = true;
                dfs(h + 1, n, grid, col, dg, udg);
                grid[h][j] = '.';
                col[j] = dg[n - h + j] = udg[h + j] = false;
            }
        }
    }
}
```

### [Leetcode417 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/)

给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。

规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。

请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。

 

提示：

输出坐标的顺序不重要
m 和 n 都小于150


示例：

 

给定下面的 5x5 矩阵:

  太平洋 ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * 大西洋

返回:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (上图中带括号的单元).

```java
class Solution {
    private int m, n;
    private int[][] direction = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
    private boolean in_area(int x, int y){
        return 0 <= x && x < m && 0 <= y && y < n;
    }
    private void dfs(int[][] matrix, int x, int y, int[][] tmp){
        tmp[x][y] = 1;
        for (int[] d : direction) {
            int newx = x + d[0];
            int newy = y + d[1];
            if (!in_area(newx, newy) || matrix[x][y] > matrix[newx][newy] || tmp[newx][newy] == 1){
                continue;
            }
            dfs(matrix, newx, newy, tmp);
        }
    }
    public List<List<Integer>> pacificAtlantic(int[][] matrix) {
        List<List<Integer>> ans = new ArrayList<>();
        if (matrix == null || matrix.length == 0)
            return ans;
        m = matrix.length;
        n = matrix[0].length;
        int[][] po = new int[m][n], ao = new int[m][n]; //po 太平洋，ao 大西洋
        for (int i = 0; i < n; ++i){
            dfs(matrix, 0, i, po);
            dfs(matrix, m - 1, i, ao);
        }
        for (int i = 0; i < m; ++i){
            dfs(matrix, i, 0, po);
            dfs(matrix, i, n - 1, ao);
        }
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (po[i][j] == 1 && ao[i][j] == 1){
                    ans.add(Arrays.asList(i, j));
                }
            }
        }
        return ans;
    }
}
```

### Leetcodde502 IPO

假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。

给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。

总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。

 

示例：

输入：k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].
输出：4
解释：
由于你的初始资本为 0，你仅可以从 0 号项目开始。
在完成后，你将获得 1 的利润，你的总资本将变为 1。
此时你可以选择开始 1 号或 2 号项目。
由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。
因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。


提示：

```java
class Solution {
    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        // to speed up: if all projects are available
        boolean speedUp = true;
        for (int c: Capital) if (W < c) speedUp = false;
        if (speedUp) {
            PriorityQueue<Integer> heap = new PriorityQueue<>();
            for (int p: Profits) {
                heap.add(p);
                if (heap.size() > k) heap.poll();    
            }
            for (int h: heap) W += h; 
            return W;
        }
        
        int idx;
        int n = Profits.length;
        for(int i = 0; i < Math.min(k, n); ++i) {
            idx = -1; 
            // if there are available projects,
            // pick the most profitable one
            for(int j = 0; j < n; ++j) { 
                if (W >= Capital[j]) {
                    if (idx == -1 ) idx = j;
                    else if (Profits[idx] < Profits[j]) idx = j;
                }
            }
            // not enough capital to start any project
            if(idx == -1) break;
            
            // add the profit from chosen project
            // and remove the project from further consideration
            W += Profits[idx];
            Capital[idx] = Integer.MAX_VALUE;                
        }
        return  W;
    }
}


```

### Leetcode799 香槟塔


我们把玻璃杯摆成金字塔的形状，其中第一层有1个玻璃杯，第二层有2个，依次类推到第100层，每个玻璃杯(250ml)将盛有香槟。

从顶层的第一个玻璃杯开始倾倒一些香槟，当顶层的杯子满了，任何溢出的香槟都会立刻等流量的流向左右两侧的玻璃杯。当左右两边的杯子也满了，就会等流量的流向它们左右两边的杯子，依次类推。（当最底层的玻璃杯满了，香槟会流到地板上）

例如，在倾倒一杯香槟后，最顶层的玻璃杯满了。倾倒了两杯香槟后，第二层的两个玻璃杯各自盛放一半的香槟。在倒三杯香槟后，第二层的香槟满了 - 此时总共有三个满的玻璃杯。在倒第四杯后，第三层中间的玻璃杯盛放了一半的香槟，他两边的玻璃杯各自盛放了四分之一的香槟，如下图所示。

![img](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png)

现在当倾倒了非负整数杯香槟后，返回第 i 行 j 个玻璃杯所盛放的香槟占玻璃杯容积的比例（i 和 j都从0开始）。

示例 1:
输入: poured(倾倒香槟总杯数) = 1, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.0
解释: 我们在顶层（下标是（0，0））倒了一杯香槟后，没有溢出，因此所有在顶层以下的玻璃杯都是空的。

示例 2:
输入: poured(倾倒香槟总杯数) = 2, query_glass(杯子的位置数) = 1, query_row(行数) = 1
输出: 0.5
解释: 我们在顶层（下标是（0，0）倒了两杯香槟后，有一杯量的香槟将从顶层溢出，位于（1，0）的玻璃杯和（1，1）的玻璃杯平分了这一杯香槟，所以每个玻璃杯有一半的香槟。

```java
class Solution {
    public double champagneTower(int poured, int query_row, int query_glass) {
        double[][] champagne = new double[101][101];
        champagne[0][0] = poured;
        for(int i = 0; i <= query_row; i++) {
            for(int j = 0; j <= i; j++) {
                double p = (champagne[i][j] - 1.0) / 2;
                if(p > 0) {
                    champagne[i+1][j] += p;
                    champagne[i+1][j+1] += p;
                }
            }
        }
        return Math.min(champagne[query_row][query_glass], 1);
    }
}
```

### Leetcode475 供暖器

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

在加热器的加热半径范围内的每个房屋都可以获得供暖。

现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。

说明：所有供暖器都遵循你的半径标准，加热的半径也一样。

 

示例 1:

输入: houses = [1,2,3], heaters = [2]
输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。
示例 2:

输入: houses = [1,2,3,4], heaters = [1,4]
输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。

```java
class Solution {
    public int findRadius(int[] houses, int[] heaters) {
        // 先进行升序排列
        Arrays.sort(houses);
        Arrays.sort(heaters);
        int radius = 0;
        int i = 0;
        for (int house : houses) {
            while (i < heaters.length && heaters[i] < house) {
                // 一直找到处于房屋右侧的热水器
                i++;
            }
            if (i == 0)
                radius = Math.max(radius, heaters[i] - house);
            else if (i == heaters.length)
                // 最后一个热水器
                return Math.max(radius, houses[houses.length-1] - heaters[heaters.length-1]);
            else
                // 房屋右侧的热水器和房屋左侧的热水器，取小的那个
                radius = Math.max(radius, Math.min(heaters[i] - house, house - heaters[i - 1]));
        }
        return radius;
    }
}
```

### Leetcode514 自由之路

电子游戏“辐射4”中，任务“通向自由”要求玩家到达名为“Freedom Trail Ring”的金属表盘，并使用表盘拼写特定关键词才能开门。

给定一个字符串 ring，表示刻在外环上的编码；给定另一个字符串 key，表示需要拼写的关键词。您需要算出能够拼写关键词中所有字符的最少步数。

最初，ring 的第一个字符与12:00方向对齐。您需要顺时针或逆时针旋转 ring 以使 key 的一个字符在 12:00 方向对齐，然后按下中心按钮，以此逐个拼写完 key 中的所有字符。

旋转 ring 拼出 key 字符 key[i] 的阶段中：

您可以将 ring 顺时针或逆时针旋转一个位置，计为1步。旋转的最终目的是将字符串 ring 的一个字符与 12:00 方向对齐，并且这个字符必须等于字符 key[i] 。
如果字符 key[i] 已经对齐到12:00方向，您需要按下中心按钮进行拼写，这也将算作 1 步。按完之后，您可以开始拼写 key 的下一个字符（下一阶段）, 直至完成所有拼写。
示例：

 

![img](imgs\ring.jpg)

输入: ring = "godding", key = "gd"
输出: 4
解释:
 对于 key 的第一个字符 'g'，已经在正确的位置, 我们只需要1步来拼写这个字符。 
 对于 key 的第二个字符 'd'，我们需要逆时针旋转 ring "godding" 2步使它变成 "ddinggo"。
 当然, 我们还需要1步进行拼写。
 因此最终的输出是 4。

```java
class Solution {
    public int findRotateSteps(String ring, String key) {
        int n = ring.length(), m = key.length();
        List<Integer>[] pos = new List[26];
        for (int i = 0; i < 26; ++i) {
            pos[i] = new ArrayList<Integer>();
        }
        for (int i = 0; i < n; ++i) {
            pos[ring.charAt(i) - 'a'].add(i);
        }
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; ++i) {
            Arrays.fill(dp[i], 0x3f3f3f);
        }
        for (int i : pos[key.charAt(0) - 'a']) {
            dp[0][i] = Math.min(i, n - i) + 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j : pos[key.charAt(i) - 'a']) {
                for (int k : pos[key.charAt(i - 1) - 'a']) {
                    dp[i][j] = Math.min(dp[i][j], dp[i - 1][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + 1);
                }
            }
        }
        return Arrays.stream(dp[m - 1]).min().getAsInt();
    }
}

```

### Leetcode741 摘樱桃

个N x N的网格(grid) 代表了一块樱桃地，每个格子由以下三种数字的一种来表示：

0 表示这个格子是空的，所以你可以穿过它。
1 表示这个格子里装着一个樱桃，你可以摘到樱桃然后穿过它。
-1 表示这个格子里有荆棘，挡着你的路。
你的任务是在遵守下列规则的情况下，尽可能的摘到最多樱桃：

从位置 (0, 0) 出发，最后到达 (N-1, N-1) ，只能向下或向右走，并且只能穿越有效的格子（即只可以穿过值为0或者1的格子）；
当到达 (N-1, N-1) 后，你要继续走，直到返回到 (0, 0) ，只能向上或向左走，并且只能穿越有效的格子；
当你经过一个格子且这个格子包含一个樱桃时，你将摘到樱桃并且这个格子会变成空的（值变为0）；
如果在 (0, 0) 和 (N-1, N-1) 之间不存在一条可经过的路径，则没有任何一个樱桃能被摘到。
示例 1:

输入: grid =
[[0, 1, -1],
 [1, 0, -1],
 [1, 1,  1]]
输出: 5
解释： 
玩家从（0,0）点出发，经过了向下走，向下走，向右走，向右走，到达了点(2, 2)。
在这趟单程中，总共摘到了4颗樱桃，矩阵变成了[[0,1,-1],[0,0,-1],[0,0,0]]。
接着，这名玩家向左走，向上走，向上走，向左走，返回了起始点，又摘到了1颗樱桃。
在旅程中，总共摘到了5颗樱桃，这是可以摘到的最大值了。

```java
class Solution {
    private int[][][] memo;
    private int[][] grid;
    private int N;

    public int cherryPickup(int[][] grid) {
        this.grid = grid;
        N = grid.length;
        memo = new int[N][N][N];
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                Arrays.fill(memo[i][j], Integer.MIN_VALUE);
            }
        }
        return Math.max(0, dfs(0, 0, 0));
    }

    public int dfs(int x1, int y1, int x2) {
        int y2 = x1 + y1 - x2;

        // 越界或者遇到障碍的时候
        if (x1 == N || y2 == N || y1 == N || x2 == N || grid[x1][y1] == -1 || grid[x2][y2] == -1) {
            return -1;
        }

        // 走到了边，注意是并且并且
        if (x1 == N - 1 && y1 == N - 1) {
            return grid[x1][y1];
        }

        // 记忆化
        if (memo[x1][y1][x2] != Integer.MIN_VALUE) {
            return memo[x1][y1][x2];
        }

        int res = Math.max(Math.max(dfs(x1, y1 + 1, x2 + 1), dfs(x1 + 1, y1, x2 + 1)),
                Math.max(dfs(x1, y1 + 1, x2), dfs(x1 + 1, y1, x2)));

        if (res < 0) {
            return memo[x1][y1][x2] = -1;
        }
        res += grid[x1][y1];
        if (x1 != x2) {
            res += grid[x2][y2];
        }
        return memo[x1][y1][x2] = res;
    }
}


```

### Leetcode875 爱吃香蕉的珂珂

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。

珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

 

示例 1：

输入: piles = [3,6,7,11], H = 8
输出: 4
示例 2：

输入: piles = [30,11,23,4,20], H = 5
输出: 30

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int max=Integer.MIN_VALUE;
        int min=1;
        for(int i:piles){
            max=Math.max(max,i);
        }
        while (min<max){
            int mid = (max+min)>>1;
            int hour=0;
            for(int i:piles){
                if(i%mid!=0)hour++;
                hour+=i/mid;
            }
            if(hour>h){
                min=mid+1;
            }else {
                max=mid;
            }
        }
        return min;
    }
}
```

### Leetcode881 救生艇

第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。

每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。

返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

 

示例 1：

输入：people = [1,2], limit = 3
输出：1
解释：1 艘船载 (1, 2)
示例 2：

输入：people = [3,2,2,1], limit = 3
输出：3
解释：3 艘船分别载 (1, 2), (2) 和 (3)

```java
class Solution {
    public int numRescueBoats(int[] people, int limit) {
        int res = 0;
        int right = people.length - 1;
        int left = 0;
        Arrays.sort(people);
        while (left <= right) {
            if (left == right) {
                res++;      // 只剩下最后一个,直接一个走,结束
                break;
            }
            if (people[left] + people[right] > limit) {
                res++;
                right--;        // 先载最重的, 而且最小的也无法一起载,那么就最重的单独走
            }
            else {
                res++;
                right--;        // 最重的与最轻的一起走
                left++;
            }
        }
        return res;
    }
}
```

### Leetcode956 最高的广告牌

你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。

你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。

返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。

 

示例 1：

输入：[1,2,3,6]
输出：6
解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。
示例 2：

输入：[1,2,3,4,5,6]
输出：10
解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。

```java
class Solution {
    int NINF = Integer.MIN_VALUE / 3;
    Integer[][] memo;
    public int tallestBillboard(int[] rods) {
        int N = rods.length;
        // "memo[n][x]" will be stored at memo[n][5000+x]
        // Using Integer for default value null
        memo = new Integer[N][10001];
        return (int) dp(rods, 0, 5000);
    }

    public int dp(int[] rods, int i, int s) {
        if (i == rods.length) {
            return s == 5000 ? 0 : NINF;
        } else if (memo[i][s] != null) {
            return memo[i][s];
        } else {
            int ans = dp(rods, i+1, s);
            ans = Math.max(ans, dp(rods, i+1, s-rods[i]));
            ans = Math.max(ans, rods[i] + dp(rods, i+1, s+rods[i]));
            memo[i][s] = ans;
            return ans;
        }
    }
}

```

### Leetcode1049 最后一块石头的重量II

有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。

每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。

 

示例 1：

输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
示例 2：

输入：stones = [31,26,33,21,40]
输出：5

```java
class Solution {
    public int lastStoneWeightII(int[] stones) {
        int sum = 0;
        for (int i : stones) {
            sum += i;
        }
        int target = sum >> 1;
        //初始化dp数组
        int[] dp = new int[target + 1];
        for (int i = 0; i < stones.length; i++) {
            //采用倒序
            for (int j = target; j >= stones[i]; j--) {
                //两种情况，要么放，要么不放
                dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - 2 * dp[target];
    }
}
```

### Leetcode546 移除盒子

给出一些不同颜色的盒子，盒子的颜色由数字表示，即不同的数字表示不同的颜色。

你将经过若干轮操作去去掉盒子，直到所有的盒子都去掉为止。每一轮你可以移除具有相同颜色的连续 k 个盒子（k >= 1），这样一轮之后你将得到 k * k 个积分。

当你将所有盒子都去掉之后，求你能获得的最大积分和。

 

示例 1：

输入：boxes = [1,3,2,2,2,3,4,3,1]
输出：23
解释：
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----> [1, 3, 3, 4, 3, 1] (3*3=9 分) 
----> [1, 3, 3, 3, 1] (1*1=1 分) 
----> [1, 1] (3*3=9 分) 
----> [] (2*2=4 分)
示例 2：

输入：boxes = [1,1,1]
输出：9

```java
class Solution {
    public int removeBoxes(int[] boxes) {
        // 用于存储之前计算过的状态，避免重复计算
        int[][][] dp = new int[100][100][100];
        return cal(boxes, dp, 0, boxes.length - 1, 0);
    }
    
    public int cal(int[] boxes, int[][][] dp, int l, int r, int k) {
        if (l > r) {
            return 0;
        }
        if (dp[l][r][k] != 0) {
            return dp[l][r][k];
        }
        // 计算右边有几个跟最右边一个（boxes[r]）相等, 如果相等则把右边界左移到不相同的元素之后一个为止，移动过程中同步改动k
        while (r > l && boxes[r] == boxes[r-1]) {
            r--;
            k++;
        }
        // 计算把右边k+1个消除时的得分
        dp[l][r][k] = cal(boxes, dp, l, r-1, 0) + (k+1)*(k+1);
        // 从右边界开始向左寻找跟外部k个元素相等的元素，如果相等则剔除掉这些不相等的，让后面一段连起来。
        // 此时得分就是中间消除中间一段不连续部分的得分和剩下来部分的得分
        // 比较这个得分和原来计算过其他方案的得分，去最大值覆盖到状态数组dp中
        for (int i = r-1; i >= l; --i) {
            if (boxes[i] == boxes[r]) {
                dp[l][r][k] = Math.max(dp[l][r][k], cal(boxes, dp, l, i, k+1) + cal(boxes, dp, i+1, r-1, 0));
            }
        }
        return dp[l][r][k];
        
    }
}
```



## 动归

### [Leetcode486 预测赢家](https://leetcode-cn.com/problems/predict-the-winner/)(动态规划-预测赢家)

给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。

给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。

 

示例 1：

输入：[1, 5, 2]
输出：False
解释：一开始，玩家1可以从1和2中进行选择。
如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
因此，玩家 1 永远不会成为赢家，返回 False 。

```java
class Solution {
    public boolean PredictTheWinner(int[] nums) {
        // 预测赢家
        int n = nums.length;
        int[][] dp = new int[n][n];
        // 初始化
        for(int i=0;i<n;i++){
            // 对角线赋值
            dp[i][i] = nums[i];
        }

        // 转移方程从下到上
        for(int i=n-2;i>=0;i--){
            for(int j=i+1;j<n;j++){
                dp[i][j] = Math.max(nums[i]-dp[i+1][j],nums[j]-dp[i][j-1]);
            }
        }
        // 
        return dp[0][n-1]>=0;
    }
}
```

### [Leetcode_Offer14-I剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。

示例 1：

输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1
示例 2:

输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36

```java
class Solution {
    public int cuttingRope(int n) {
         // 剪绳子
        // 动态规划
        int[] dp = new int[n+1];
        //初始化
        dp[2] = 1;
        // 别的长度
        for(int i=3;i<n+1;i++){
            // 第一刀剪1没意义
            for(int j=2;j<i;j++){
                // 当前值的=维护当前 或者(剩下i-j不动)
                dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));
            }
        }
        return
            dp[n];
    }
}
```

### [NC68 跳台阶](https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=188&&tqId=38622&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

**示例1**

输入：

```
2
```

复制

返回值：

```
2
```

复制

**示例2**

输入：

```
7
```

复制

返回值：

```
21
```

**方法一：递归**

题目分析，假设f[i]表示在第i个台阶上可能的方法数。逆向思维。如果我从第n个台阶进行下台阶，下一步有2中可能，一种走到第n-1个台阶，一种是走到第n-2个台阶。所以f[n] = f[n-1] + f[n-2].
那么初始条件了，f[0] = f[1] = 1。
所以就变成了：f[n] = f[n-1] + f[n-2], 初始值f[0]=1, f[1]=1，目标求f[n]
看到公式很亲切，代码秒秒钟写完。

```java
int Fibonacci(int n) {
    if (n<=1) return 1;
    return Fibonacci(n-1) + Fibonacci(n-2);
}

```

优点，代码简单好写，缺点：慢，会超时
**时间复杂度**：O(2^n)
**空间复杂度**：递归栈的空间



方法二：记忆化搜索
拿求f[5] 举例

![image-20210808211724364](E:/笔记/面试高频/imgs/653.png)

通过图会发现，方法一中，存在很多重复计算，因为为了改进，就把计算过的保存下来。
那么用什么保存呢？一般会想到map， 但是此处不用牛刀，此处用数组就好了。

```java
int Fib(int n, vector<int>& dp) {
    if (n<=1) return 1;
    if (dp[n] != -1) return dp[n];
    return dp[n] = Fib(n-1) + Fib(n-2);
}
int Fibonacci(int n) {
    vector<int> dp(45, -1); // 因为答案都是>=0 的， 所以初始为-1，表示没计算过
    return Fib(n, dp);
}
```

**时间复杂度**：O（n）， 没有重复的计算
**空间复杂度**：O（n）和递归栈的空间

**动态规划**

虽然方法二可以解决此题了，但是如果想让空间继续优化，那就用动态规划，优化掉递归栈空间。
方法二是从上往下递归的然后再从下往上回溯的，最后回溯的时候来合并子树从而求得答案。
那么动态规划不同的是，不用递归的过程，直接从子树求得答案。过程是从下往上。

```java
public class Solution {
    public int jumpFloor(int n) {
        int[] dp = new int[n+1];
        dp[0] = dp[1] = 1;
        for (int i=2; i<=n; ++i) {
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
   
}
```

### [剑指Offer47 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)

在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？

 

示例 1:

输入: 
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 12
解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物

```java
class Solution {
    public int maxValue(int[][] grid) {
        // 从左上角到右下角
        // 向右或者向下移动一格
        int m = grid.length;
        int n = grid[0].length;
        // 动态规划的思路
        int[][] dp = new int[m][n];
        // 初始化
        dp[0][0] = grid[0][0];
        for(int i=1;i<m;i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for(int j=1;j<n;j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];  
        }
        // 继续走
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                // 转移方程
                dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### Leetcode1011 在D天内送达包裹的能力

传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。

传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。

返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。

 

示例 1：

输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5
输出：15
解释：
船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：
第 1 天：1, 2, 3, 4, 5
第 2 天：6, 7
第 3 天：8
第 4 天：9
第 5 天：10

请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。 

```java
class Solution {
    public int shipWithinDays(int[] weights, int days) {
        // 确定二分查找左右边界
        int left = Arrays.stream(weights).max().getAsInt(), right = Arrays.stream(weights).sum();
        while (left < right) {
            int mid = (left + right) / 2;
            // need 为需要运送的天数
            // cur 为当前这一天已经运送的包裹重量之和
            int need = 1, cur = 0;
            for (int weight : weights) {
                if (cur + weight > mid) {
                    ++need;
                    cur = 0;
                }
                cur += weight;
            }
            if (need <= days) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}


```



## 背包问题

### [NC145 01背包](https://www.nowcoder.com/practice/2820ea076d144b30806e72de5e5d4bbf?tpId=117&&tqId=37856&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

已知一个背包最多能容纳物体的体积为 ![img](https://www.nowcoder.com/equation?tex=V%5C)

现有 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个物品，第 ![img](https://www.nowcoder.com/equation?tex=i%5C) 个物品的体积为 v_i*v**i* , 重量为 w_i*w**i*

求当前背包最多能装多大重量的物品?

数据范围：

1 \le V \le 50001≤*V*≤5000

1 \le n \le 50001≤*n*≤5000

1 \le v_i \le 50001≤*v**i*≤5000

1 \le w_i \le 50001≤*w**i*≤5000

**示例1**

输入：

```
10,2,[[1,3],[10,4]]
```

复制

返回值：

```
4
```

复制

说明：

```
第一个物品的体积为1，重量为3，第二个物品的体积为10，重量为4。只取第二个物品可以达到最优方案，取物重量为4  
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算01背包问题的结果
     * @param V int整型 背包的体积
     * @param n int整型 物品的个数
     * @param vw int整型二维数组 第一维度为n,第二维度为2的二维数组,vw[i][0],vw[i][1]分别描述i+1个物品的vi,wi
     * @return int整型
     */
    public int knapsack (int V, int n, int[][] vw) {
        // write code here
        if(V==0 || n==0 || vw==null){
            return 0;
        }
        int[][] dp=new int[n+1][V+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=V;j++){
                if(j<vw[i-1][0]){
                    dp[i][j]=dp[i-1][j];
                }
                else{
                    dp[i][j]=Math.max(dp[i-1][j],dp[i-1][j-vw[i-1][0]]+vw[i-1][1]);
                }
            }
        }
        return dp[n][V];
    }
}
```

### 0-1背包问题

> 前言

**a.0-1背包是否重量能否装满的问题**

```java
package com.lcz.contest.alibaba;

import java.util.Scanner;

public class Contest_01 {
	// 限重m，个人是wi 恰好等于就上船
	// 恰好背包问题 不重复背人
	public static boolean check(int[] nums,int target) {
		int n = nums.length;
		boolean[][] dp = new boolean[n+1][target+1];
		dp[0][0] = true;
		
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=target;j++) {
				// 判断能不能放
				if(j>=nums[i-1]) {
					//可以放 也可以不放
					dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
				}else {
					// 不能放
					dp[i][j] = dp[i-1][j];
				}
			}
		}
		// 默认
		return dp[n][target];
	}
	// 主函数
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		while(in.hasNextInt()) {
			int n = in.nextInt();
			int target = in.nextInt();
			int[] weight = new int[n];
			for(int i=0;i<n;i++) {
				weight[i] = in.nextInt();
			}
			
			boolean flag = check(weight,target);
			if(flag) {
				System.out.println("YES");
			}else {
				System.out.println("NO");
			}
		}
	}
}

```

**b.0-1背包装满的 最大价值问题**

```java
package com.lcz.contest.alibaba;
// 给你一个可装载重量为W和N个物体，每个物品有重量和质量两个属性
// 其中第i个物体的重量有wt[i] 价值为val[i]
// 最多能装多少
import java.util.*;
public class Contest_03 {
	// 处理
	public static int process(int[] wt,int[] val,int target) {
		//动态规划 选择数组前ig容量为w
		int n = wt.length;
		int[][] dp = new int[n+1][target+1];
		// 初始化最大最小值不需要
		// 对其进行选择
		for(int i=1;i<=n;i++) {
			for(int j=1;j<=target;j++) {
				// 看能否放下去
				if(j>=wt[i-1]) {
					// 能放下去数组的值存放价值
					dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-wt[i-1]] + val[i-1]);
				}else {
					// 放不下去
					dp[i][j] = dp[i-1][j];
				}
			}
		}
		return dp[n][n];
		
	}
	public static void main(String[] args) {
		
		Scanner in = new Scanner(System.in);
		while(in.hasNextInt()) {
			// n=3 w=4 wt=[2,1,3] val=[4,2,3]
			int N = in.nextInt();
			int W = in.nextInt();
			int[] wt = new int[N];
			int[] val = new int[N];
			for(int i=0;i<N;i++) {
				wt[i] = in.nextInt();
			}
			for(int i=0;i<N;i++) {
				val[i] = in.nextInt();
			}
			System.out.println(process(wt,val,W));
		}
		
	}
}

```

#### [1.Leetcode416 分割等和子集](https://leetcode-cn.com/problems/partition-equal-subset-sum/)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        // 分割等和子集 即从这里面挑选n个数，使其等于 target
        int sum = 0;
        for(int num:nums){
            sum += num;
        }
        // 判断
        if(sum%2!=0){
            return false;
        }
        int target = sum/2;
        // 动态规划
        int n = nums.length; 
        // 第n个的剩余背包容量
        boolean[][] dp = new boolean[n+1][target+1];
        dp[0][0] = true;
        // 开始
        for(int i=1;i<=n;i++){
            for(int j=1;j<=target;j++){
                if(j>=nums[i-1]){
                    // 能放下
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i-1]];
                }else{
                    // 不能放下
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][target];
    }
}
```

#### [2.Leetcode494 目标和](https://leetcode-cn.com/problems/target-sum/)

给你一个整数数组 nums 和一个整数 target 。

向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：

例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。

 

示例 1：

输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

> 解题思路：从这些数里面挑选等于(sum+S)/2的总数

```JAVA
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int sum = 0;
        for(int num:nums){
            sum += num;
        }
        if((sum+S)%2!=0){
            return 0;
        }
        // 继续
        int target = (sum+S)/2;
        // 从前i个数挑选出等于target的数量
        int n = nums.length;
        int[][] dp = new int[n+1][target+1];
        //初始化
        for(int i=0;i<=n;i++){
            dp[i][0] = 1;
        }
        // 转移方程
        for(int i=1;i<=n;i++){
            for(int j=0;j<=target;j++){
                if(j>=nums[i-1]){
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][target];
    }
}
```

#### [3.Leetcode474 一和零](https://leetcode-cn.com/problems/ones-and-zeroes/)


给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的大小，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

 

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。
```



```java
class Solution {
    public int findMaxForm(String[] strs, int m, int n) {
        int len = strs.length;
        // 动态规划
        int[][][] dp = new int[len+1][m+1][n+1];
        // 最大最小问题
        for(int i=1;i<=len;i++){
            int count0 = count_0(strs[i-1]);
            int count1 = strs[i-1].length()-count0;
            // 转移方程
            for(int j=0;j<=m;j++){
                for(int k=0;k<=n;k++){
                    if(j>=count0&&k>=count1){
                        dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-count0][k-count1]+1);
                    }else{
                        dp[i][j][k] = dp[i-1][j][k];
                    }
                }
            } 
        }
        return dp[len][m][n];
    }

    // 统计0的数量
    public int count_0(String str){
        int sum = 0;
        for(int i=0;i<str.length();i++){
            if(str.charAt(i)=='0'){
                sum++;
            }
        }
        return sum;
    }
}
```



- 恰好target-组合问题的转移公式：

```java
dp[i] = dp[i] + dp[i-num];
```

- 恰好target-True/False问题的转移公式：

```java
dp[i] = dp[i] || dp[i-num];
```

- 最大target-最大最小问题的转移公式：

```java
dp[i] = Math.max(dp[i],dp[i-num]+1)
```

> 恰好问题记得初始化dp[0] = 1 or dp[0] = true;

### 完全背包问题

#### [NC126 换钱的最少货币数](https://www.nowcoder.com/practice/3911a20b3f8743058214ceaa099eeb45?tpId=188&&tqId=38635&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。

如果无解，请返回-1.

【要求】

时间复杂度O(n \times aim)*O*(*n*×*a**i**m*)，空间复杂度On。

**示例1**

输入：

```
[5,2,3],20
```

复制

返回值：

```
4
```

```java
import java.util.*;


public class Solution {
    /**
     * 最少货币数
     * @param arr int整型一维数组 the array
     * @param aim int整型 the target
     * @return int整型
     */
    public int minMoney (int[] coins, int amount) {
        // write code here
         int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

#### [1.Leetcode322 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //最大最小问题的数量问题
        int n = coins.length;
        int[][] dp = new int[n+1][amount+1];
        // 初始化
        for(int i=0;i<=n;i++){
            Arrays.fill(dp[i],amount+1);
            dp[i][0] = 0;
        }
        // 转移方程
        for(int i=1;i<=n;i++){
            for(int j=0;j<=amount;j++){
                if(j>=coins[i-1]){
                    dp[i][j] = Math.min(dp[i-1][j],dp[i][j-coins[i-1]]+1);
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][amount]==amount+1?-1:dp[n][amount];
    }
}
```

#### [2.Leetcode518 零钱兑换II](https://leetcode-cn.com/problems/coin-change-2/)


给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。



**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

```java
class Solution {
    public int change(int amount, int[] coins) {
        int n = coins.length;
        //动态规划
        int[][] dp = new int[n+1][amount+1];
        // 求数量
        for(int i=0;i<=n;i++){
            dp[i][0] = 1;
        }
        //转移方程
        for(int i=1;i<=n;i++){
            for(int j=0;j<=amount;j++){
                if(j>=coins[i-1]){
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                }else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[n][amount];
    }
}
```

#### [3.Leetcode139 单词拆分](https://leetcode-cn.com/problems/word-break/)

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：

输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：

输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        boolean[] dp = new boolean[n+1];
        // 初始化
        dp[0] = true;
        // 用hashset
        HashSet<String> dict = new HashSet<>(wordDict);
        // 转移方程
        for(int i=1;i<=n;i++){
            for(int j=0;j<i;j++){
                if(dp[j]&&dict.contains(s.substring(j,i))){
                    dp[i] = true;
                    break;
                }
            }
        } 
        return dp[n];
    }
}
```

#### [4.Leetcode377 组合总和IV](https://leetcode-cn.com/problems/combination-sum-iv/)

给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

示例 1：

输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。

> 解题思路：该题求得是排列

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        // 求排列总数
        int[] dp = new int[target+1];
        dp[0] = 1;;
        for(int i=1;i<=target;i++){
            for(int num:nums){
                if(i>=num){
                    dp[i] += dp[i-num];
                }
            }
        }
        return dp[target];
    }
}
```

## 股票买卖问题

### [1.一次买卖股票- Leetcode121买卖股票的最佳时间](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

 

示例 1：

输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

```java
class Solution {
    public int maxProfit(int[] prices) {
        if(prices.length<=1){
            return 0;
        }
        // 进价
        int dp0 = prices[0];
        // 利润
        int maxproft = 0;
        // 遍历
        for(int i=1;i<prices.length;i++){
            maxproft = Math.max(prices[i]-dp0,maxproft);
            dp0 = Math.min(dp0,prices[i]);
        }
        return maxproft;
    }
}
```

### [2.多次买卖股票-Leetcode122 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入: prices = [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

> 解题思路：两个变量

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 未持有
        int dp0 = 0;
        // 持有了
        int dp1 = -prices[0];
        for(int i=1;i<prices.length;i++){
            int newdp0 = Math.max(dp0,dp1+prices[i]);
            int newdp1 = Math.max(dp1,dp0-prices[i]);

            dp0 = newdp0;
            dp1 = newdp1;
        }
        return dp0;
    }
}
```

### [3.多次买卖股票包含冷却期-Leetcode309最佳买卖股票时机包含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
示例:

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]

> 状态：
>
> 持有 未持有冷冻期 持有冷冻期



```java
class Solution {
    public int maxProfit(int[] prices) {
        // 持有了
        int dp0 = -prices[0];
        // 未持有处于冷冻期
        int dp1 = 0;
        // 未持有不处于冷冻期
        int dp2 = 0;
        for(int i=1;i<prices.length;i++){
            // 持有
            int newdp0 = Math.max(dp0,dp2-prices[i]);
            // 未持有冷冻期
            int newdp1 = dp0+prices[i];
            // 未持有不在冷冻期
            int newdp2 = Math.max(dp2,dp1);

            dp0 = newdp0;
            dp1 = newdp1;
            dp2 = newdp2;
        }
        return Math.max(dp1,dp2);
    }
}
```

### [4.多次买卖股票包含手续费-Leetcode714买卖股票的最佳时机包含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

示例 1:

输入: prices = [1, 3, 2, 8, 4, 9], fee = 2
输出: 8
解释: 能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        // 多次买卖股票
        int dp0 = 0;
        int dp1 = -prices[0];
        for(int i=1;i<prices.length;i++){
            int newdp0 = Math.max(dp0,dp1+prices[i]-fee);
            int newdp1 = Math.max(dp1,dp0-prices[i]);

            dp0 = newdp0;
            dp1 = newdp1;
        }
        return dp0;
    }
}
```

### [5.多次买卖股票且最多进行两次Leetcode123](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

```java
class Solution {
    public int maxProfit(int[] prices) {
        // 一次也没有交易
        int dp0 = 0;
        // 第一次买入
        int dp1 = -prices[0];
        // 第一次卖出
        int dp2 = 0;
        // 第二次买入
        int dp3 = Integer.MIN_VALUE;
        // 第二次卖出
        int dp4 = Integer.MIN_VALUE;

        for(int i=1;i<prices.length;i++){
            int newdp0 = dp0;
            int newdp1 = Math.max(dp1,dp0-prices[i]);
            int newdp2 = Math.max(dp2,dp1+prices[i]);
            int newdp3 = Math.max(dp3,dp2-prices[i]);
            int newdp4 = Math.max(dp4,dp3+prices[i]);

            dp0 = newdp0;
            dp1 = newdp1;
            dp2 = newdp2;
            dp3 = newdp3;
            dp4 = newdp4;
        }
        return Math.max(dp2,dp4);
    }
}
```

### [6.多次买卖股票且限制k次交易-Leetcode188买卖股票的最佳时机IV](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/)

给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1：

输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。

```java
class Solution {
	    public int maxProfit(int k, int[] prices) {
	    	if(prices==null||prices.length==0||prices.length==1) {
	    		return 0;
	    	}
	    	// 判断k次交易
	    	if(k>(prices.length/2)) {
	    		int sum = 0;
	    		for(int i=1;i<prices.length;i++) {
	    			int temp = prices[i]-prices[i-1];
	    			sum += (temp>0?temp:0);
	    		}
	    		return sum;
	    	}
	    	
	    	// 动态数组
	    	int[][][] dp = new int[k+1][prices.length+1][2];
	    	// 初始化 交易 0天t次交易 手上持有 不可能
	    	for(int t=0;t<=k;t++) {
	    		dp[t][0][1] = Integer.MIN_VALUE;
	    	}
	    	// i天0次交易手上持有 不可能
	    	for(int i=0;i<prices.length;i++) {
	    		dp[0][i][1] = Integer.MIN_VALUE;
	    	}
	    	// 开始
	    	for(int t=1;t<=k;t++) { // 交易次数
	    		for(int i=1;i<=prices.length;i++) {
	    			dp[t][i][0] = Math.max(dp[t][i-1][0], dp[t][i-1][1]+prices[i-1]);
	    			dp[t][i][1] = Math.max(dp[t][i-1][1], dp[t-1][i-1][0]-prices[i-1]);
	    		}
	    	}
	    	return dp[k][prices.length][0];
	    }
	}
```

## A到B点的路径问题

### 面试题08.02 迷路机器人

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

障碍物和空位置分别用 1 和 0 来表示。

返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

示例 1:

输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）

```java
class Solution {
    List<List<Integer>> res = new ArrayList();
    public List<List<Integer>> pathWithObstacles(int[][] obstacleGrid) {
        if(dfs(obstacleGrid, obstacleGrid.length - 1, obstacleGrid[0].length - 1))
            return res;
        else return new ArrayList();
    }

    public boolean dfs(int[][] obstacleGrid, int x, int y) {
        if(x < 0 || y < 0 || obstacleGrid[x][y] == 1) return false;
        boolean flag = dfs(obstacleGrid, x - 1, y) || dfs(obstacleGrid, x, y - 1);
        if(x == 0 && y == 0) flag = true;
        if(flag) {
            List<Integer> list = new ArrayList();
            list.add(x);
            list.add(y);
            res.add(list);
        }
        return flag;
    }
}
```

### [4.1 Leetcode797 所有可能的路径-从 A点到B点的所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）

二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3

```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        return solve(graph,0);
    }
    public List<List<Integer>> solve(int[][] graph,int node){
        int n = graph.length;
        // 结果存储
        List<List<Integer>> res = new ArrayList<>();
        // 递归结果
        if(node==n-1){
            List<Integer> path = new ArrayList<>();
            path.add(n-1);
            res.add(path);
            return res;
        }
        //  其余的点遍历
        for(int nei:graph[node]){
            for(List<Integer> path:solve(graph,nei)){
                path.add(0,node);
                res.add(path);
            }
        }
        return res;
    }

}
```

### 4.2 [Leetcode64 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)


输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
示例 2：

输入：grid = [[1,2,3],[4,5,6]]
输出：12

> 解题思路：初始化以及转移方程

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // 最小路径和
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        // 初始化
        dp[0][0] = grid[0][0];
        for(int i=1;i<m;i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for(int j=1;j<n;j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        // 转移方程
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### [4.3 Leetcode174 地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。

骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。

有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。

为了尽快到达公主，骑士决定每次只向右或向下移动一步。

 

编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。

例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -> 右 -> 下 -> 下，则骑士的初始健康点数至少为 7。

-2 (K)	-3	3
-5	-10	1
10	30	-5 (P)

**说明:**

- 骑士的健康点数没有上限。
- 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间

> 解题思路：从最后往上面走

```java
class Solution {
    public int calculateMinimumHP(int[][] dungeon) {
        int n = dungeon.length;
        int m = dungeon[0].length;
        // 动态规划
        int[][] dp = new int[n][m];
        // 逆序
        for(int i=n-1;i>=0;i--){
            for(int j=m-1;j>=0;j--){
                // 判断如果到了终点
                if(i==n-1&&j==m-1){
                    dp[i][j] = Math.max(1,1-dungeon[i][j]);
                }else if(i==n-1){
                    // 到达最后一行了
                    dp[i][j] = Math.max(1,dp[i][j+1]-dungeon[i][j]);
                }else if(j==m-1){
                    //到达最后一列了
                    dp[i][j] = Math.max(1,dp[i+1][j]-dungeon[i][j]);
                }else{
                    dp[i][j] = Math.max(1,Math.min(dp[i+1][j],dp[i][j+1])-dungeon[i][j]);
                }
            }
        }
        return dp[0][0];
    }
}
```

### [4.4 Leetcode1368 使网格图至少有一条有效路径的最小代价](https://leetcode-cn.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/)

给你一个 m x n 的网格图 grid 。 grid 中每个格子都有一个数字，对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：

1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]
2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]
3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]
4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]
注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域。

一开始，你会从最左上角的格子 (0,0) 出发。我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走，最终在最右下角的格子 (m - 1, n - 1) 结束的路径。有效路径 不需要是最短路径 。

你可以花费 cost = 1 的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次 。

请你返回让网格图至少有一条有效路径的最小代价。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/29/grid1.png)

输入：grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]
输出：3
解释：你将从点 (0, 0) 出发。
到达 (3, 3) 的路径为： (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) 花费代价 cost = 1 使方向向下 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) 花费代价 cost = 1 使方向向下 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) 花费代价 cost = 1 使方向向下 --> (3, 3)
总花费为 cost = 3.

> 解题思路：
>
> BFS 的特点是按层遍历，从而可以保证首先找到最优解（最少步数、最小深度）。从这个意义上讲，BFS 解决的其实也是最短路径问题。这一问题对应的图 GG 包含的所有顶点即为状态空间，而每一个可能的状态转移都代表了一条边。
>
> 这题是求最短距离的变种，按最短距离的bfs解法来写。
> 在这题中求的最小cost可以当作最短距离，只是这个cost的算法不太一样，当我们
> 使用bfs时向上下左右四个方向扩展，向网络所指方向扩展则cost不变，往其他方向
> 则cost+1，遍历过程中使用二维数组dst来保存由(0, 0)到其他网格的最小花费。

```java
class Solution {
    public int minCost(int[][] grid) {
        //BFS算法
        int n = grid.length;
        int m = grid[0].length;
        // 最小花费的保存
        int[][] dst = new int[n][m];
        // 方向 向右走 向左走 向下走 向上走
        int[][] direction = {{},{0,1},{0,-1},{1,0},{-1,0}};
        // 初始化
        for(int i=0;i<n;i++){
            Arrays.fill(dst[i],-1);
        }
        // 层序遍历
        Queue<int[]> queue = new LinkedList<>();
        // int数组三个参数 纵轴 横轴 当前cost
        queue.offer(new int[]{0,0,0,});
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i=0;i<size;i++){
                // 排出来第一个
                int[] q = queue.poll();
                // 判断是否到终点了
                if(q[0]==n-1&&q[1]==m-1){
                    continue;
                }
                // 继续当前能走的方向
                int val = grid[q[0]][q[1]];
                for(int j=1;j<=4;j++){
                    int r = q[0] + direction[j][0];
                    int c = q[1] + direction[j][1];
                    //判断
                    if(r>=0&&c>=0&&r<n&&c<m){
                        // 判断
                        int add = j==val?0:1;
                        if(dst[r][c]==-1 || dst[r][c]>q[2]+add){
                            dst[r][c] = q[2]+add;
                            queue.offer(new int[]{r,c,dst[r][c]});
                        }
                    }
                }
            }
        }
        return Math.max(0,dst[n-1][m-1]);
    }
}
```

### [4.5 Leetcode1391 检查网格中是否存在有效路径](https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/)

给你一个 m x n 的网格 grid。网格里的每个单元都代表一条街道。grid[i][j] 的街道可以是：

1 表示连接左单元格和右单元格的街道。
2 表示连接上单元格和下单元格的街道。
3 表示连接左单元格和下单元格的街道。
4 表示连接右单元格和下单元格的街道。
5 表示连接左单元格和上单元格的街道。
6 表示连接右单元格和上单元格的街道。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/main.png)


你最开始从左上角的单元格 (0,0) 开始出发，网格中的「有效路径」是指从左上方的单元格 (0,0) 开始、一直到右下方的 (m-1,n-1) 结束的路径。该路径必须只沿着街道走。

注意：你 不能 变更街道。

如果网格中存在有效的路径，则返回 true，否则返回 false 。

  

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/03/21/e1.png)

输入：grid = [[2,4,3],[6,5,2]]
输出：true
解释：如图所示，你可以从 (0, 0) 开始，访问网格中的所有单元格并到达 (m - 1, n - 1) 。

```java
class Solution {
    // 定义数组 记录街道 前两个数字记录当前的方向 后面三个数字记录可以连接的下一个街道的型号 看图
    int[][] direct = {{0,1,1,3,5}, {1,0,2,5,6}, {0,-1,1,4,6},{-1,0,2,3,4}};
    // 记录图中每个街道哪些方向是相通的 看图 与上面的数组索引下标相关联
    int[][] cset = {{},{0,2},{1,3},{1,2},{0,1},{2,3},{0,3}};
    public boolean hasValidPath(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        boolean[][] df = new boolean[m][n];
        //层序遍历
        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{0,0,1});
        while(!queue.isEmpty()){
            int[] cur = queue.poll();
            //到达了
            if(cur[0]==m-1&&cur[1]==n-1){
                return true;
            }
            int[] rdirect = cset[grid[cur[0]][cur[1]]];
            // 遍历
            for(int rd:rdirect){
                int[] d = direct[rd];
                int x = cur[0]+d[0];
                int y = cur[1]+d[1];
                //判断
                if(x>=m || x<0 || y<0 || y>=n || df[x][y]){
                    continue;
                }
                if(grid[x][y]==d[2] || grid[x][y]==d[3] || grid[x][y]==d[4]){
                    queue.offer(new int[]{x,y,1});
                    df[x][y] = true;
                }
            }
        }
        return false;
    }
}
```

### 4.6 矩阵最长递增路径

给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/05/grid1.jpg)

```
输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
输出：4 
解释：最长递增路径为 [1, 2, 6, 9]。
```

```java
class Solution {
    //方向
    public int[][] dirs = {{-1,0,},{1,0},{0,-1},{0,1}};
    int rows,cols;
    public int longestIncreasingPath(int[][] matrix) {
        //递归截止条件
        if(matrix==null || matrix.length==0 || matrix[0].length==0){
            return 0;
        }
        rows = matrix.length;
        cols = matrix[0].length;
        // 记忆化
        int[][] meno = new int[rows][cols];
        // 结果
        int res = 0;
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                res = Math.max(res,dfs(matrix,i,j,meno));
            }
        }
        return res;
    }

    //深度优先搜索
    public int dfs(int[][]matrix,int row,int col,int[][] meno){
        if(meno[row][col]!=0){
            return meno[row][col];
        }
        ++meno[row][col];
        // 遍历
        for(int[] dir:dirs){
            int newRow = row+dir[0],newCol = col+dir[1];
            if(newRow>=0&&newRow<rows&&newCol>=0&&newCol<cols&&matrix[newRow][newCol]>matrix[row][col]){
                meno[row][col] = Math.max(meno[row][col],dfs(matrix,newRow,newCol,meno)+1);
            }
        }
        return meno[row][col];
    } 

}
```

### 4.7 Leetcode 判断t1树是否有t2树拓扑结构完全相同的子树

描述

给定彼此独立的两棵二叉树，判断 t1 树是否有与 t2 树拓扑结构完全相同的子树。

设 t1 树的边集为 E1，t2 树的边集为 E2，若 E2 等于 E1 ，则表示 t1 树和t2 树的拓扑结构完全相同。

**示例1**

输入：

```
{1,2,3,4,5,6,7,#,8,9},{2,4,5,#,8,9}
```

复制

返回值：

```
true
```

```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root1 TreeNode类 
     * @param root2 TreeNode类 
     * @return bool布尔型
     */
    public boolean isContains (TreeNode root1, TreeNode root2) {
        // write code here
        if(root2==null){
            return  true;
        }
        if(root1==null){
            return false;
        }
        if(root1.val==root2.val&&check(root1,root2)){
            return true;
        }
        return isContains(root1.left,root2) || isContains(root1.right,root2);
    }
    public boolean check(TreeNode root1,TreeNode root2){
        if(root2==null&&root1==null){
            return true;
        }
        
        if(root1==null || root2==null || root1.val!=root2.val){
            return false;
        }
        return check(root1.left,root2.left)&&check(root1.right,root2.right);
    }
}
```

## A到B之间的最小以及最大

### DFS-[1.Leetcode 面试题04.01 节点间通路](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

示例1:

 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
示例2:

 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true

```java
class Solution {
    // 访问过的
    Set<Integer> visited = new HashSet<>();
    public boolean findWhetherExistsPath(int n, int[][] edges, int start, int target) {
        // 构建图
        Map<Integer,List<Integer>> graph = new HashMap<>();
        for(int[] arr:edges){
            if(!graph.containsKey(arr[0])){
                graph.put(arr[0],new ArrayList<>());
            }
            graph.get(arr[0]).add(arr[1]);
        }
        // 判断
        if(start==target){
            return true;
        }
        if(!graph.containsKey(start)){
            return false;
        }
        // dfs
        return dfs(start,target,graph);
    }

    public boolean dfs(int cur,int target,Map<Integer,List<Integer>> graph){
        if(cur==target){
            return true;
        }
        if(!graph.containsKey(cur)){
            return false;
        }
        visited.add(cur);
        for(int node:graph.get(cur)){
            if(!visited.contains(node)){
                if(dfs(node,target,graph)){
                    return true;
                }
            }
        }
        return false;
    }
}
```

### DFS-[2.Leetcode797 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）

二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
示例 2：

![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]



```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        return solve(graph,0);
    }

    public List<List<Integer>> solve(int[][] graph,int node){
        // 结点总数
        int n = graph.length;
        List<List<Integer>> res = new ArrayList<>();
        if(node==n-1){
            // 到达最后一个； 
            List<Integer> path = new ArrayList<>();
            path.add(n-1);
            res.add(path);
            return res;
        } 
        // 其余的结点遍历
        for(int nei:graph[node]){
            for(List<Integer> path:solve(graph,nei)){
                path.add(0,node);
                res.add(path);
            }
        }
        return res;
    }
}
```

### DFS-[3.Leetcode1786 从第一个节点出发到最后一个节点的受限路径数](https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/)

现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。

从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, ..., zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 <= i <= k-1 的节点 zi 和 zi+1 之间存在一条边。

路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) > distanceToLastNode(zi+1) 的一条路径，其中 0 <= i <= k-1 。

返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png)

输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
输出：3
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png)


输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
输出：1
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。

```java
class Solution {
    final int MOD = 1000000007;
    public int countRestrictedPaths(int n, int[][] edges) {
        int cnt = 0;
        Map<Integer, List<int[]>> map = new HashMap<>();
        // 初始化邻接表
        for (int[] t : edges) {
            int x = t[0];
            int y = t[1];
            map.computeIfAbsent(x, k -> new ArrayList<>()).add(new int[]{y, t[2]});
            map.computeIfAbsent(y, k -> new ArrayList<>()).add(new int[]{x, t[2]});
        }
        
        // 保存到n点的 最短距离 和 受限路径数
        int[] distance = findShortPath(map,n,n);
        
        Long[] mem = new Long[n + 1];
        cnt = (int)findLimitedPathCount(map,1,n,distance,mem);
        return cnt;
    }
    public int[] findShortPath( Map<Integer, List<int[]>> map, int n, int start) {
        // 初始化distance数组和visit数组，并用最大值填充作为非连接状态INF
        int[] distance = new int[n + 1];
        Arrays.fill(distance, Integer.MAX_VALUE);
        boolean[] visit = new boolean[n + 1];

        // 初始化，索引0和起点的distance为0
        distance[start] = 0;
        distance[0] = 0;

        // 堆优化，将距离作为排序标准。单独用传入距离是因为PriorityQueue的上浮规则决定
        PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        // 把起点放进去，距离为0
        queue.offer(new int[]{start,0});

        while (!queue.isEmpty()) {
        // 当队列不空，拿出一个源出来
        Integer poll = queue.poll()[0];
        if(visit[poll]) continue;
        // 标记访问
        visit[poll] = true;
        // 遍历它的相邻节点
        List<int[]> list = map.getOrDefault(poll, Collections.emptyList());
        for (int[] arr : list) {
            int next = arr[0];
            if (visit[next]) continue;
            // 更新到这个相邻节点的最短距离，与 poll出来的节点增加的距离 比较
            distance[next] = Math.min(distance[next], distance[poll] + arr[1]);
            //堆中新增节点，这里需要手动传入 next节点堆距离值。否则如果next在队列中，将永远无法上浮。
            queue.offer(new int[]{next,distance[next]});
        }
        }
        return distance;
    }
    
    private long findLimitedPathCount(Map<Integer, List<int[]>> map, int i, int n, int[] distance, Long[] mem) {
        if(mem[i]!=null)return mem[i];
        if(i==n)return 1;
        long cnt = 0;
        List<int[]> list = map.getOrDefault(i,Collections.emptyList());
        for (int[] arr:list){
            int next = arr[0];
            //如果相邻节点距离比当前距离小，说明是受限路径
            if(distance[next] < distance[i]){
                cnt += findLimitedPathCount(map,next,n,distance,mem);
                cnt %= MOD;
            }
        }
        mem[i] = cnt;
        return cnt;
    }
}
```

### BFS-[1.Leetcode1514 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)

给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。

指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png)

输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
输出：0.25000
解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25

```java
//封装一个结点
class Pair implements Comparable<Pair>{
    double probaility;
    int node;

    // 初始化
    public Pair(double probaility,int node){
        this.probaility = probaility;
        this.node = node;
    }
    // 比较
    public int compareTo(Pair pair2){
        if(this.probaility==pair2.probaility){
            return this.node-pair2.node;
        }else{
            return this.probaility-pair2.probaility>0?-1:1;
        }
    }
}

class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        // 构建图
        List<List<Pair>> graph = new ArrayList<>();
        for(int i=0;i<n;i++){
            graph.add(new ArrayList<>());
        }
        for(int i=0;i<edges.length;i++){
            int[] e = edges[i];
            graph.get(e[0]).add(new Pair(succProb[i],e[1]));
            graph.get(e[1]).add(new Pair(succProb[i],e[0]));
        }

        // 权值
        PriorityQueue<Pair> queue = new PriorityQueue<>();
        // 结果
        double[] prob = new double[n];
        queue.offer(new Pair(1,start));
        prob[start] = 1;
        while(!queue.isEmpty()){
            Pair pair = queue.poll();
            double pr = pair.probaility;
            int node = pair.node;
            if(pr<prob[node]){
                continue;
            }
            for(Pair pairNext:graph.get(node)){
                double prNext = pairNext.probaility;
                int nodeNext = pairNext.node;
                if(prob[nodeNext]<prob[node]*prNext){
                    prob[nodeNext] = prob[node]*prNext;
                    queue.offer(new Pair(prob[nodeNext],nodeNext));
                }
            }
        }
        return prob[end];
    }
}
```

### 并查集-[1.Leetcode1631 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)

你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png)

输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png)



输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        //Kruskal构造连边
        List<int[]> edges = new LinkedList<>();
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                int id = i*cols+j;
                if(i<rows-1){
                    edges.add(new int[]{id,id+cols,Math.abs(heights[i][j]-heights[i+1][j])});
                }
                if(j<cols-1){
                    edges.add(new int[]{id,id+1,Math.abs(heights[i][j]-heights[i][j+1])});
                }
            }
        }
        //根据结点之间的权值进行排序
        Collections.sort(edges,new Comparator<int[]>(){
            public int compare(int[] o1,int[] o2){
                return o1[2] - o2[2];
            }
        });
        int ans = 0;
        //从小到大连通结点
        UnionFind uf = new UnionFind(rows*cols);
        for(int i=0;i<edges.size();i++){
            int[] temp = edges.get(i);
            int x = temp[0];
            int y = temp[1];
            int dp = temp[2];
            if(uf.find(x)!=uf.find(y)){
                uf.union(x,y);
                ans = dp;
            }
            //左上角结点和右下角结点连通
            if(uf.find(0)==uf.find(rows*cols-1)){
                break;
            }
        }
        return ans;
    }
}
// 并查集
class UnionFind{
    private int[] parent;
    private int count;

    public int getCount(){
        return count;
    }
    // 初始化
    public UnionFind(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // 开始找
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    // 合并
    public void union(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty){
            return;
        }
        parent[rootx] = rooty;
        count--;
    }

}
```



## DFS

### [1.Leetcode1219 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。


示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。

```java
class Solution {
    public int getMaximumGold(int[][] grid) {
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]!=0){
                    res = Math.max(res,dfs(grid,i,j));
                }
            }
        } 
        return res;
    }

    public int dfs(int[][] grid,int i,int j){
        // 递归截止条件
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){
            return 0;
        }
        // 记录
        int temp = grid[i][j];
        grid[i][j] = 0;
        int count = temp;
        int leftcount = dfs(grid,i-1,j);
        int rightcount = dfs(grid,i+1,j);
        int upcount = dfs(grid,i,j-1);
        int downcount = dfs(grid,i,j+1);
        int othercount = Math.max(leftcount,Math.max(rightcount,Math.max(upcount,downcount)));
        grid[i][j] = temp;
        
        return count + othercount;
    }
}
```

### [2.Leetcode200 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        int n = grid.length;
        int m = grid[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='1'){
                    count++;
                    // 渲染
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }
    public void dfs(char[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length|| grid[i][j]!='1'){
            return;
        }
        grid[i][j] = '2';
        dfs(grid,i+1,j);
        dfs(grid,i-1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
}
```

### [3.Leetcode1254 统计封闭岛屿的数量](https://leetcode-cn.com/problems/number-of-closed-islands/)

有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。

我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。

请返回封闭岛屿的数目。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_3_1610.png)

输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：

> 解题思路：

```java
class Solution {
    public int closedIsland(int[][] grid) {
        int count = 0;
        int n = grid.length;
        int m = grid[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                // 判断
                if(grid[i][j]==0&&dfs(grid,i,j)){
                    count++;
                }
            }
        }
        return count;
    }

    // 统计
    public boolean dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length){
            return false;
        }
        if(grid[i][j]!=0){
            return true;
        }
        grid[i][j] = 2;
        boolean left = dfs(grid,i+1,j);
        boolean right = dfs(grid,i-1,j);
        boolean up = dfs(grid,i,j-1);
        boolean down = dfs(grid,i,j+1);

        return left&&right&&up&&down;
    }
}
```

### [4.Leetcode_剑指Offer13 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

 

示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        int[][] square = new int[m][n];
        return dfs(square,0,0,k);
    }
    public int dfs(int[][] square,int i,int j,int k){
        // 递归截止条件
        if(i<0 || i>=square.length || j<0 || j>=square[0].length || square[i][j]==1 || ( (i%10+i/10+j%10+j/10)>k )){
            return 0;
        }
        // 访问过的
        square[i][j] = 1;
        int left = dfs(square,i+1,j,k);
        int right = dfs(square,i-1,j,k);
        int up  = dfs(square,i,j-1,k);
        int down = dfs(square,i,j+1,k);

        return left+right+up+down+1;
    }
}
```

### [5.Leetcode695 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

 

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                // 是否满足条件
                if(grid[i][j]==1){
                    count = Math.max(count,dfs(grid,i,j));
                }
            }
        }
        return count;
    }

    public int dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]!=1){
            return 0;
        }
        grid[i][j] = 2;
        // 继续
        int left = dfs(grid,i-1,j);
        int right = dfs(grid,i+1,j);
        int up = dfs(grid,i,j-1);
        int down = dfs(grid,i,j+1);

        return 1+left+right+up+down;
    }
}
```

### [6.Leetcode463 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)

输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    count += dfs(grid,i,j);
                }
            }
        }
        return count;
    }

    public int dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){
            return 1;
        }

        if(grid[i][j]==2){
            return 0;
        }

        grid[i][j] = 2;

        int left = dfs(grid,i+1,j);
        int right = dfs(grid,i-1,j);
        int up = dfs(grid,i,j-1);
        int down = dfs(grid,i,j+1);

        return left+right+up+down;
    }
}
```

### [7.Leetcode_剑指Offer12 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

 

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] arr = word.toCharArray();
        int n = board.length;
        int m = board[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(dfs(board,i,j,arr,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(char[][] board,int i,int j,char[] word, int index){
        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j]!=word[index]){
            return false;
        }
        if(index==word.length-1){
            return true;
        }
        char temp = board[i][j];
        board[i][j] = '1';

        boolean res = dfs(board,i+1,j,word,index+1) ||
                      dfs(board,i-1,j,word,index+1) ||
                      dfs(board,i,j-1,word,index+1) ||
                      dfs(board,i,j+1,word,index+1);
        board[i][j] = temp;
        return res;

    }
}
```

### Leetcode694 不同岛屿的数量

![在这里插入图片描述](imgs\731.png)

 统计岛屿的数量很简单，直接 dfs 即可。

  如果两个岛屿可以通过平移变换（不包括旋转和翻转）和另一个岛屿重合，说明两个岛屿是相同的。

  我们给一个岛屿的所有网格都记录坐标，以岛屿的最左上角网格作为起点，其他网格减去这个起点，得到的岛屿网格坐标就是一个相对值。

  如果两个岛屿的相对值一一对应，说明是同一个岛屿。

  因此，我们可以把所有岛屿的相对坐标连在一起成字符串，如果两个岛屿的字符串一样，也就说明他们的相对坐标一样，是同一个岛屿。

  再把这些岛屿相对坐标字符串存入到 HashSet 中，利用 HashSet 的不重复特点，最终 HashSet 有多少个字符串，就有多少个不同的岛屿。



```java
class Solution {
    public int numDistinctIslands(int[][] grid) {
        Set<String> islands = new HashSet<>();
        int rows = grid.length;
        if (rows == 0) return 0;
        int cols = grid[0].length;
        if (cols == 0) return 0;
        // 遍历坐标为 1 的点
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    StringBuilder islandCoordinate = new StringBuilder();
                    dfs(grid, islandCoordinate, i, j, i, j);
                    islands.add(islandCoordinate.toString());
                }
            }
        }
        return islands.size();
    }

    private void dfs(int[][] grid, StringBuilder islandCoordinate,
                     int curX, int curY,
                     int originX, int originY) {
        if (curX < 0 || curX >= grid.length || curY < 0 || curY >= grid[0].length || grid[curX][curY] == 0) {
            return;
        }
        grid[curX][curY] = 0; // 表示当前坐标已经处理，后面不要重复计算它
        islandCoordinate.append(curX - originX);  // 记录相对横坐标
        islandCoordinate.append(curY - originY);  // 记录相对纵坐标
        dfs(grid, islandCoordinate, curX - 1, curY, originX, originY);    // 上
        dfs(grid, islandCoordinate, curX + 1, curY, originX, originY);    // 下
        dfs(grid, islandCoordinate, curX, curY - 1, originX, originY);    // 左
        dfs(grid, islandCoordinate, curX, curY + 1, originX, originY);    // 右
    }
}

```

### [面试题08.12 八皇后](https://leetcode-cn.com/problems/eight-queens-lcci/)

设计一种算法，打印 N 皇后在 N × N 棋盘上的各种摆法，其中每个皇后都不同行、不同列，也不在对角线上。这里的“对角线”指的是所有的对角线，不只是平分整个棋盘的那两条对角线。

注意：本题相对原题做了扩展

示例:

 输入：4
 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
 解释: 4 皇后问题存在如下两个不同的解法。
[
 [".Q..",  // 解法 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // 解法 2
  "Q...",
  "...Q",
  ".Q.."]
]

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();

    public List<List<String>> solveNQueens(int n) {
        char[][] grid = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                grid[i][j] = '.';
            }
        }
        boolean[] col = new boolean[n];
        boolean[] dg = new boolean[n + n];
        boolean[] udg = new boolean[n + n];
        dfs(0, n, grid, col, dg, udg);

        return res;
    }

    private void dfs(int h, int n, char[][] grid, boolean[] col, boolean[] dg, boolean[] udg) {
        if (h == n) {
            List<String> list = new ArrayList<>();
            for (int i = 0; i < grid.length; i++) {
                list.add(new String(grid[i]));
            }
            res.add(list);
            return;
        }
        for (int j = 0; j < n; j++) {
            if (!col[j] && !dg[n - h + j] && !udg[h + j]) {
                grid[h][j] = 'Q';
                col[j] = dg[n - h + j] = udg[h + j] = true;
                dfs(h + 1, n, grid, col, dg, udg);
                grid[h][j] = '.';
                col[j] = dg[n - h + j] = udg[h + j] = false;
            }
        }
    }
}
```

### Leetcode1504 统计全1的子矩形

给你一个只包含 0 和 1 的 rows * columns 矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。

 

示例 1：

输入：mat = [[1,0,1],
            [1,1,0],
            [1,1,0]]
输出：13
解释：
有 6 个 1x1 的矩形。
有 2 个 1x2 的矩形。
有 3 个 2x1 的矩形。
有 1 个 2x2 的矩形。
有 1 个 3x1 的矩形。
矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。

**枚举**

```java
class Solution {
    public int numSubmat(int[][] mat) {
        int n = mat.length;
        int m = mat[0].length;
        int[][] row = new int[n][m];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (j == 0) {
                    row[i][j] = mat[i][j];
                } else if (mat[i][j] != 0) {
                    row[i][j] = row[i][j - 1] + 1;
                } else {
                    row[i][j] = 0;
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                int col = row[i][j];
                for (int k = i; k >= 0 && col != 0; --k) {
                    col = Math.min(col, row[k][j]);
                    ans += col;
                }
            }
        }
        return ans;
    }
}


```

**单调栈**

```java
class Solution {
    public int numSubmat(int[][] mat) {
        int n = mat.length;
        int m = mat[0].length;
        int[][] row = new int[n][m];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (j == 0) {
                    row[i][j] = mat[i][j];
                } else if (mat[i][j] != 0) {
                    row[i][j] = row[i][j - 1] + 1;
                } else {
                    row[i][j] = 0;
                }
            }
        }
        int ans = 0;
        for (int j = 0; j < m; ++j) { 
            int i = 0;
            Deque<int[]> Q = new LinkedList<int[]>();
            int sum = 0; 
            while (i <= n - 1) { 
                int height = 1; 
                while (!Q.isEmpty() && Q.peekFirst()[0] > row[i][j]) {
                  	// 弹出的时候要减去多于的答案
                    sum -= Q.peekFirst()[1] * (Q.peekFirst()[0] - row[i][j]); 
                    height += Q.peekFirst()[1]; 
                    Q.pollFirst(); 
                } 
                sum += row[i][j]; 
                ans += sum; 
                Q.offerFirst(new int[]{row[i][j], height}); 
                i++; 
            } 
        } 
        return ans;
    }
}


```





## 路径问题

### [Leetcode130 被围绕的区域]

给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。

示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)


输入：board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。

**深度优先搜索**

```java
class Solution {
    int n, m;

    public void solve(char[][] board) {
        n = board.length;
        if (n == 0) {
            return;
        }
        m = board[0].length;
        for (int i = 0; i < n; i++) {
            dfs(board, i, 0);
            dfs(board, i, m - 1);
        }
        for (int i = 1; i < m - 1; i++) {
            dfs(board, 0, i);
            dfs(board, n - 1, i);
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }

    public void dfs(char[][] board, int x, int y) {
        if (x < 0 || x >= n || y < 0 || y >= m || board[x][y] != 'O') {
            return;
        }
        board[x][y] = 'A';
        dfs(board, x + 1, y);
        dfs(board, x - 1, y);
        dfs(board, x, y + 1);
        dfs(board, x, y - 1);
    }
}

```

**广度优先搜索**

```java
class Solution {
    int[] dx = {1, -1, 0, 0};
    int[] dy = {0, 0, 1, -1};

    public void solve(char[][] board) {
        int n = board.length;
        if (n == 0) {
            return;
        }
        int m = board[0].length;
        Queue<int[]> queue = new LinkedList<int[]>();
        for (int i = 0; i < n; i++) {
            if (board[i][0] == 'O') {
                queue.offer(new int[]{i, 0});
                board[i][0] = 'A';
            }
            if (board[i][m - 1] == 'O') {
                queue.offer(new int[]{i, m - 1});
                board[i][m - 1] = 'A';
            }
        }
        for (int i = 1; i < m - 1; i++) {
            if (board[0][i] == 'O') {
                queue.offer(new int[]{0, i});
                board[0][i] = 'A';
            }
            if (board[n - 1][i] == 'O') {
                queue.offer(new int[]{n - 1, i});
                board[n - 1][i] = 'A';
            }
        }
        while (!queue.isEmpty()) {
            int[] cell = queue.poll();
            int x = cell[0], y = cell[1];
            for (int i = 0; i < 4; i++) {
                int mx = x + dx[i], my = y + dy[i];
                if (mx < 0 || my < 0 || mx >= n || my >= m || board[mx][my] != 'O') {
                    continue;
                }
                queue.offer(new int[]{mx, my});
                board[mx][my] = 'A';
            }
        }
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (board[i][j] == 'A') {
                    board[i][j] = 'O';
                } else if (board[i][j] == 'O') {
                    board[i][j] = 'X';
                }
            }
        }
    }
}

```

### [1.Leetcode064 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。

> 解题思路：动态规划

```java
class Solution {
    public int minPathSum(int[][] grid) {
        // 动态规划
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        // 初始化
        dp[0][0] = grid[0][0];
        for(int i=1;i<m;i++){
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for(int j=1;j<n;j++){
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        // 转移方程
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = Math.min(dp[i][j-1],dp[i-1][j])+grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### [2.Leetcode120 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

 

示例 1：

输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

```java
class Solution {
    public int minimumTotal(List<List<Integer>> triangle) {
        int row = triangle.size();
        // 动态规划
        int[][] dp = new int[row][row];
        // 初始化
        dp[0][0] = triangle.get(0).get(0);
        for(int i=1;i<row;i++){
            dp[i][0] = dp[i-1][0] + triangle.get(i).get(0);
        }   
        // 转移方程
        for(int i=1;i<row;i++){
            for(int j=1;j<=i;j++){
                if(i==j){
                    dp[i][j] = dp[i-1][j-1] + triangle.get(i).get(j);
                }else{
                    dp[i][j] = Math.min(dp[i-1][j],dp[i-1][j-1])+triangle.get(i).get(j);
                }
            }
        }
        // 结果
        int res = dp[row-1][0];
        for(int j=1;j<row;j++){
            res = Math.min(res,dp[row-1][j]);
        }
        return res;
    }
}
```

### [3.Leetcode062 不同路径](https://leetcode-cn.com/problems/unique-paths/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)


输入：m = 3, n = 7
输出：28

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        // 不同路径
        // 初始化
        for(int i=0;i<m;i++){
            dp[i][0] = 1;
        }
        for(int j=0;j<n;j++){
            dp[0][j] = 1;
        }
        // 转移方程
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### [4.Leetcode63 不同路径II](https://leetcode-cn.com/problems/unique-paths-ii/)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？



网格中的障碍物和空位置分别用 1 和 0 来表示。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)


输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        // 动态规划
        int[][] dp = new int[m][n];
        // 初始化
        for(int i=0;i<m;i++){
            if(obstacleGrid[i][0]==1){
                break;
            }
            dp[i][0] = 1;
        }
        for(int j=0;j<n;j++){
            if(obstacleGrid[0][j]==1){
                break;
            }
            dp[0][j] = 1;
        }
        // 转移方程
        for(int i=1;i<m;i++){
            for(int j=1;j<n;j++){
                dp[i][j] = obstacleGrid[i][j]==1?0:dp[i-1][j]+dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### [不同路径III]-代价

给你一个由‘0’(水)，‘1’陆地和2障碍物组成的二维网络，走陆地费用为1，走水路为2，障碍物无法通行，请你计算从网络的起始位置到最终位置的最小费用。

```java
package com.lcz.wangyi;

import java.util.Arrays;

public class Solution2 {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 计算最小航行费用
     * @param input int整型二维数组 二维网格
     * @return int整型
     */
    public static int minSailCost (int[][] input) {
        // write code here
    	if(input==null||input.length==0) {
    		return 0;
    	}
    	int m = input.length;
    	int n = input[0].length;
    	if(m==1&&n==1) {
    		return 1;
    	}
    	
    	int[][] dp = new int[m][n];
    	//初始化花费的代价
    	dp[0][0] = 0;
    	for(int i=1;i<m;i++) {
    		if(input[i][0]==2) {
    			//障碍物
    			for(int j=i;j<m;j++) {
        			dp[j][0] = -1;
    			}
    			break;
    		}
    		if(input[i][0]==0) {
    			//水路
    			dp[i][0] = dp[i-1][0]+2;
    		}
    		if(input[i][0]==1) {
    			//陆路
    			dp[i][0] = dp[i-1][0]+1; 
    		}
    	}
    	
    	for(int j=1;j<n;j++) {
    		if(input[0][j]==2) {
    			//障碍物
    			for(int i=j;i<n;i++) {
    				dp[0][i] = -1;
    			}
    			break;
    		}
    		if(input[0][j]==0) {
    			//水路
    			dp[0][j] = dp[0][j-1]+2;
    		}
    		if(input[0][j]==1) {
    			//陆路
    			dp[0][j] = dp[0][j-1]+1; 
    		}
    	}
    	
    	//转移方程
    	for(int i=1;i<m;i++) {
    		for(int j=1;j<n;j++) {
    			if(input[i][j]==2) {
    				//遇到障碍物 走不了
    				dp[i][j] = -1;
    				continue;
    			}else {
    				//判断当前是水路还是陆地
    				int cost = 0;
    				if(input[i][j]==0) {
    					//水路
    					cost = 2;
    				}else  if(input[i][j]==1) {
    					//陆地
    					cost = 1;
    				}
    				//判断之前的路径是否能走
    				if(dp[i-1][j]==-1&&dp[i][j-1]==-1) {
    					dp[i][j]=-1;
    				}else if(dp[i-1][j]==-1) {
    					dp[i][j]=dp[i][j-1]+cost;
    				}else if(dp[i][j-1]==-1){
    					dp[i][j]=dp[i-1][j]+cost;
    				}else {
        				dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1])+cost;
    				}
    			}
    		}
    	}
//    	
//    	for(int i=0;i<m;i++) {
//    		for(int j=0;j<n;j++) {
//    			System.out.print(dp[i][j]+" ");
//    		}
//    		System.out.println();
//    	}
//    	
    	return dp[m-1][n-1];
    	
    }
    
//    
//    public static void main(String[] args) {
//    	int[][] input = {{1,1,1,1,0},{0,1,0,1,0},{1,1,2,1,1},{0,2,0,0,1}};
//    	System.out.println(minSailCost(input));
//    	
//	}
}

```





### [5.Leetcode746 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

 

示例 1：

输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        //动态规划
        int[] dp = new int[n];
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i=2;i<n;i++){
            dp[i] = Math.min(dp[i-1],dp[i-2]) +cost[i];
        }
        return Math.min(dp[n-2],dp[n-1]);
    }
}
```

### [5.Leetcode70 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶
示例 2：

输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

```java
class Solution {
    public int climbStairs(int n) {
        if(n==1) {
	    		return n;
	    }
        int[] bp = new int[n];
        bp[0] = 1;
        bp[1] = 2;
        for(int i=2;i<n;i++) {
            bp[i] = bp[i-1] + bp[i-2];
        }
        return bp[n-1];
    }
}
```

### [面试题08.01 三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

三步问题。有个小孩正在上楼梯，楼梯有n阶台阶，小孩一次可以上1阶、2阶或3阶。实现一种方法，计算小孩有多少种上楼梯的方式。结果可能很大，你需要对结果模1000000007。

示例1:

 输入：n = 3 
 输出：4
 说明: 有四种走法
示例2:

 输入：n = 5
 输出：13

```java
class Solution {
    public int waysToStep(int n) {
        if(n<=2){
            return n;
        }
        if(n==3){
            return 4;
        }
        // 动态规划
        int[] dp = new int[n+1];
        dp[1] = 1;
        dp[2] = 2;
        dp[3] = 4;
        for(int i=4;i<=n;i++){
            dp[i] = (dp[i-1]+dp[i-2])%1000000007 + dp[i-3];
            dp[i] %= 1000000007;
        }
        return dp[n];
    }
}
```

### [6.Leetcode198打家劫舍](https://leetcode-cn.com/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 

示例 1：

输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 

```java
class Solution {
    public int rob(int[] nums) {
        // 打家劫舍
        int rob_1 = 0;
        int rob_2 = 0;
        int rob_i = 0;
        int n = nums.length-1;
        // 结果
        for(int i=n;i>=0;i--){
            rob_i = Math.max(rob_1,rob_2+nums[i]);

            rob_2 = rob_1;
            rob_1 = rob_i;
        }
        return rob_i; 
    }
}
```

### [7.Leetcode213 打家劫舍II](https://leetcode-cn.com/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

```java
class Solution {
    public int rob(int[] nums) {
        if(nums.length<2){
            return nums[0];
        }
        // 最后一个和第一个
        int n = nums.length-1;
        return Math.max(process(nums,n,1),process(nums,n-1,0));
    }
    public int process(int[] nums,int start,int end){
        // 开始处理
        int rob_1 = 0;
        int rob_2 = 0;
        int rob_i = 0;
        for(int i=start;i>=end;i--){
            rob_i = Math.max(rob_1,rob_2+nums[i]);

            rob_2 = rob_1;
            rob_1 = rob_i;
        }
        return rob_i;
    }
}
```

### [8.Leetcode337 打家劫舍III](https://leetcode-cn.com/problems/house-robber-iii/)

在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。

计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。

示例 1:

输入: [3,2,3,null,3,null,1]

     3
    / \
   2   3
    \   \ 
     3   1

输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.

> 解题思路：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        int[] res = dfs(root);
        return Math.max(res[0],res[1]);
    }
    // 开始
    public int[] dfs(TreeNode root){
        if(root==null){
            return new int[]{0,0};
        }
        int[] left = dfs(root.left);
        int[] right = dfs(root.right);
        int rob = root.val + left[1] + right[1];
        int norob = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);
        return new int[]{rob,norob};
    }
}
```

### [NC144 不相邻最大子序列和](https://www.nowcoder.com/practice/269b4dbd74e540aabd3aa9438208ed8d?tpId=117&&tqId=37855&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给你一个n（1\leq n\leq10^51≤*n*≤105），和一个长度为n的数组，在不同时选位置相邻的两个数的基础上，求该序列的最大子序列和（挑选出的子序列可以为空）。

**示例1**

输入：

```
3,[1,2,3]
```

复制

返回值：

```
4
```

复制

说明：

```
有[],[1],[2],[3],[1,3] 4种选取方式其中[1,3]选取最优，答案为4 
```

**示例2**

输入：

```
4,[4,2,3,5]
```

复制

返回值：

```
9
```

复制

说明：

```
其中[4,5]的选取方案是在满足不同时选取相邻位置的数的情况下是最优的答案 
```







其实就是一个打家劫舍的问题，数组中每一个元素值就是可以偷的金额，相邻的不能偷，求能够偷出的最大金额是多少。

设置一个状态转移数组dp，dp[i]表示数组中前i个元素所能偷的最大金额是多少

状态转移表达式：
(1)对于当前的元素arr[i],如果偷，那么dp[i] = dp[i-2] + arr[i]
(2)如果不偷，那么dp[i] = dp[i-1]

```java
import java.util.*;
public class Solution {
    public long subsequence (int n, int[] array) {
        
        long dp[] = new long[n];   
        dp[0] = Math.max(0,array[0]);
        if(n==1){
            return dp[n-1];
        }
        
        dp[1] = Math.max(dp[0],Long.valueOf(array[1]));
        
        for(int i = 2 ; i < n ; i++){
            dp[i] = Math.max(array[i]+dp[i-2],dp[i-1]);
        }
        return dp[n-1];
    }
}
```

## 贪心-跳法

### [贪心游戏-1.Leetcode55跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

```java
class Solution {
    public boolean canJump(int[] nums) {
        // 跳跃游戏
        int long_path = 0;
        int n =nums.length-1;
        for(int i=0;i<n;i++){
            long_path = Math.max(long_path,i+nums[i]);
            if(i>=long_path){
                return false;
            }
        }
        // 判断
        return long_path>=n-1;
    }
}
```

### [贪心游戏-2.Leetcode45 跳跃游戏II](https://leetcode-cn.com/problems/jump-game-ii/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

```java
class Solution {
    public int jump(int[] nums) {
        int long_path = 0;
        // 结果统计
        int count = 0;
        int end = 0;
        // 长度
        int len = nums.length-1;
        for(int i=0;i<len;i++){
            long_path = Math.max(long_path,i+nums[i]);
            if(i==end){
                count++;
                end = long_path;
            }
        }
        return count;
    }
}
```

### [贪心游戏-Leetcode1306 跳跃游戏III](https://leetcode-cn.com/problems/jump-game-iii/)

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

 

示例 1：

输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 

```java
class Solution {//深度优先搜索
    public boolean canReach(int[] arr, int start) {
        boolean[] dp=new boolean[arr.length];
        return dfs(arr,dp,start);
    }

    public boolean dfs(int[] arr,boolean[] dp,int start){
        if(start<0||start>=arr.length)return false;

        if(arr[start]==0)return true;

        if(dp[start]){
            return false;
        }else{
            dp[start]=true;
        }

        return dfs(arr,dp,start+arr[start])||dfs(arr,dp,start-arr[start]);
    }
}

```



### [NVC148 几步可以从跳到尾](https://www.nowcoder.com/practice/de62bcee9f9a4881ac80cce6da42b135?tpId=117&&tqId=37858&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给你一个长度为 ![img](https://www.nowcoder.com/equation?tex=n%5C) 的数组 ![img](https://www.nowcoder.com/equation?tex=A%5C)。

![img](https://www.nowcoder.com/equation?tex=A%5Bi%5D%5C) 表示从 ![img](https://www.nowcoder.com/equation?tex=i%5C) 这个位置开始最多能往后跳多少格。

求从 1 开始最少需要跳几次就能到达第 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个格子。

示例1

输入：

```
2,[1,2]
```

复制

返回值：

```
1
```

复制

说明：

```
从1号格子只需要跳跃一次就能到达2号格子  
```

**示例2**

输入：

```
3,[2,3,1]
```

复制

返回值：

```
1
```

复制

说明：

```
从1号格子只需要跳一次就能直接抵达3号格子  
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 最少需要跳跃几次能跳到末尾
     * @param n int整型 数组A的长度
     * @param A int整型一维数组 数组A
     * @return int整型
     */
        public int Jump (int n, int[] A) {
        // write code here
        int count=0;//跳的步数
        int index=0;//当前位置
        int maxStep=0;//最远可跳跃位置
        for(int i=0;i<n-1;i++){
            maxStep=Math.max(maxStep,i+A[i]);//maxStep记录的每次可以达到的最大位置
            if(index>=n){
                break;//当前位置大于长度,表示已经跳完了,出去了
            }
            if(index==i){//当前位置等于i时候,表示遍历到了最后一步跳法跳完时候
                index=maxStep;//根据每处的maxStep,将当前位置换成局部最优的
                count++;//当前位置完成一步跳跃之后,等于最远可到达位置,步数加1
            }
        }
        return count;
    }
}
```

### Leetcode403 青蛙过河

一只青蛙想要过河。 假定河流被等分为若干个单元格，并且在每一个单元格内都有可能放有一块石子（也有可能没有）。 青蛙可以跳上石子，但是不可以跳入水中。

给你石子的位置列表 stones（用单元格序号 升序 表示）， 请判定青蛙能否成功过河（即能否在最后一步跳至最后一块石子上）。

开始时， 青蛙默认已站在第一块石子上，并可以假定它第一步只能跳跃一个单位（即只能从单元格 1 跳至单元格 2 ）。

如果青蛙上一步跳跃了 k 个单位，那么它接下来的跳跃距离只能选择为 k - 1、k 或 k + 1 个单位。 另请注意，青蛙只能向前方（终点的方向）跳跃。

 

示例 1：

输入：stones = [0,1,3,5,6,8,12,17]
输出：true
解释：青蛙可以成功过河，按照如下方案跳跃：跳 1 个单位到第 2 块石子, 然后跳 2 个单位到第 3 块石子, 接着 跳 2 个单位到第 4 块石子, 然后跳 3 个单位到第 6 块石子, 跳 4 个单位到第 7 块石子, 最后，跳 5 个单位到第 8 个石子（即最后一块石子）。

```java
class Solution {
    public boolean canCross(int[] stones) {
        /*
        假设每次都跳 k + 1 步
        0   1   2   3   4   5   6   ：  i
        1   2   3   4   5   6   7   :   step
        那么第 i 个单位最远能够条 i + 1 步

        对于第 i 个石头，前面的石头 j 能否跳到该石头, 假设两石头间的距离为 diff = stones[i] - stones[j],
        需要判断 j 是否存在可以跳跃 diff 步 的能力，而这个能力是由 石头 j 前面的石头决定的
        当前面能够跳 diff 步石头 i 时，那么石头 i 可跳的步数增加 diff - 1 || diff || diff + 1

        因此，我们记录 石头 i 所有能够跳跃的步数
        dp[i][j] 表示 第 i 个石头是否可以跳 j 步

比如 当 石头 j 能够跳到 石头 i 时， diff = stones[i] - stones[j]
那么对于 石头 i 来说，它能够跳跃的步数增加了以下三个
                    dp[i][diff - 1] = true;
                    dp[i][diff] = true;
                    dp[i][diff + 1] = true;
        */
        int len = stones.length;

        //dp[i][j] 表示 第 i 个石头是否可以跳 j 步
        boolean[][] dp = new boolean[len][len + 1];

        //初始条件：第 0 个石头可以跳 1 步
        dp[0][1] = true;

        for(int i = 1; i < len; i++){
            boolean flag = false;
            //因为 石头 i 最大只能跳 i + 1 步，因此 前面的石头 j 到达 石头 i 的距离必须 <= i
            for(int j = i - 1; j >= 0; j--){
                int diff = stones[i] - stones[j];
                if(diff > i){
                    break;
                }
                //对于 石头 j ，它需要跳 diff 步
                if(dp[j][diff]){
                    dp[i][diff - 1] = true;
                    dp[i][diff] = true;
                    dp[i][diff + 1] = true;
                    flag = true;
                }
            }
            //当到达了终点 而 flag ，表示无法从前面的任意石头跳到终点，返回 false
            if(i == len - 1 && !flag){
                return false;
            }
        }
        return true;
    
    }
}
```

### Leetcode-LCP09 最小跳跃次数

为了给刷题的同学一些奖励，力扣团队引入了一个弹簧游戏机。游戏机由 N 个特殊弹簧排成一排，编号为 0 到 N-1。初始有一个小球在编号 0 的弹簧处。若小球在编号为 i 的弹簧处，通过按动弹簧，可以选择把小球向右弹射 jump[i] 的距离，或者向左弹射到任意左侧弹簧的位置。也就是说，在编号为 i 弹簧处按动弹簧，小球可以弹向 0 到 i-1 中任意弹簧或者 i+jump[i] 的弹簧（若 i+jump[i]>=N ，则表示小球弹出了机器）。小球位于编号 0 处的弹簧时不能再向左弹。

为了获得奖励，你需要将小球弹出机器。请求出最少需要按动多少次弹簧，可以将小球从编号 0 弹簧弹出整个机器，即向右越过编号 N-1 的弹簧。

示例 1：

输入：jump = [2, 5, 1, 1, 1, 1]

输出：3

解释：小 Z 最少需要按动 3 次弹簧，小球依次到达的顺序为 0 -> 2 -> 1 -> 6，最终小球弹出了机器。

限制：

1 <= jump.length <= 10^6
1 <= jump[i] <= 10000

```java
class Solution {
    public int minJump(int[] jump) {
        int[] dp = new int[jump.length];
        dp[jump.length - 1] = 1;
        for(int i = jump.length - 2; i > -1; --i){
            dp[i] = jump[i] + i >= jump.length ? 1 : dp[jump[i] + i] + 1;
            //遍历当前位置更新后影响到的后面的位置，只需要更新到dp[j] >= dp[i]+1即可
            //如果遍历到某dp[j]<dp[i]+1就不需要向右遍历了,因为j到dp.length的值会被当前遍历到的dp[j]更新而不是dp[i]+1
             for(int j = i + 1; j < dp.length && dp[j] >= dp[i] + 1; ++j){
                dp[j] = dp[i] + 1;
            }
        }
        return dp[0];
    }
}

```



## 贪心+DFS

### [Leetcode252 会议室](https://leetcode-cn.com/problems/meeting-rooms/)（个数）

给定一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，请你判断一个人是否能够参加这里面的全部会议。

 

示例 1：

输入：intervals = [[0,30],[5,10],[15,20]]
输出：false
示例 2：

输入：intervals = [[7,10],[2,4]]
输出：true

```java
class Solution {
    public boolean canAttendMeetings(int[][] intervals) {
          Arrays.sort(intervals, (o1, o2) -> o1[0] - o2[0]);
        for (int i = 0; i < intervals.length - 1; i++) {
            int[] cur = intervals[i], next = intervals[i + 1];
            if (cur[1] > next[0]) {
                return false;
            }
        }
        return true;
    }   
}
```

### Leetcode253 会议室II（避免冲突 ）

给你一个会议时间安排的数组 intervals ，每个会议时间都会包括开始和结束的时间 intervals[i] = [starti, endi] ，为避免会议冲突，同时要考虑充分利用会议室资源，请你计算至少需要多少间会议室，才能满足这些会议安排。

 

示例 1：

输入：intervals = [[0,30],[5,10],[15,20]]
输出：2
示例 2：

输入：intervals = [[7,10],[2,4]]
输出：1

```java
class Solution {
    public int minMeetingRooms(int[][] intervals) {
        if(intervals == null || intervals.length == 0) return 0; 
        int[] start = new int[intervals.length];
        int[] end = new int[intervals.length];
        for(int i=0;i<intervals.length;i++){
            start[i] = intervals[i][0];
            end[i] = intervals[i][1];
        }
        Arrays.sort(start);
        Arrays.sort(end);
        
        int rooms=0, activeMeeting = 0;
        int i=0,j=0;
        while(i<intervals.length && j<intervals.length){
            if(start[i]<end[j]){
                activeMeeting++;
                i++;
            }else{
                activeMeeting--;
                j++;
         }
            rooms = Math.max(rooms,activeMeeting);
        }
        return rooms;
        
    }
}
```



### Leetcode1229 安排会议日程

你是一名行政助理，手里有两位客户的空闲时间表：slots1 和 slots2，以及会议的预计持续时间 duration，请你为他们安排合适的会议时间。

「会议时间」是两位客户都有空参加，并且持续时间能够满足预计时间 duration 的 最早的时间间隔。

如果没有满足要求的会议时间，就请返回一个 空数组。

 

「空闲时间」的格式是 [start, end]，由开始时间 start 和结束时间 end 组成，表示从 start 开始，到 end 结束。 

题目保证数据有效：同一个人的空闲时间不会出现交叠的情况，也就是说，对于同一个人的两个空闲时间 [start1, end1] 和 [start2, end2]，要么 start1 > end2，要么 start2 > end1。

 

示例 1：

输入：slots1 = [[10,50],[60,120],[140,210]], slots2 = [[0,15],[60,70]], duration = 8
输出：[60,68]

```java
class Solution {
    public List<Integer> minAvailableDuration(int[][] slots1, int[][] slots2, int duration) {
        Arrays.sort(slots1, (o1,o2) -> o1[0]-o2[0]);
        Arrays.sort(slots2, (o1,o2) -> o1[0]-o2[0]);
        List<Integer> res = new ArrayList<>();
        int i = 0, j = 0;
        while(i < slots1.length && j < slots2.length){
            int[] interval_a = slots1[i];
            int[] interval_b = slots2[j];
            if(interval_a[1] <= interval_b[0]){
                i++;
                continue;
            }
            if(interval_a[0] >= interval_b[1]){
                j++;
                continue;
            }
            int start = Math.max(interval_a[0], interval_b[0]);
            int end = Math.min(interval_a[1], interval_b[1]);
            if(end - start >= duration){
                res.add(start);
                res.add(start + duration);
                break;
            }else{
                if(interval_a[1] > interval_b[1]) j++;
                else i++;
            }
        }
        return res;
    }
}
```

### Leetcode1353 最多可以参加的会议数目（个数的排序）

给你一个数组 events，其中 events[i] = [startDayi, endDayi] ，表示会议 i 开始于 startDayi ，结束于 endDayi 。

你可以在满足 startDayi <= d <= endDayi 中的任意一天 d 参加会议 i 。注意，一天只能参加一个会议。

请你返回你可以参加的 最大 会议数目。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/16/e1.png)

输入：events = [[1,2],[2,3],[3,4]]
输出：3
解释：你可以参加所有的三个会议。
安排会议的一种方案如上图。
第 1 天参加第一个会议。
第 2 天参加第二个会议。
第 3 天参加第三个会议。

```java
class Solution {
    final int MAX_N = 100005;

    public int maxEvents(int[][] events) {
        List<Integer>[] arr = new ArrayList[MAX_N];
        int idx = 0, cnt = 0;

        // 记录每个开始时间点的所有下标
        for (int[] p : events) {
            if (arr[p[0]] == null) {
                arr[p[0]] = new ArrayList<>();
            }
            arr[p[0]].add(idx);
            idx++;
        }

        // 小顶堆取最早结束会议
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for (int i = 1; i < MAX_N; i++) {
            var list = arr[i];
            // 加入当前时间点 i 开始的所有会议的结束时间
            if (list != null) {
                for (int j : list) {
                    pq.offer(events[j][1]);
                }
            }
            // 去除所有已结束会议
            while (!pq.isEmpty() && pq.peek() < i) {
                pq.poll();
            }
            // 还有会议可以参加，选个结束时间最早的
            if (!pq.isEmpty()) {
                pq.poll();
                cnt++;
            }
        }

        return cnt;
    }
}
```

### Leetcode 最多可参加会议的价值

我是按天还有value排序（一个二维数组），然后用天数从大到小去扫，每天都把当天可取（过期时间大于当天）的所有加入到一个最大堆，就可以了。

```java
作者：落荒草
链接：https://www.nowcoder.com/discuss/715991?type=post&order=create&pos=&page=2&ncTraceId=&channel=-1&source_id=search_post_nctrack
来源：牛客网

// 本题为考试多行输入输出规范示例，无需提交，不计分。
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();

        while (T-->0){
            int N = sc.nextInt();//商品数量
            int[][] goods = new int[N][2];
            for (int i=0;i<N;i++){
                goods[i][0] = sc.nextInt();//评分
                goods[i][1] = sc.nextInt();//上架持续时间
            }

            Arrays.sort(goods, new Comparator<int[]>() {
                @Override
                public int compare(int[] o1, int[] o2) {
                    //时间最远 价值最大排前面
                   if (o1[1]==o2[1]){
                       return o2[0] - o1[0];
                   }else{
                       return o2[1] - o1[1];
                   }
                }
            });


            int time = goods[0][1];//最远的时间
            int index = 0;//当前扫到的
            int result = 0;
            PriorityQueue<Integer> maxValHeap = new PriorityQueue<>(new Comparator<Integer>() {
                @Override
                public int compare(Integer o1, Integer o2) {
                    return o2.compareTo(o1);
                }
            });//val的大根堆

            while (time > 0){
                //把到当天可以获取的全部加入大根堆 过期时间大于等于今日的
                while (index < N && goods[index][1]>=time){
                    maxValHeap.add(goods[index][0]);
                    index++;
                }
                //当天取一个
                if (!maxValHeap.isEmpty()){
                    result+=maxValHeap.poll();//取出堆顶
                }
                //时间往前
                time--;
            }
            System.out.println(result);
        }
    }
}
```



### Leetcode1751 最多可以的会议数目II（价值的排序）（回溯dfs跳到下一个）

给你一个 events 数组，其中 events[i] = [startDayi, endDayi, valuei] ，表示第 i 个会议在 startDayi 天开始，第 endDayi 天结束，如果你参加这个会议，你能得到价值 valuei 。同时给你一个整数 k 表示你能参加的最多会议数目。

你同一时间只能参加一个会议。如果你选择参加某个会议，那么你必须 完整 地参加完这个会议。会议结束日期是包含在会议内的，也就是说你不能同时参加一个开始日期与另一个结束日期相同的两个会议。

请你返回能得到的会议价值 最大和 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/02/06/screenshot-2021-01-11-at-60048-pm.png)

输入：events = [[1,2,4],[3,4,3],[2,3,1]], k = 2
输出：7
解释：选择绿色的活动会议 0 和 1，得到总价值和为 4 + 3 = 7 。

**暴力**

```java
class Solution {
         public int maxValue(int[][] events, int k) {
            int n = events.length;
            //因为递归是自顶向下，按会议的开始时间从小到大排序，区别于自底向上的dp 填表的方式
            Arrays.sort(events, (o1, o2) -> o1[0] - o2[0]);
            return helper(events, 0, n, k);
        }

        private int helper(int[][] events, int curr, int n, int k) {
            //退出递归的出口，当curr到末尾或者剩余参加会议的机会或是次数k用完了
            if (curr >= n || k <= 0) return 0;
            int i = 0;//找curr之后满足条件最靠近curr这个会议的 下个会议 可以二分来加速
            for (i = curr + 1; i < n; i++) {
                if (events[i][0] > events[curr][1]) break;
            }
            //参加当前的会议，下个会议是 i 此 i 会议开始的时间大于当前会议 curr的结束时间 此时k用掉了一次，-1
            //不参加当前会议，跳到下个会议  此时k没有使用 保持不变
            int ans = Math.max(helper(events, i, n, k - 1) + events[curr][2], helper(events, curr + 1, n, k));
            return ans;
        }

}
```



```java
class Solution {
    public int maxValue(int[][] events, int k) {
        int ans = 0;
        //预处理，以会议截止日期排序
        Arrays.sort(events,new Comparator<int[]>(){
            @Override
            public int compare(int[] a, int[] b) {
                return a[1] - b[1];
            }
        });
        //保存每轮依次计算以第i个会议为小明要参加的第k次会议取得的最大价值
        TreeMap<Integer,Integer> map = new TreeMap<>();
        //加这句便于查询，不然需要特定判断
        map.put(0,0);
        for(int L=1;L<=k;L++){
            TreeMap<Integer,Integer> tmp = new TreeMap<>();
            //同上，便于判断
            tmp.put(0,0);
            for(int[] event:events){
                int start = event[0];
                int end = event[1];
                int val = event[2];
                Integer key = map.floorKey(start-1);
                //start之前不一定有符合条件的L-1个会议
                if(key == null){
                    continue;
                }
                //小明要参加第i个会议，那么要计算start之前的(L-1)次会议的最大价值+第i次会议价值，保存在tmp里面
                int tmpval = map.get(key) + val;
                //本轮中小明要参加的第L次会议，end为右侧边界能获取的最大价值，更新
                tmp.put(end, Math.max(tmpval, tmp.get(tmp.floorKey(end))));
            }
            //本轮处理完成后，比较中间值更新结果
            ans = Math.max(ans,tmp.get(tmp.floorKey((int)1e9)));
            map = tmp;
        }
        return ans;
    }
}

```

**动态规划**

```java
class Solution {
    public int maxValue(int[][] events, int k) {
        Arrays.sort(events, Comparator.comparingInt(x -> x[1]));

        int n = events.length;
        int[] pre = new int[events.length];
        Arrays.fill(pre, -1);
        for (int i = 0; i < n; i++) {
            for (int j = i - 1; j >= 0; j--) {
                if (events[j][1] >= events[i][0]) {
                    continue;
                }
                pre[i] = j;
                break;
            }
        }

        int[][] dp = new int[events.length+1][k + 1];
        for (int i = 1; i <= events.length; i++) {
            for (int j = 1; j <= k; j++) {
                dp[i][j]=Math.max(dp[i-1][j],dp[pre[i-1]+1][j-1]+events[i-1][2]);
            }
        }
        return dp[events.length][k];
    }
}
```

**按照结束时间**

```java
class Solution {
    public int maxValue(int[][] events, int k) {
        Arrays.sort(events, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[1]-o2[1];
            }
        });//按照结束时间排序
        int n=events.length;
        int[][]dp=new int[n+1][k+1];//dp[i][j]表示有i个会议可选，剩余参加名额为j的最大价值
        boolean flag=false;
        for(int i=1;i<=n;i++){
            int h=i-2;
            flag=false;
            for(;h>=0;h--){//直接查找参加当前会议的前面的会议结束时间小于当前会议的开始时间
                if(events[h][1]<events[i-1][0]){
                    flag=true;
                    break;
                }
            }
            if(flag==false){
                h=-1;
            }
            for(int j=k-1;j>-1;j--){
              dp[i][j]= Math.max(dp[i-1][j],events[i-1][2]+dp[h+1][j+1]);//在参加会议和不参加当前会议中取较大值
            }
        }
        return dp[n][0];

    }
}
```



**比较简短的流程**

```java
class Solution {
    public int maxValue(int[][] events, int k) {
        int n = events.length;
        int[][] es = new int[n+1][3];
        es[0][0] = es[0][1] = es[0][2] = 0;
        for(int i = 1; i <= n; i++){
            es[i] = events[i-1];
        }
        Arrays.sort(es, (e1, e2) -> e1[1] - e2[1]);
        int[][] f = new int[n+1][k+1];
        // f[i][j]表示从前i个区间中选至少j个区间的最大值
        // 第0个区间为哨兵，如果前面的区间都不满足条件，则第0个区间一定满足条件，无需特判
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= k; j++){
                // 选第i个区间
                int l = 0, r = i-1;
                while(l < r){
                    int mid = l + r + 1 >> 1;
                    if(es[mid][1] < es[i][0]) l = mid;
                    else r = mid - 1;
                }
                f[i][j] = Math.max(f[i-1][j], f[l][j-1] + es[i][2]);
            }
        }
        return f[n][k];
    }
}
```





### Leetcode岛屿泛洪

湖泊抽水问题
时间限制： 3000MS
内存限制： 589824KB
题目描述：
你的省份有多个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水



输入描述
给你一个整数数组 rains ，其中：

rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。

rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水

输出描述
返回一个数组 ans ，满足：

ans.length == rains.length

如果 rains[i] > 0 ，那么ans[i] == -1 。

如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。

如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组


样例输入
[1,2,0,0,2,1]
样例输出
[-1,-1,2,1,-1,-1]

提示
贪心、搜索；

请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生

```java
public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
      	String str2 = str.split("\\[")[1].split("\\]")[0];
      	String[] str_arr = str2.split(",");
      	int len = str_arr.length;
      	int[] nums = new int[len];
      	for(int i=0;i<len;i++) {
      		nums[i] = Integer.valueOf(str_arr[i]);
      	}
      	int[] res = new int[len];
      	//填充
      	Arrays.fill(res, -1);
      	//记录rains[i]->i
      	Map<Integer,Integer> dict = new HashMap<>();
      	//记录0的位置
      	LinkedList<Integer> zeros = new LinkedList<>();
      	for(int i=0;i<len;i++) {
      		//发生了
      		if(nums[i]>0) {
      			//判断是否出现过了
      			if(dict.containsKey(nums[i])) {
      				int prev = dict.get(nums[i]);
      				//没有可以抽水的天数
      				if(zeros.size()==0 || zeros.getLast()<prev) {
      	      			System.out.print("[]");
      	      			return;
      				}
      				int day = -1;
      				Iterator<Integer> iter = zeros.iterator();
      				while((day=iter.next())<=prev);
      				iter.remove();
      				//赋值
      				res[day] = nums[i];
      			}
      			dict.put(nums[i],i);
      		}else {
      			//记录没有发生洪水的日子
      			zeros.add(i);
      		}
      	}
      	// 还剩下值
      	for(int idx:zeros) {
      		res[idx] = 1;
      	}
      	
      	//输出结果
      	for(int i=0;i<len;i++) {
      		if(i==0) {
      			System.out.print("["+res[i]+",");
      		}else if(i!=len-1){
      			System.out.print(res[i]+",");
      		}else {
      			System.out.print(res[i]+"]");
      		}
      	}
    }
```

### [NC147 主持人调度](https://www.nowcoder.com/practice/4edf6e6d01554870a12f218c94e8a299?tpId=188&&tqId=38647&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

有 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个活动即将举办，每个活动都有开始时间与活动的结束时间，第 ![img](https://www.nowcoder.com/equation?tex=i%5C) 个活动的开始时间是 start_i*s**t**a**r**t**i* ,第 ![img](https://www.nowcoder.com/equation?tex=i%5C) 个活动的结束时间是 end_i*e**n**d**i* ,举办某个活动就需要为该活动准备一个活动主持人。

一位活动主持人在同一时间只能参与一个活动。并且活动主持人需要全程参与活动，换句话说，一个主持人参与了第 ![img](https://www.nowcoder.com/equation?tex=i%5C) 个活动，那么该主持人在 (start_i,end_i)(*s**t**a**r**t**i*,*e**n**d**i*) 这个时间段不能参与其他任何活动。求为了成功举办这 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个活动，最少需要多少名主持人。

数据范围:
1 \le n \le 10^51≤*n*≤105
-2^{32} \le start_i,end_i \le 2^{31}-1−232≤*s**t**a**r**t**i*​,*e**n**d**i*​≤231−1

**示例1**

输入：

```
2,[[1,2],[2,3]]
```

复制

返回值：

```
1
```

复制

说明：

```
只需要一个主持人就能成功举办这两个活动  
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算成功举办活动需要多少名主持人
     * @param n int整型 有n个活动
     * @param startEnd int整型二维数组 startEnd[i][0]用于表示第i个活动的开始时间，startEnd[i][1]表示第i个活动的结束时间
     * @return int整型
     */
    public int minmumNumberOfHost (int n, int[][] startEnd) {
        int[] starts = new int[startEnd.length];
        int[] ends = new int[startEnd.length];
        for(int i = 0 ;i < startEnd.length;i++){
            starts[i] = startEnd[i][0];
            ends[i] = startEnd[i][1];
        }
        Arrays.sort(starts);
        Arrays.sort(ends);
        int count = 0;
        int end = 0;
        for(int start = 0;start< startEnd.length;start++){
            if(starts[start] >= ends[end]){
                end++;
            }else{
                count++;
            }
        }
        return count;
    }
}
```



### [区间调度问题-1.Leetcode435 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)


给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

**注意:**

1. 可以认为区间的终点总是大于它的起点。
2. 区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。

**示例 1:**

```
输入: [ [1,2], [2,3], [3,4], [1,3] ]

输出: 1

解释: 移除 [1,3] 后，剩下的区间没有重叠。
```

> 解题思路：贪心

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        //排序
        // 按结束时间排序
        Arrays.sort(intervals,((a,b)->(a[1]-b[1])));
        int end = intervals[0][1];
        // 结果
        int res = 1;
        for(int[] other:intervals){
            int start = other[0];
            if(start>=end){
                res++;
                end = other[1];
            }
        }
        return intervals.length-res;
    }
}
```

### [区间调度问题-2.Leetcode452 用最少的数量的箭引爆气球](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以纵坐标并不重要，因此只要知道开始和结束的横坐标就足够了。开始坐标总是小于结束坐标。

一支弓箭可以沿着 x 轴从不同点完全垂直地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

给你一个数组 points ，其中 points [i] = [xstart,xend] ，返回引爆所有气球所必须射出的最小弓箭数。


示例 1：

输入：points = [[10,16],[2,8],[1,6],[7,12]]
输出：2
解释：对于该样例，x = 6 可以射爆 [2,8],[1,6] 两个气球，以及 x = 11 射爆另外两个气球

```java
class Solution {
    public int findMinArrowShots(int[][] points) {
        // 排序
        Arrays.sort(points,((a,b)->(Integer.compare(a[1],b[1]))));
        // 结果
        int res = 1;
        int end = points[0][1];
        // 开始
        for(int[] other:points){
            int start =other[0];
            if(start>end){
                res++;
                end = other[1];
            }
        }
        return res;

    }
}
```

### [区间调度问题-3.Leetcode630 课程表III](https://leetcode-cn.com/problems/course-schedule-iii/)

这里有 n 门不同的在线课程，他们按从 1 到 n 编号。每一门课程有一定的持续上课时间（课程时间）t 以及关闭时间第 d 天。一门课要持续学习 t 天直到第 d 天时要完成，你将会从第 1 天开始。

给出 n 个在线课程用 (t, d) 对表示。你的任务是找出最多可以修几门课。

 

示例：

输入: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]]
输出: 3
解释: 
这里一共有 4 门课程, 但是你最多可以修 3 门:
首先, 修第一门课时, 它要耗费 100 天，你会在第 100 天完成, 在第 101 天准备下门课。
第二, 修第三门课时, 它会耗费 1000 天，所以你将在第 1100 天的时候完成它, 以及在第 1101 天开始准备下门课程。
第三, 修第二门课时, 它会耗时 200 天，所以你将会在第 1300 天时完成它。
第四门课现在不能修，因为你将会在第 3300 天完成它，这已经超出了关闭日期。

```java
class Solution {
    public int scheduleCourse(int[][] courses) {
        //duration和deadline
        Arrays.sort(courses,((a,b)->(a[1]-b[1])));
        // 大顶堆记录duration
        PriorityQueue<Integer> queue = new PriorityQueue<>((a,b)->(b-a));
        // 开始
        int time = 0;
        for(int[] course:courses){
            int duration = course[0];
            int deadline = course[1];
            if(time+duration<=deadline){
                time = time + duration;
                queue.offer(duration);
            }else{
                queue.offer(duration);
                time = time + duration - queue.poll();
            }
        }
        return queue.size();
    }
}
```



### [贪心游戏-1.Leetcode55跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

```java
class Solution {
    public boolean canJump(int[] nums) {
        // 跳跃游戏
        int long_path = 0;
        int n =nums.length-1;
        for(int i=0;i<n;i++){
            long_path = Math.max(long_path,i+nums[i]);
            if(i>=long_path){
                return false;
            }
        }
        // 判断
        return long_path>=n-1;
    }
}
```

### [贪心游戏-2.Leetcode45 跳跃游戏II](https://leetcode-cn.com/problems/jump-game-ii/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

输入: [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

```java
class Solution {
    public int jump(int[] nums) {
        int long_path = 0;
        // 结果统计
        int count = 0;
        int end = 0;
        // 长度
        int len = nums.length-1;
        for(int i=0;i<len;i++){
            long_path = Math.max(long_path,i+nums[i]);
            if(i==end){
                count++;
                end = long_path;
            }
        }
        return count;
    }
}
```

### [贪心游戏-Leetcode1306 跳跃游戏III](https://leetcode-cn.com/problems/jump-game-iii/)

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

 

示例 1：

输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 

```java

class Solution {//深度优先搜索
    public boolean canReach(int[] arr, int start) {
        boolean[] dp=new boolean[arr.length];
        return dfs(arr,dp,start);
    }

    public boolean dfs(int[] arr,boolean[] dp,int start){
        if(start<0||start>=arr.length)return false;

        if(arr[start]==0)return true;

        if(dp[start]){
            return false;
        }else{
            dp[start]=true;
        }

        return dfs(arr,dp,start+arr[start])||dfs(arr,dp,start-arr[start]);
    }
}

```



### [NVC148 几步可以从跳到尾](https://www.nowcoder.com/practice/de62bcee9f9a4881ac80cce6da42b135?tpId=117&&tqId=37858&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

给你一个长度为 ![img](https://www.nowcoder.com/equation?tex=n%5C) 的数组 ![img](https://www.nowcoder.com/equation?tex=A%5C)。

![img](https://www.nowcoder.com/equation?tex=A%5Bi%5D%5C) 表示从 ![img](https://www.nowcoder.com/equation?tex=i%5C) 这个位置开始最多能往后跳多少格。

求从 1 开始最少需要跳几次就能到达第 ![img](https://www.nowcoder.com/equation?tex=n%5C) 个格子。

示例1

输入：

```
2,[1,2]
```

复制

返回值：

```
1
```

复制

说明：

```
从1号格子只需要跳跃一次就能到达2号格子  
```

**示例2**

输入：

```
3,[2,3,1]
```

复制

返回值：

```
1
```

复制

说明：

```
从1号格子只需要跳一次就能直接抵达3号格子  
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 最少需要跳跃几次能跳到末尾
     * @param n int整型 数组A的长度
     * @param A int整型一维数组 数组A
     * @return int整型
     */
        public int Jump (int n, int[] A) {
        // write code here
        int count=0;//跳的步数
        int index=0;//当前位置
        int maxStep=0;//最远可跳跃位置
        for(int i=0;i<n-1;i++){
            maxStep=Math.max(maxStep,i+A[i]);//maxStep记录的每次可以达到的最大位置
            if(index>=n){
                break;//当前位置大于长度,表示已经跳完了,出去了
            }
            if(index==i){//当前位置等于i时候,表示遍历到了最后一步跳法跳完时候
                index=maxStep;//根据每处的maxStep,将当前位置换成局部最优的
                count++;//当前位置完成一步跳跃之后,等于最远可到达位置,步数加1
            }
        }
        return count;
    }
}
```

### 

### [1.Leetcode392 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

 

示例 1：

输入：s = "abc", t = "ahbgdc"
输出：true
示例 2：

输入：s = "axc", t = "ahbgdc"
输出：false

> 解题思路：贪心算法

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        t = ' ' + t;
        // 对t进行预处理
        int[][] dp = new int[t.length()][26];
        for(char c='a';c<='z';c++){
            int nextPos = -1;
            for(int i=t.length()-1;i>=0;i--){
                dp[i][c-'a'] = nextPos;
                if(t.charAt(i)==c){
                    nextPos = i;
                }
            }
        }
        // 开始
        int index = 0;
        for(char c:s.toCharArray()){
            index = dp[index][c-'a'];
            if(index==-1){
                return false;
            }
        }
        return true;
    }
}
```

### [2.Leetcode605 种花问题](https://leetcode-cn.com/problems/can-place-flowers/)

假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给你一个整数数组  flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。

 

示例 1：

输入：flowerbed = [1,0,0,0,1], n = 1
输出：true
示例 2：

输入：flowerbed = [1,0,0,0,1], n = 2
输出：false

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count = 0;
        // 对其遍历
        for(int i=0;i<flowerbed.length;i++){
            if(flowerbed[i]==0&&(i==0 || flowerbed[i-1]==0)&&(i==flowerbed.length-1 || flowerbed[i+1]==0)){
                count++;
                flowerbed[i] = 1;
            }
        }
        return count>=n;
    }
}
```

### [3.Leetcode455 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。


示例 1:

输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        // 结果
        int count = 0;
        int g_len = g.length;
        int s_len = s.length;
        // 开始
        for(int i=0,j=0;i<g_len&&j<s_len;i++,j++){
            // 使得j满足
            while(j<s_len&&g[i]>s[j]){
                j++;
            }
            if(j<s_len){
                count++;
            }
        }
        return count;
    }
}
```

### [4.Leetcode763 划分字母区间](https://leetcode-cn.com/problems/partition-labels/)

字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。

 

示例：

输入：S = "ab



abcbacadefegdehijhklij"
输出：[9,7,8]
解释：
划分结果为 "ababcbaca", "defegde", "hijhklij"。
每个字母最多出现在一个片段中。
像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。

```java
class Solution {
    // 贪心思想
    public List<Integer> partitionLabels(String s) {
        // 记录字母最后出现的位置
        int len = s.length();
        int[] last = new int[26];
        for(int i=0;i<len;i++){
            last[s.charAt(i)-'a'] = i;
        }
        // 划分
        List<Integer> partition = new ArrayList<>();
        // 遍历
        int end = 0;
        int start = 0;
        for(int i=0;i<s.length();i++){
            // 维护一个end
            end = Math.max(end,last[s.charAt(i)-'a']);
            if(i==end){
                partition.add(end-start+1);
                start = end+1;
            }
        }
        return partition;
    }
}
```

### [5.Leetcode134 加油站](https://leetcode-cn.com/problems/gas-station/)

在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。

你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。

如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。

说明: 

如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
示例 1:

输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

输出: 3

解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

> 解题思路：环形的思路

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        // 剩余的油量
        int rest = 0;
        //跑的油量
        int run = 0;
        // 记录起点
        int start = 0;
        //遍历
        for(int i=0;i<gas.length;i++){
            run += (gas[i]-cost[i]);
            rest += (gas[i]-cost[i]);
            if(run<0){
                run = 0;
                start = i+1;
            }
        }
        return rest<0?-1:start;
    }
}
```

### [6.Leetcode406 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

 

示例 1：

输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        // 从身高从高到低排，然后按数量排序低到高排序；
        Arrays.sort(people,((a,b)->(a[0]==b[0]?a[1]-b[1]:b[0]-a[0])));
        List<int[]> list = new ArrayList<>();
        for(int[] person:people){
            list.add(person[1],person);
        }
        return list.toArray(new int[res.size()][]);
    }
}
```

### [7.Leetcode1221 分割平衡字符串](https://leetcode-cn.com/problems/split-a-string-in-balanced-strings/)

在一个 平衡字符串 中，'L' 和 'R' 字符的数量是相同的。

给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

注意：分割得到的每个字符串都必须是平衡字符串。

返回可以通过分割得到的平衡字符串的 最大数量 。

 

示例 1：

输入：s = "RLRRLLRLRL"
输出：4
解释：s 可以分割为 "RL"、"RRLL"、"RL"、"RL" ，每个子字符串中都包含相同数量的 'L' 和 'R' 。

> 平衡系数

```java
class Solution {
    public int balancedStringSplit(String s) {
        int res = 0;
        int t = 0;
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)=='L'){
                t++;
            }else{
                t--;
            }
            if(t==0){
                res++;
            }
        }
        return res;
    }
}
```

### [8.Leetcode765 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)

N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。

人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。

这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。

示例 1:

输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。
示例 2:

输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。

```java
class Solution {
    public int minSwapsCouples(int[] row) {
        // 贪心思想：碰到一对不是情侣的，就替换
        int operations = 0;
        for(int i=0;i<row.length;i+=2){
            int x = row[i];
            // 判断是否相同
            if(row[i+1]==(x^1)){
                continue;
            }
            // 不相同交换
            operations++;
            for(int j=i+1;j<row.length;j++){
                if(row[j]==(x^1)){
                    row[j] = row[i+1];
                    row[i+1]= x^1;
                    break;
                }
            }
        }
        return operations;
    }
}
```

### [9.Leetcode1029 两地调度](https://leetcode-cn.com/problems/two-city-scheduling/)

公司计划面试 2n 人。给你一个数组 costs ，其中 costs[i] = [aCosti, bCosti] 。第 i 人飞往 a 市的费用为 aCosti ，飞往 b 市的费用为 bCosti 。

返回将每个人都飞到 a 、b 中某座城市的最低费用，要求每个城市都有 n 人抵达。

 

示例 1：

输入：costs = [[10,20],[30,200],[400,50],[30,20]]
输出：110
解释：
第一个人去 a 市，费用为 10。
第二个人去 a 市，费用为 30。
第三个人去 b 市，费用为 50。
第四个人去 b 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。

> 解题思路：

```java
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        // 自定义排序
        Arrays.sort(costs,((o1,o2)->( o1[0]-o1[1]-(o2[0]-o2[1]) )));
        int total =0;
        int n = costs.length/2;
        for(int i=0;i<n;i++){
            total += costs[i][0] + costs[i+n][1];
        }
        return total;
    }
}
```

### Leetcode1109 航班预订统计

这里有 n 个航班，它们分别从 1 到 n 进行编号。

有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。

请你返回一个长度为 n 的数组 answer，其中 answer[i] 是航班 i 上预订的座位总数。

 

示例 1：

输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
输出：[10,55,45,25,25]
解释：
航班编号        1   2   3   4   5
预订记录 1 ：   10  10
预订记录 2 ：       20  20
预订记录 3 ：       25  25  25  25
总座位数：      10  55  45  25  25
因此，answer = [10,55,45,25,25]

```java
class Solution {
    public int[] corpFlightBookings(int[][] bookings, int n) {
         // 类同1094题思想，使用差分思想。
        int[] b = new int[n + 2]; // 由于航班下标从1开始，且右区间是r+1，所以定义长度+2
        for (int i = 0; i < bookings.length; i++) {
            int l = bookings[i][0];
            int r = bookings[i][1];
            int c = bookings[i][2];

            b[l] += c;
            b[r + 1] -= c;
        }
        for (int i = 1; i < b.length; i++) {
            b[i] += b[i - 1];
        }
        return Arrays.copyOfRange(b, 1, b.length - 1);
    }
}
```

### Leetcode815 公交路线

给你一个数组 routes ，表示一系列公交线路，其中每个 routes[i] 表示一条公交线路，第 i 辆公交车将会在上面循环行驶。

例如，路线 routes[0] = [1, 5, 7] 表示第 0 辆公交车会一直按序列 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... 这样的车站路线行驶。
现在从 source 车站出发（初始时不在公交车上），要前往 target 车站。 期间仅可乘坐公交车。

求出 最少乘坐的公交车数量 。如果不可能到达终点车站，返回 -1 。

 

示例 1：

输入：routes = [[1,2,7],[3,6,7]], source = 1, target = 6
输出：2
解释：最优策略是先乘坐第一辆公交车到达车站 7 , 然后换乘第二辆公交车到车站 6 。 
示例 2：

输入：routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12
输出：-1

```java
class Solution {
    // BFS 解法
    // 1. 状态定义：将一条公交路线定义为一个状态, 而状态转移就是从一个公交路线转移到另一条公交路线. 其中 每条路线可以使用routes的下标表示, routes[i]就表示i条路线
    // 2. 状态存储：使用一个队列来存储公交路线
    // 3. 距离存储：d[x] = a, 存储当前公交路线到起点公交路线的距离
    // 思想：每个「路线」为一个点，当不同「路线」之间存在「公共车站」则为其增加一条边权为 1 的无向边
    public int numBusesToDestination(int[][] routes, int source, int target) {
        
        if (source == target)
            return 0;

        int len = routes.length;

        // 初始化距离
        int[] distance = new int[len];
        Arrays.fill(distance, -1);
        
        // 从车站(key)可以到达的所有公交线路(value)
        Map<Integer, Set<Integer>> pathMap = new HashMap<>();
        // 存储走过的公交路线
        Deque<Integer> queue = new LinkedList<>();

        // 1. 找到起始车站所在的公交路线, 并计算每个车站能到达的所有公交路线
        for (int i = 0; i < len; i++) {
            for (int station : routes[i]) {
                if (station == source) {
                    // 初始到路线i的距离为1, 因为初始车站就在i路线上
                    distance[i] = 1;
                    // 当前初始路线进队
                    queue.offer(i);
                }
                // 记录车站station所有能到达的路线
                Set<Integer> set = pathMap.getOrDefault(station, new HashSet<>());
                set.add(i);
                pathMap.put(station, set);
            }
        }

        while (!queue.isEmpty()) {
            // 取出当前路线
            int x = queue.poll();
            
            // 遍历当前路线的所有车站
            for (int station : routes[x]) {
                // 当前路线上有目标车站, 则之间范围
                if (station == target) {
                    return distance[x];
                }

                // 该车站能到达的所有路线
                Set<Integer> paths = pathMap.get(station);
                if (paths == null)  continue;
                for (Integer path : paths) {
                    if (distance[path] == -1) {
                        distance[path] = distance[x] + 1;
                        queue.offer(path);
                    }
                }

            }
        } 
        return -1;
    }
}
```

### Leetcode1723 完成所有广告的最短时间

你一个整数数组 jobs ，其中 jobs[i] 是完成第 i 项工作要花费的时间。

请你将这些工作分配给 k 位工人。所有工作都应该分配给工人，且每项工作只能分配给一位工人。工人的 工作时间 是完成分配给他们的所有工作花费时间的总和。请你设计一套最佳的工作分配方案，使工人的 最大工作时间 得以 最小化 。

返回分配方案中尽可能 最小 的 最大工作时间 。

 

示例 1：

输入：jobs = [3,2,3], k = 3
输出：3
解释：给每位工人分配一项工作，最大工作时间是 3 。
示例 2：

输入：jobs = [1,2,4,7,8], k = 2
输出：11
解释：按下述方式分配工作：
1 号工人：1、2、8（工作时间 = 1 + 2 + 8 = 11）
2 号工人：4、7（工作时间 = 4 + 7 = 11）
最大工作时间是 11 。

```java
class Solution {
    int min=Integer.MAX_VALUE;
    public int minimumTimeRequired(int[] jobs, int k) {
        dfs(new int[k],jobs,0,0);
        return min;
    }
    public void dfs(int[]k,int[] arr,int sta,int max)
    {
        if(max>=min)return;
        if(sta==arr.length)
        {
            min=max;
            return;
        }
        for(int i=0;i<Math.min(k.length,sta+1);i++)
        {
            k[i]+=arr[sta];
            dfs(k,arr,sta+1,Math.max(max,k[i]));
            k[i]-=arr[sta];
        }
    }
}
```

### Leetcode1094 拼车


假设你是一位顺风车司机，车上最初有 `capacity` 个空座位可以用来载客。由于道路的限制，车 **只能** 向一个方向行驶（也就是说，**不允许掉头或改变方向**，你可以将其想象为一个向量）。

这儿有一份乘客行程计划表 `trips[][]`，其中 `trips[i] = [num_passengers, start_location, end_location]` 包含了第 `i` 组乘客的行程信息：

- 必须接送的乘客数量；
- 乘客的上车地点；
- 以及乘客的下车地点。

这些给出的地点位置是从你的 **初始** 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。

请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所有乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 `true`，否则请返回 `false`）。

 

**示例 1：**

```
输入：trips = [[2,1,5],[3,3,7]], capacity = 4
输出：false
```

**示例 2：**

```
输入：trips = [[2,1,5],[3,3,7]], capacity = 5
输出：true
```

```java
class Solution 
{
    public boolean carPooling(int[][] trips, int capacity) 
    {
        int [] f = new int[1002];
        for (int [] v: trips)
        {
            int x = v[0], L = v[1], R = v[2];
            f[L] += x;
            f[R] -= x;
        }

        if (f[0] > capacity)
            return false;
        for (int i=1; i<1002; i++)
        {
            f[i] = f[i-1] + f[i];
            if (f[i] > capacity)
                return false;
        }
        return true;
    }
}

```

### Leetcode826 安排工作已达到最大收益

有一些工作：difficulty[i] 表示第 i 个工作的难度，profit[i] 表示第 i 个工作的收益。

现在我们有一些工人。worker[i] 是第 i 个工人的能力，即该工人只能完成难度小于等于 worker[i] 的工作。

每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。

举个例子，如果 3 个工人都尝试完成一份报酬为 1 的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。

我们能得到的最大收益是多少？

 

示例：

输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]
输出: 100 
解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。

```java
class Solution {
    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {
        int[] dp = new int[(int) Math.pow(10, 5)];
        int maxIndex = Integer.MIN_VALUE, minIndex = Integer.MAX_VALUE;
        for (int i = 0; i < difficulty.length; i++) {
            if (dp[difficulty[i]] < profit[i]) {
                dp[difficulty[i]] = profit[i];
            }
            if (difficulty[i] > maxIndex) maxIndex = difficulty[i];
            if (difficulty[i] < minIndex) minIndex = difficulty[i];
        }
        int max = 0;
        for (int i = minIndex; i <= maxIndex; i++) {
            if (max > dp[i]) {
                dp[i] = max;
            } else {
                max = dp[i];
            }
        }
        final int num = maxIndex;
        return Arrays.stream(worker).map(w -> {
            if (w > num) {
                return dp[num];
            }
            return dp[w];
        }).sum();
    }
}
```

### Leetcode879 盈利计划

集团里有 n 名员工，他们可以完成各种各样的工作创造利润。

第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。如果成员参与了其中一项工作，就不能参与另一项工作。

工作的任何至少产生 minProfit 利润的子集称为 盈利计划 。并且工作的成员总数最多为 n 。

有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。

 

示例 1：

输入：n = 5, minProfit = 3, group = [2,2], profit = [2,3]
输出：2
解释：至少产生 3 的利润，该集团可以完成工作 0 和工作 1 ，或仅完成工作 1 。
总的来说，有两种计划。
示例 2：

输入：n = 10, minProfit = 5, group = [2,3,5], profit = [6,7,8]
输出：7
解释：至少产生 5 的利润，只要完成其中一种工作就行，所以该集团可以完成任何工作。
有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。

```java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {
        int len = group.length, MOD = (int)1e9 + 7;
        int[][][] dp = new int[len + 1][n + 1][minProfit + 1];
        dp[0][0][0] = 1;
        for (int i = 1; i <= len; i++) {
            int members = group[i - 1], earn = profit[i - 1];
            for (int j = 0; j <= n; j++) {
                for (int k = 0; k <= minProfit; k++) {
                    if (j < members) {
                        dp[i][j][k] = dp[i - 1][j][k];
                    } else {
                        dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - members][Math.max(0, k - earn)]) % MOD;
                    }
                }
            }
        }
        int sum = 0;
        for (int j = 0; j <= n; j++) {
            sum = (sum + dp[len][j][minProfit]) % MOD;
        }
        return sum;
    }
}


```



## DFS

#### [贪心游戏-Leetcode1306 跳跃游戏III](https://leetcode-cn.com/problems/jump-game-iii/)

这里有一个非负整数数组 arr，你最开始位于该数组的起始下标 start 处。当你位于下标 i 处时，你可以跳到 i + arr[i] 或者 i - arr[i]。

请你判断自己是否能够跳到对应元素值为 0 的 任一 下标处。

注意，不管是什么情况下，你都无法跳到数组之外。

 

示例 1：

输入：arr = [4,2,3,0,3,1,2], start = 5
输出：true
解释：
到达值为 0 的下标 3 有以下可能方案： 
下标 5 -> 下标 4 -> 下标 1 -> 下标 3 
下标 5 -> 下标 6 -> 下标 4 -> 下标 1 -> 下标 3 

```java
class Solution {//深度优先搜索
    public boolean canReach(int[] arr, int start) {
        boolean[] dp=new boolean[arr.length];
        return dfs(arr,dp,start);
    }

    public boolean dfs(int[] arr,boolean[] dp,int start){
        if(start<0||start>=arr.length)return false;

        if(arr[start]==0)return true;

        if(dp[start]){
            return false;
        }else{
            dp[start]=true;
        }

        return dfs(arr,dp,start+arr[start])||dfs(arr,dp,start-arr[start]);
    }
}

```



#### [1.Leetcode1219 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)

你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。

为了使收益最大化，矿工需要按以下规则来开采黄金：

每当矿工进入一个单元，就会收集该单元格中的所有黄金。
矿工每次可以从当前位置向上下左右四个方向走。
每个单元格只能被开采（进入）一次。
不得开采（进入）黄金数目为 0 的单元格。
矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。


示例 1：

输入：grid = [[0,6,0],[5,8,7],[0,9,0]]
输出：24
解释：
[[0,6,0],
 [5,8,7],
 [0,9,0]]
一种收集最多黄金的路线是：9 -> 8 -> 7。

```java
class Solution {
    public int getMaximumGold(int[][] grid) {
        int res = 0;
        int m = grid.length;
        int n = grid[0].length;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]!=0){
                    res = Math.max(res,dfs(grid,i,j));
                }
            }
        } 
        return res;
    }

    public int dfs(int[][] grid,int i,int j){
        // 递归截止条件
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){
            return 0;
        }
        // 记录
        int temp = grid[i][j];
        grid[i][j] = 0;
        int count = temp;
        int leftcount = dfs(grid,i-1,j);
        int rightcount = dfs(grid,i+1,j);
        int upcount = dfs(grid,i,j-1);
        int downcount = dfs(grid,i,j+1);
        int othercount = Math.max(leftcount,Math.max(rightcount,Math.max(upcount,downcount)));
        grid[i][j] = temp;
        
        return count + othercount;
    }
}
```

#### [2.Leetcode200 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

示例 1：

输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1

```java
class Solution {
    public int numIslands(char[][] grid) {
        int count = 0;
        int n = grid.length;
        int m = grid[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]=='1'){
                    count++;
                    // 渲染
                    dfs(grid,i,j);
                }
            }
        }
        return count;
    }
    public void dfs(char[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length|| grid[i][j]!='1'){
            return;
        }
        grid[i][j] = '2';
        dfs(grid,i+1,j);
        dfs(grid,i-1,j);
        dfs(grid,i,j-1);
        dfs(grid,i,j+1);
    }
}
```

#### [3.Leetcode1254 统计封闭岛屿的数量](https://leetcode-cn.com/problems/number-of-closed-islands/)

有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。

我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。

如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。

请返回封闭岛屿的数目。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/07/sample_3_1610.png)

输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]
输出：2
解释：
灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。
示例 2：

> 解题思路：

```java
class Solution {
    public int closedIsland(int[][] grid) {
        int count = 0;
        int n = grid.length;
        int m = grid[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                // 判断
                if(grid[i][j]==0&&dfs(grid,i,j)){
                    count++;
                }
            }
        }
        return count;
    }

    // 统计
    public boolean dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length){
            return false;
        }
        if(grid[i][j]!=0){
            return true;
        }
        grid[i][j] = 2;
        boolean left = dfs(grid,i+1,j);
        boolean right = dfs(grid,i-1,j);
        boolean up = dfs(grid,i,j-1);
        boolean down = dfs(grid,i,j+1);

        return left&&right&&up&&down;
    }
}
```

#### [4.Leetcode_剑指Offer13 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

 

示例 1：

输入：m = 2, n = 3, k = 1
输出：3
示例 2：

输入：m = 3, n = 1, k = 0
输出：1

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        int[][] square = new int[m][n];
        return dfs(square,0,0,k);
    }
    public int dfs(int[][] square,int i,int j,int k){
        // 递归截止条件
        if(i<0 || i>=square.length || j<0 || j>=square[0].length || square[i][j]==1 || ( (i%10+i/10+j%10+j/10)>k )){
            return 0;
        }
        // 访问过的
        square[i][j] = 1;
        int left = dfs(square,i+1,j,k);
        int right = dfs(square,i-1,j,k);
        int up  = dfs(square,i,j-1,k);
        int down = dfs(square,i,j+1,k);

        return left+right+up+down+1;
    }
}
```

#### [5.Leetcode695 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:

[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

示例 2:

[[0,0,0,0,0,0,0,0]]
对于上面这个给定的矩阵, 返回 0。

 

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                // 是否满足条件
                if(grid[i][j]==1){
                    count = Math.max(count,dfs(grid,i,j));
                }
            }
        }
        return count;
    }

    public int dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]!=1){
            return 0;
        }
        grid[i][j] = 2;
        // 继续
        int left = dfs(grid,i-1,j);
        int right = dfs(grid,i+1,j);
        int up = dfs(grid,i,j-1);
        int down = dfs(grid,i,j+1);

        return 1+left+right+up+down;
    }
}
```

#### [6.Leetcode463 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

给定一个 row x col 的二维网格地图 grid ，其中：grid[i][j] = 1 表示陆地， grid[i][j] = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)

输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边

```java
class Solution {
    public int islandPerimeter(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int count = 0;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    count += dfs(grid,i,j);
                }
            }
        }
        return count;
    }

    public int dfs(int[][] grid,int i,int j){
        if(i<0 || i>=grid.length || j<0 || j>=grid[0].length || grid[i][j]==0){
            return 1;
        }

        if(grid[i][j]==2){
            return 0;
        }

        grid[i][j] = 2;

        int left = dfs(grid,i+1,j);
        int right = dfs(grid,i-1,j);
        int up = dfs(grid,i,j-1);
        int down = dfs(grid,i,j+1);

        return left+right+up+down;
    }
}
```

#### [7.Leetcode_剑指Offer12 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

 

例如，在下面的 3×4 的矩阵中包含单词 "ABCCED"（单词中的字母已标出）。

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

 

示例 1：

输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] arr = word.toCharArray();
        int n = board.length;
        int m = board[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(dfs(board,i,j,arr,0)){
                    return true;
                }
            }
        }
        return false;
    }

    public boolean dfs(char[][] board,int i,int j,char[] word, int index){
        if(i<0 || i>=board.length || j<0 || j>=board[0].length || board[i][j]!=word[index]){
            return false;
        }
        if(index==word.length-1){
            return true;
        }
        char temp = board[i][j];
        board[i][j] = '1';

        boolean res = dfs(board,i+1,j,word,index+1) ||
                      dfs(board,i-1,j,word,index+1) ||
                      dfs(board,i,j-1,word,index+1) ||
                      dfs(board,i,j+1,word,index+1);
        board[i][j] = temp;
        return res;

    }
}
```

#### Leetcode694 不同岛屿的数量

![在这里插入图片描述](imgs\731.png)

 统计岛屿的数量很简单，直接 dfs 即可。

  如果两个岛屿可以通过平移变换（不包括旋转和翻转）和另一个岛屿重合，说明两个岛屿是相同的。

  我们给一个岛屿的所有网格都记录坐标，以岛屿的最左上角网格作为起点，其他网格减去这个起点，得到的岛屿网格坐标就是一个相对值。

  如果两个岛屿的相对值一一对应，说明是同一个岛屿。

  因此，我们可以把所有岛屿的相对坐标连在一起成字符串，如果两个岛屿的字符串一样，也就说明他们的相对坐标一样，是同一个岛屿。

  再把这些岛屿相对坐标字符串存入到 HashSet 中，利用 HashSet 的不重复特点，最终 HashSet 有多少个字符串，就有多少个不同的岛屿。



```java
class Solution {
    public int numDistinctIslands(int[][] grid) {
        Set<String> islands = new HashSet<>();
        int rows = grid.length;
        if (rows == 0) return 0;
        int cols = grid[0].length;
        if (cols == 0) return 0;
        // 遍历坐标为 1 的点
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                if (grid[i][j] == 1) {
                    StringBuilder islandCoordinate = new StringBuilder();
                    dfs(grid, islandCoordinate, i, j, i, j);
                    islands.add(islandCoordinate.toString());
                }
            }
        }
        return islands.size();
    }

    private void dfs(int[][] grid, StringBuilder islandCoordinate,
                     int curX, int curY,
                     int originX, int originY) {
        if (curX < 0 || curX >= grid.length || curY < 0 || curY >= grid[0].length || grid[curX][curY] == 0) {
            return;
        }
        grid[curX][curY] = 0; // 表示当前坐标已经处理，后面不要重复计算它
        islandCoordinate.append(curX - originX);  // 记录相对横坐标
        islandCoordinate.append(curY - originY);  // 记录相对纵坐标
        dfs(grid, islandCoordinate, curX - 1, curY, originX, originY);    // 上
        dfs(grid, islandCoordinate, curX + 1, curY, originX, originY);    // 下
        dfs(grid, islandCoordinate, curX, curY - 1, originX, originY);    // 左
        dfs(grid, islandCoordinate, curX, curY + 1, originX, originY);    // 右
    }
}

```

```java
class Solution {
    private int path = 0;
    public int numDistinctIslands(int[][] grid) {
        Set<Integer> result = new HashSet<>();
        for(int i = 0 ;i<grid.length;i++){
            for(int j = 0;j<grid[0].length;j++){
                if(grid[i][j]==1){
                    path = 0;
                    dfs(grid,i,j,0);
                    result.add(path);
                }
            }
        }
        return result.size();
    }
    public void dfs(int[][] grid, int i, int j,int prev){
        if(i==-1||j==-1||i==grid.length||j==grid[0].length||grid[i][j]==0){
            return;
        }
        grid[i][j] = 0;
        path = path*10+prev;
        dfs(grid,i-1,j,1);
        dfs(grid,i+1,j,2);
        dfs(grid,i,j-1,3);
        dfs(grid,i,j+1,4);
        path = path*10+5;
    }
}
```



#### Leetcode1905 统计子岛屿

给你两个 m x n 的二进制矩阵 grid1 和 grid2 ，它们只包含 0 （表示水域）和 1 （表示陆地）。一个 岛屿 是由 四个方向 （水平或者竖直）上相邻的 1 组成的区域。任何矩阵以外的区域都视为水域。

如果 grid2 的一个岛屿，被 grid1 的一个岛屿 完全 包含，也就是说 grid2 中该岛屿的每一个格子都被 grid1 中同一个岛屿完全包含，那么我们称 grid2 中的这个岛屿为 子岛屿 。

请你返回 grid2 中 子岛屿 的 数目 。

 

示例 1：

输入：grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]
输出：3
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 3 个子岛屿。

![img](https://assets.leetcode.com/uploads/2021/06/10/test1.png)示例 2：

![img](https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png)


输入：grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]
输出：2 
解释：如上图所示，左边为 grid1 ，右边为 grid2 。
grid2 中标红的 1 区域是子岛屿，总共有 2 个子岛屿。

```java
class Solution {
    int row, col;
    boolean notSub;
    
    public int countSubIslands(int[][] grid1, int[][] grid2) {
        row = grid1.length;
        col = grid1[0].length;
        int cnt = 0;
        
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid2[i][j] == 1) {
                    notSub = false;
                    dfs(grid1, grid2, i, j);
                    if (!notSub) {
                        cnt++;
                    }
                }
                
            }
        }

        return cnt;
    }
    
    private void dfs(int[][] grid1, int[][] grid2, int x, int y) {
        if (x < 0 || y < 0 || x >= row || y >= col || grid2[x][y] == 0) {
            return;
        }
        
        if (grid1[x][y] != 1) {
            notSub = true;
        }
        grid2[x][y] = 0;
        dfs(grid1, grid2, x + 1, y);
        dfs(grid1, grid2, x - 1, y);
        dfs(grid1, grid2, x, y + 1);
        dfs(grid1, grid2, x, y - 1);
    }
}
```

### Leetcode1020 飞地的数量

给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。

移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。

返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。

 

示例 1：

输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]
输出：3
解释： 
有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。
示例 2：

输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]
输出：0
解释：
所有 1 都在边界上或可以到达边界。

```java
class Solution {
    int row, col;
    int[][] A;
    public int numEnclaves(int[][] A) {
        if(A == null || A.length == 0) return 0;
        this.A = A;
        this.row = A.length;
        this.col = A[0].length;

        // 淹没所有和边界相接的陆地
        for (int i = 0; i < row; i++) {
            dfs(i, 0);
            dfs(i, col - 1);
        }
        for (int i = 0; i < col; i++) {
            dfs(0, i);
            dfs(row - 1, i);
        }
        // 统计剩下的飞陆
        int count = 0;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if(A[i][j] == 1) count++;
            }
        }
        return count;
    }

    /**
     * 把此大陆淹没，即把 1 变成 0
     * @param r,c DFS 起点
     */
    public void dfs(int r, int c){
        if(A[r][c] == 0) return;

        A[r][c] = 0;
        if(r > 0       ) { dfs(r - 1, c);       }
        if(c > 0       ) { dfs(r,     c - 1);   }
        if(r < row - 1 ) { dfs(r + 1, c);       }
        if(c < col - 1 ) { dfs(r,     c + 1);   }
    }
}

```



#### [1.Leetcode841 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。

最初，除 0 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 true，否则返回 false。

示例 1：

输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2：

输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。

> 解题思路：
>
> 当 xx 号房间中有 yy 号房间的钥匙时，我们就可以从 xx 号房间去往 yy 号房间。如果我们将这 nn 个房间看成有向图中的 nn 个节点，那么上述关系就可以看作是图中的 xx 号点到 yy 号点的一条有向边。
>
> 这样一来，问题就变成了给定一张有向图，询问从 00 号节点出发是否能够到达所有的节点。

我们可以使用深度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组vis标记当前节点是否访问过，以防止重复访问。

```java
class Solution {
    // dfs解题
    //访问过的
    boolean[] visited;
    int sum;
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        visited = new boolean[n];
        sum = 0;
        //dfs从0开始
        dfs(rooms,0);
        return sum==n;
    }
    // dfs
    public void dfs(List<List<Integer>> rooms,int i){
        visited[i] = true;
        sum++;
        //访问其它的
        for(int n:rooms.get(i)){
            //未访问过
            if(!visited[n]){
                dfs(rooms,n);
            }
        }
    }
}


// 主函数增加
public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		String[] str_arr = str.split(";");
		int n = str_arr.length;
		// 结果存储
		List<List<Integer>> list = new ArrayList<>();
		for(int i=0;i<n;i++) {
			List<Integer> temp = new ArrayList<>();
			String[] temp_num = str_arr[i].split(",");
			for(String num:temp_num) {
				temp.add(Integer.valueOf(num));
			}
			list.add(temp);
		}
		// 输出
	}
```

#### [2.Leetcode322 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。

 

提示：

如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
所有的机场都用三个大写字母表示（机场代码）。
假定所有机票至少存在一种合理的行程。
所有的机票必须都用一次 且 只能用一次。


示例 1：

输入：[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出：["JFK", "MUC", "LHR", "SFO", "SJC"]
示例 2：

示例 2：

输入：[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。

```java
class Solution {
    // src和dst，dst可能有多个
    HashMap<String,PriorityQueue<String>> dict = new HashMap<>();
    // 结果存储
    List<String> res = new ArrayList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        // 开始构建
        for(List<String> list:tickets){
            String src = list.get(0);
            String dst = list.get(1);
            // 如果未包含
            if(!dict.containsKey(src)){
                dict.put(src,new PriorityQueue<>());
            }
            dict.get(src).offer(dst);
        }
        //开始搜索
        dfs("JFK");
        // 反转
        Collections.reverse(res);
        return res;
    }

    // 深度搜索
    public void dfs(String src){
        // 是否包含
        while(dict.containsKey(src)&&dict.get(src).size()>0){
            // 排出来一个
            String temp = dict.get(src).poll();
            // 接着走
            dfs(temp);
        }
        // 记录
        res.add(src);

    }
}
```

#### [3.Leetcode802 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)



有向图中，从某个节点和每个转向处开始出发，沿着图的有向边走。如果到达的节点是终点（即它没有连出的有向边），则停止。

如果从起始节点出发，最后必然能走到终点，就认为起始节点是 最终安全 的。更具体地说，对于最终安全的起始节点而言，存在一个自然数 k ，无论选择沿哪条有向边行走 ，走了不到 k 步后必能停止在一个终点上。

返回一个由图中所有最终安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。

该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。

 

示例 1：

![Illustration of graph](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)


输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。

```java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int N = graph.length;
        int[] color = new int[N];
        List<Integer> ans = new ArrayList();

        for (int i = 0; i < N; ++i){
             if (dfs(i, color, graph)){
                ans.add(i);
             }
        }
        return ans;
    }

    // colors: WHITE 0, GRAY 1, BLACK 2;
    public boolean dfs(int node, int[] color, int[][] graph) {
        if (color[node] > 0)
            return color[node] == 2;

        color[node] = 1;
        for (int nei: graph[node]) {
            if (color[node] == 2)
                continue;
            if (color[nei] == 1 || !dfs(nei, color, graph))
                return false;
        }

        color[node] = 2;
        return true;
    }
}
```

#### [Leetcode212 单词搜索II](https://leetcode-cn.com/problems/word-search-ii/)

给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words，找出所有同时在二维网格和字典中出现的单词。

单词必须按照字母顺序，通过 相邻的单元格 内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)


输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
输出：["eat","oath"]

```java
class TrieNode {
  HashMap<Character, TrieNode> children = new HashMap<Character, TrieNode>();
  String word = null;
  public TrieNode() {}
}

class Solution {
  char[][] _board = null;
  ArrayList<String> _result = new ArrayList<String>();

  public List<String> findWords(char[][] board, String[] words) {

    // Step 1). Construct the Trie
    TrieNode root = new TrieNode();
    for (String word : words) {
      TrieNode node = root;

      for (Character letter : word.toCharArray()) {
        if (node.children.containsKey(letter)) {
          node = node.children.get(letter);
        } else {
          TrieNode newNode = new TrieNode();
          node.children.put(letter, newNode);
          node = newNode;
        }
      }
      node.word = word;  // store words in Trie
    }

    this._board = board;
    // Step 2). Backtracking starting for each cell in the board
    for (int row = 0; row < board.length; ++row) {
      for (int col = 0; col < board[row].length; ++col) {
        if (root.children.containsKey(board[row][col])) {
          backtracking(row, col, root);
        }
      }
    }

    return this._result;
  }
  
  private void backtracking(int row, int col, TrieNode parent) {
    Character letter = this._board[row][col];
    TrieNode currNode = parent.children.get(letter);

    // check if there is any match
    if (currNode.word != null) {
      this._result.add(currNode.word);
      currNode.word = null;
    }

    // mark the current letter before the EXPLORATION
    this._board[row][col] = '#';

    // explore neighbor cells in around-clock directions: up, right, down, left
    int[] rowOffset = {-1, 0, 1, 0};
    int[] colOffset = {0, 1, 0, -1};
    for (int i = 0; i < 4; ++i) {
      int newRow = row + rowOffset[i];
      int newCol = col + colOffset[i];
      if (newRow < 0 || newRow >= this._board.length || newCol < 0
          || newCol >= this._board[0].length) {
        continue;
      }
      if (currNode.children.containsKey(this._board[newRow][newCol])) {
        backtracking(newRow, newCol, currNode);
      }
    }

    // End of EXPLORATION, restore the original letter in the board.
    this._board[row][col] = letter;

    // Optimization: incrementally remove the leaf nodes
    if (currNode.children.isEmpty()) {
      parent.children.remove(letter);
    }
  }
}

```





## 回溯

## 子集 组合 排列 N皇后 复原IP地址

#### [子集问题-1.Leetcode078 子集](https://leetcode-cn.com/problems/subsets/)

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
示例 2：

输入：nums = [0]
输出：[[],[0]]

```java
class Solution {
    // 结果
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        // 临时值
        List<Integer> path = new ArrayList<>();
        //开始
        dfs(nums,0,path);
        return res;
    }
    public void dfs(int[] nums,int index,List<Integer> path){
        res.add(new ArrayList<>(path));
        // 其它状态
        for(int i=index;i<nums.length;i++){
            path.add(nums[i]);
            dfs(nums,i+1,path);
            path.remove(path.size()-1);
        }
    }
}
```

#### [子集问题-2.Leetcode090子集II](https://leetcode-cn.com/problems/subsets-ii/)

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

 

示例 1：

输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
示例 2：

输入：nums = [0]
输出：[[],[0]]

```java
class Solution {
    // 子集有重复的子集
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 路径
        List<Integer> path = new ArrayList<>();
        Arrays.sort(nums);
        dfs(nums,0,path);
        return res;
    }
    public void dfs(int[] nums,int index,List<Integer> path){
        res.add(new ArrayList<>(path));
        // 开始
        for(int i=index;i<nums.length;i++){
            // 去重
            if(i>index&&nums[i]==nums[i-1]){
                continue;
            }
            
            path.add(nums[i]);
            dfs(nums,i+1,path);
            path.remove(path.size()-1);
        }
    }
}
```

#### [排列问题-1.Leetcode046全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 

示例 1：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
示例 2：

输入：nums = [0,1]
输出：[[0,1],[1,0]]
示例 3：

输入：nums = [1]
输出：[[1]]

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        List<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        // 
        dfs(nums,visited,list);
        return res;
    }

    public void dfs(int[] nums,boolean[] visited,List<Integer> path){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i=0;i<nums.length;i++){
            if(visited[i]==true){
                continue;
            }

            visited[i] = true;
            path.add(nums[i]);

            dfs(nums,visited,path);

            visited[i] = false;
            path.remove(path.size()-1);
        }
    }
}
```



#### [排列问题-2.Leetcode047全排列II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
示例 2：

输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<Integer> list = new ArrayList<>();
        boolean[] visited = new boolean[nums.length];
        // 排序
        Arrays.sort(nums);
        dfs(nums,list,visited);
        return res;
    }
    public void dfs(int[] nums,List<Integer> path,boolean[] visited){
        if(path.size()==nums.length){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i=0;i<nums.length;i++){
            if(visited[i]==true){
                continue;
            }
            if(i>0&&nums[i]==nums[i-1]&&visited[i-1]==false){
                continue;
            }

            visited[i] = true;
            path.add(nums[i]);

            dfs(nums,path,visited);

            visited[i] = false;
            path.remove(path.size()-1);

        }

    }
}
```

#### Leetcode60 排列序列

给出集合 [1,2,3,...,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

"123"
"132"
"213"
"231"
"312"
"321"
给定 n 和 k，返回第 k 个排列。

 

示例 1：

输入：n = 3, k = 3
输出："213"
示例 2：

输入：n = 4, k = 9
输出："2314"

```java
class Solution { 
    
    public String getPermutation(int n, int k) {
        /**
        直接用回溯法做的话需要在回溯到第k个排列时终止就不会超时了, 但是效率依旧感人
        可以用数学的方法来解, 因为数字都是从1开始的连续自然数, 排列出现的次序可以推
        算出来, 对于n=4, k=15 找到k=15排列的过程:
        
        1 + 对2,3,4的全排列 (3!个)         
        2 + 对1,3,4的全排列 (3!个)         3, 1 + 对2,4的全排列(2!个)
        3 + 对1,2,4的全排列 (3!个)-------> 3, 2 + 对1,4的全排列(2!个)-------> 3, 2, 1 + 对4的全排列(1!个)-------> 3214
        4 + 对1,2,3的全排列 (3!个)         3, 4 + 对1,2的全排列(2!个)         3, 2, 4 + 对1的全排列(1!个)
        
        确定第一位:
            k = 14(从0开始计数)
            index = k / (n-1)! = 2, 说明第15个数的第一位是3 
            更新k
            k = k - index*(n-1)! = 2
        确定第二位:
            k = 2
            index = k / (n-2)! = 1, 说明第15个数的第二位是2
            更新k
            k = k - index*(n-2)! = 0
        确定第三位:
            k = 0
            index = k / (n-3)! = 0, 说明第15个数的第三位是1
            更新k
            k = k - index*(n-3)! = 0
        确定第四位:
            k = 0
            index = k / (n-4)! = 0, 说明第15个数的第四位是4
        最终确定n=4时第15个数为3214 
        **/
        
        StringBuilder sb = new StringBuilder();
        // 候选数字
        List<Integer> candidates = new ArrayList<>();
        // 分母的阶乘数
        int[] factorials = new int[n+1];
        factorials[0] = 1;
        int fact = 1;
        for(int i = 1; i <= n; ++i) {
            candidates.add(i);
            fact *= i;
            factorials[i] = fact;
        }
        k -= 1;
        for(int i = n-1; i >= 0; --i) {
            // 计算候选数字的index
            int index = k / factorials[i];
            sb.append(candidates.remove(index));
            k -= index*factorials[i];
        }
        return sb.toString();
    }
}
```

#### Leetcode784 字母大小写全排列

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

 

示例：
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]

```java
class Solution {
    public List<String> letterCasePermutation(String S) {
        List<StringBuilder> ans = new ArrayList();
        ans.add(new StringBuilder());

        for (char c: S.toCharArray()) {
            int n = ans.size();
            if (Character.isLetter(c)) {
                for (int i = 0; i < n; ++i) {
                    ans.add(new StringBuilder(ans.get(i)));
                    ans.get(i).append(Character.toLowerCase(c));
                    ans.get(n+i).append(Character.toUpperCase(c));
                }
            } else {
                for (int i = 0; i < n; ++i)
                    ans.get(i).append(c);
            }
        }

        List<String> finalans = new ArrayList();
        for (StringBuilder sb: ans)
            finalans.add(sb.toString());
        return finalans;
    }
}

```



#### [组合问题-1.Leetcode039 组合总和](https://leetcode-cn.com/problems/combination-sum/)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]

```java
class Solution {
    // 结果
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> path = new ArrayList<>();
        int sum = 0;
        int index = 0;
        dfs(candidates,index,sum,target,path);
        return res;
    }
    // 查看结果
    public void dfs(int[] candidates,int index,int sum,int target,List<Integer> path){
        // 查看结果是否相等
        if(sum==target){
            res.add(new ArrayList<>(path));
            return;
        }
        if(sum>target){
            return;
        }
        // 其余值
        for(int i=index;i<candidates.length;i++){
            int temp = sum + candidates[i];
            path.add(candidates[i]);

            dfs(candidates,i,temp,target,path);

            path.remove(path.size()-1);

        }
    }

}
```

#### [组合问题-2.Leetcode40组合总和II](https://leetcode-cn.com/problems/combination-sum-ii/)

给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用一次。

说明：

所有数字（包括目标数）都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: candidates = [10,1,2,7,6,1,5], target = 8,
所求解集为:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        int sum = 0;
        int index = 0;
        // 去重
        Arrays.sort(candidates);
        List<Integer> path = new ArrayList<>();
        dfs(candidates,index,sum,target,path);
        return res;
    }
    public void dfs(int[] candidates,int index,int sum,int target,List<Integer> path){
        if(sum==target){
            res.add(new ArrayList<>(path));
            return;
        }
        if(sum>target){
            return;
        }
        for(int i=index;i<candidates.length;i++){
            if(i>index&&candidates[i]==candidates[i-1]){
                    continue;
            }

            int temp = sum+candidates[i];
            path.add(candidates[i]);
            dfs(candidates,i+1,temp,target,path);
            path.remove(path.size()-1);
        }
    }
}
```

#### [组合问题-3.Leetcoce77 组合](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例:

输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

> 解题思路：类似子集

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        List<Integer> path = new ArrayList<>();
        dfs(1,n,k,path);
        return res;
    }
    public void dfs(int index,int n,int k,List<Integer> path){
        if(path.size()==k){
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i=index;i<=n;i++){
            path.add(i);
            dfs(i+1,n,k,path);
            path.remove(path.size()-1);
        }
    }
}
```

#### [组合问题-4.Leetcode216 组合总和III](https://leetcode-cn.com/problems/combination-sum-iii/)

找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]

```java
class Solution {
    // 结果
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<Integer> path = new ArrayList<>();
        int index = 1;
        int sum = 0;
        dfs(1,sum,n,k,path);
        return res;
    }
    public void dfs(int index,int sum,int n, int k,List<Integer> path){
        if(path.size()==k){
            // 对其求和
            if(sum==n){
                res.add(new ArrayList<>(path));
            }
            return;
        }
        if(path.size()>k){
            return;
        }
        // 继续
        for(int i=index;i<=9;i++){
            int temp = sum+i;
            path.add(i);
            dfs(i+1,temp,n,k,path);
            path.remove(path.size()-1);
        }
    }
}
```

### 面试题08.07 无重复字符串的排列组合

无重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合，字符串每个字符均不相同。

示例1:

 输入：S = "qwe"
 输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
示例2:

 输入：S = "ab"
 输出：["ab", "ba"]

```java
class Solution {
    private List<String> list = new ArrayList<>();
    private StringBuilder path = new StringBuilder();
    private boolean[] used = new boolean[10];

    public String[] permutation(String S) {
        dfs(S);
        String[] res = new String[list.size()];
        for (int i = 0; i < list.size(); i++) {
            res[i] = list.get(i);
        }

        return res;
    }

    private void dfs(String S) {
        if (path.length() == S.length()) {
            list.add(new String(path.toString()));
            return;
        }
        for (int i = 0; i < S.length(); i++) {
            if (!used[i]) {
                path.append(S.charAt(i));
                used[i] = true;
                dfs(S);
                used[i] = false;
                path.deleteCharAt(path.length() - 1);
             }
        }
    }
}
```



#### 面试题08.08 有重复字符串的排列组合

有重复字符串的排列组合。编写一种方法，计算某字符串的所有排列组合。

示例1:

 输入：S = "qqe"
 输出：["eqq","qeq","qqe"]
示例2:

 输入：S = "ab"
 输出：["ab", "ba"]
提示:

字符都是英文字母。
字符串长度在[1, 9]之间。

```java
class Solution {
     public String[] permutation(String S) {

        List<String> list = new ArrayList<>();
        char[] arr = S.toCharArray();
        Arrays.sort(arr);
        boolean[] book = new boolean[arr.length];
        dfs(list, new StringBuilder(), book, arr);

        String[] res = new String[list.size()];
        for (int i = 0; i < res.length; i++)
            res[i] = list.get(i);

        return res;
    }
    
    public void dfs(List<String> res, StringBuilder sb, boolean[] book, char[] arr) {
        
        if (sb.length() == arr.length) {
            res.add(sb.toString());
            return;
        }
        for (int i = 0; i < arr.length; i++) {
            if (!book[i]) {
                if (i > 0 && arr[i] == arr[i - 1] && !book[i - 1])
                    continue;
                else {
                    sb.append(arr[i]);
                    book[i] = true;
                    dfs(res, sb, book, arr);
                    book[i] = false;
                    sb.deleteCharAt(sb.length() - 1);
                }
            }
        }
    }
}
```





#### 33.字符串的全排列

**描述*

输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则按字典序打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。

**输入描述：**

输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。

示例1

输入：

```
"ab"
```

复制

返回值：

```
["ab","ba"]
```

```java
import java.util.*;
//import java.uitl.Arrays;

public class Solution {
    //ArrayList<ArrayList<String>> ans  = new ArrayLiat<>();
    ArrayList<String> ans = new ArrayList<>();
    //boolean[] vis;
    public ArrayList<String> Permutation(String s) {
        StringBuilder sb = new StringBuilder();
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        boolean[] visited = new boolean[s.length()];
        backtrack(sb, visited, arr);
        return ans;
    }

     private  void backtrack(StringBuilder sb, boolean[] visited, char[] arr) {
         if (sb.length() == arr.length) {
             ans.add(sb.toString());
             return ;
         }

         for (int i=0;i<arr.length;i++) {
             if (visited[i] == true) continue;
             if (i > 0 && arr[i] == arr[i - 1] && visited[i - 1] == false) continue; // 剪枝
             visited[i] = true;
             sb.append(arr[i]); // 做选择
             backtrack(sb, visited, arr);
             visited[i] = false;
             sb.deleteCharAt(sb.length() - 1); // 撤销选择
         }
    }
}



```



#### [1.Leetcode51 NN皇后](https://leetcode-cn.com/problems/n-queens/)

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)


输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。

```java
class Solution {
    // 结果
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> solveNQueens(int n) {
        // 类似全排列的问题
        // 生成一个棋盘
        char[][] chess = new char[n][n];
        // 默认填充为“.”
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                chess[i][j] = '.';
            }
        }

        // 全排列行 结果在chess中
        dfs(chess,0);
        return res;
    }

    // 回溯
    public void dfs(char[][] chess,int row){
        if(row==chess.length){
            // 加入结果
            ArrayList<String> list = new ArrayList<>();
            for(int i=0;i<chess.length;i++){
                list.add(new String(chess[i]));
            }
            res.add(new ArrayList<>(list));
            return;
        }

        // 继续遍历状态
        for(int col=0;col<chess.length;col++){
            // 删除不合法选择
            if(!valid(chess,row,col)){
                continue;
            }
            chess[row][col] = 'Q';
            // 回溯
            dfs(chess,row+1);
            chess[row][col] = '.';
        }
    }

    // 检查
    public boolean valid(char[][] chess,int row,int col){
        int n = chess.length;
        // 检查列
        for(int i=0;i<n;i++){
            if(chess[i][col]=='Q'){
                return false;
            }
        }
        // 检查左上
        for(int i=row-1,j=col-1;i>=0&&j>=0;i--,j--){
            if(chess[i][j]=='Q'){
                return false;
            }
        }
        // 检查右上
        for(int i=row-1,j=col+1;i>=0&&j<n;i--,j++){
            if(chess[i][j]=='Q'){
                return false;
            }
        }
        return true;

    }

}
```

#### [2.Leetcode93 复原IP地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。

 

示例 1：

输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
示例 2：

输入：s = "0000"
输出：["0.0.0.0"]

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        // 暴力破解每个数的开始和结束
        StringBuilder path = new StringBuilder();
        // 结果
        List<String> res = new ArrayList<>();
        // 对其四个for循环
        for(int a=1;a<4;a++){
            for(int b=1;b<4;b++){
                for(int c=1;c<4;c++){
                    for(int d=1;d<4;d++){
                        if(a+b+c+d==s.length()){
                            int s1 = Integer.parseInt(s.substring(0,a));
                            int s2 = Integer.parseInt(s.substring(a,a+b));
                            int s3 = Integer.parseInt(s.substring(a+b,a+b+c));
                            int s4 = Integer.parseInt(s.substring(a+b+c));
                            //判断是否
                            if(s1<=255&&s2<=255&&s3<=255&&s4<=255){
                                //添加点
                                path.append(s1).append(".").append(s2).append(".").append(s3).append(".").append(s4);
                                if(path.length()==s.length()+3){
                                    //添加
                                    res.add(path.toString());
                                }
                                // 清空
                                path.delete(0,path.length());
                            }
                        }
                    }
                }
            }
        }
        return res;

    }
}
```

```java
class Solution {
    public List<String> restoreIpAddresses(String s) {
        //结果
        List<String> res = new ArrayList<>();
        dfs(s,0,new ArrayList<>(),res);
        return res;
    }

    public void dfs(String s,int startIndex,List<String> path,List<String> res){
        // 递归截止条件
        if(path.size()>4){
            return;
        }
        if(path.size()>=4&&startIndex!=s.length()){
            return;
        }
        // 符合条件
        if(path.size()==4){
            res.add(String.join(".",path));
            return;
        }
        // 遍历
        for(int i=startIndex;i<s.length();i++){
            // 过滤条件在0-255之间，且前缀不是0 或者其长度大于3了
            String newStr = s.substring(startIndex,i+1);
            if( (newStr.length()>1&&newStr.startsWith("0"))  || newStr.length()>3){
                continue;
            }
            //判断数值方面
            int value = Integer.valueOf(newStr);
            if(value<0 || value>255){
                continue;
            }
            path.add(newStr);
            dfs(s,i+1,path,res);
            path.remove(path.size()-1);
        }
    }
}
```







## 滑窗

### Leetcode525 连续数组

给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。

 

示例 1:

输入: nums = [0,1]
输出: 2
说明: [0, 1] 是具有相同数量 0 和 1 的最长连续子数组。
示例 2:

输入: nums = [0,1,0]
输出: 2
说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。

```java
class Solution {
    public int findMaxLength(int[] nums) {
        int res = 0, sum = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 0) {
                nums[i] = -1;
            }
        }
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (sum == 0 && i > res) {
                res = i + 1;
            }
            if (map.containsKey(sum)) {
                res = Math.max(i - map.get(sum), res);
            } else {
                map.put(sum, i);
            }
        }
        return res;
    }
}
```



### 剑指Offer57-II 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int temp_sum = 3;
        // 结果
        List<int[]> res = new ArrayList<>();
        while(l<r){
            //如果符合条件
            if(temp_sum==target){
                int[] temp = new int[r-l+1];
                for(int k=l;k<=r;k++){
                    temp[k-l] = k;
                }
                res.add(temp);
            }
            if(temp_sum>=target){
                temp_sum -= l;
                l++;
            }else{
                r++;
                temp_sum+=r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```



### Leetcode340 最多带有k个不同字符的最长子字符串

题目描述：

最多带有K个不同字符的最长子字符串，子字符串不能含有重复字符

输入：5 ，“leetcode” 输出：5—“tcode”

解题步骤：

采用窗口长度可变的滑动窗口法。先让一个指针指向最左边i=0，依次移动右边指针至i=s.length()。如果当前字符不包含在子字符串，则将该字符添加进子字符串。反之，如果子串包含该字符，左边指针依次向右移动，直至子串不包含该字符，再移动右边指针。


![在这里插入图片描述](https://img-blog.csdnimg.cn/20200410113517956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p5NDUwMjcxOTIz,size_16,color_FFFFFF,t_70)

```java
 public int KSubstring(String s, int k) {
  String sub = "";
  int maxLen = 0;
  for (int i = 0; i < s.length(); i++) {
   while(sub.contains(Character.toString(s.charAt(i)))) {
    sub = sub.substring(1);
   }
   sub += Character.toString(s.charAt(i));
   if(sub.length() <= k)
    maxLen = Math.max(maxLen, sub.length());
  }
  return maxLen;
 }
```



与改题目类似的还有另外一个

题目描述：

最多带有K个不同字符的最长子字符串，注意该题表示子字符串可以有重复字符，但是不同字符的种类必须小于k

解题步骤：

（1）还是采用滑动窗口的方法，如果子串中包含有当前字符，就直接添加到子串。
（2）如果字串中不包含当前字符，那么需要判断当前字符串字符种类是否大于等于k：

如果大于等于k则移动左边指针，使子串字符种类小于k后，再将当前字符添加进子串

```java
 public int lengthOfLongestSubstringKDistinct(String s, int k) {
  String str = "";
  String ret = "";
  if(s.length()<1 || k < 1)
   return 0;
  int count = 0;
  int maxLen = 0;
  for (int i = 0; i < s.length(); i++) {
   if(str.contains(Character.toString(s.charAt(i)))) {
    str += Character.toString(s.charAt(i));
   }
   else {
    while(count >= k) {
     String ch = Character.toString(str.charAt(0));
     str = str.substring(1);
     if(!str.contains(ch))
      count--;
    }
    str += Character.toString(s.charAt(i));
    count++;
   }
   if(maxLen < str.length()) {
    maxLen = str.length();
    ret = str;
   }
  }
  System.out.println(ret);
  return maxLen;
 }
```



### 剑指Offer57-II 和为s的连续正数序列

输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。

序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

 

示例 1：

输入：target = 9
输出：[[2,3,4],[4,5]]
示例 2：

输入：target = 15
输出：[[1,2,3,4,5],[4,5,6],[7,8]]

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        int l = 1;
        int r = 2;
        int temp_sum = 3;
        // 结果
        List<int[]> res = new ArrayList<>();
        while(l<r){
            //如果符合条件
            if(temp_sum==target){
                int[] temp = new int[r-l+1];
                for(int k=l;k<=r;k++){
                    temp[k-l] = k;
                }
                res.add(temp);
            }
            if(temp_sum>=target){
                temp_sum -= l;
                l++;
            }else{
                r++;
                temp_sum+=r;
            }
        }
        return res.toArray(new int[0][]);
    }
}
```



### [子串问题-1.Leetcode76 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"

```java
class Solution {
    public String minWindow(String s, String t) {
        // 得到t的字母以及频率表
        int[] need = new int[128];
        int[] window = new int[128];
        // 统计
        for(char c:t.toCharArray()){
            need[c]++;
        }
        // 滑窗
        int left = 0;
        int right = 0;
        // 结果
        String res = "";
        int minlen = s.length()+1;
        // 统计满足条件的
        int count = 0;
        while(right<s.length()){
            char c = s.charAt(right);
            window[c]++;
            //看是否满足条件
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            // 满足了左边移动
            while(count==t.length()){
                // 左边移动
                c = s.charAt(left);
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                // 记录长度
                if(right-left<minlen){
                    minlen = right-left+1;
                    res = s.substring(left,right+1);
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return res;
    }
}
```

### [子串问题-2.Leetcode567字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)


给定两个字符串 `s1` 和 `s2`，写一个函数来判断 `s2` 是否包含 `s1` 的排列。

换句话说，第一个字符串的排列之一是第二个字符串的 **子串** 。

 

**示例 1：**

```
输入: s1 = "ab" s2 = "eidbaooo"
输出: True
解释: s2 包含 s1 的排列之一 ("ba").
```

**示例 2：**

```
输入: s1= "ab" s2 = "eidboaoo"
输出: False
```

> 解题思路：滑窗

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int[] need = new int[128];
        int[] window = new int[128];
        //统计
        for(char c:s1.toCharArray()){
            need[c]++;
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int count = 0;
        while(right<s2.length()){
            char c = s2.charAt(right);
            window[c]++;
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            //查看是否满足条件了
            while(right-left+1>=s1.length()){
                c = s2.charAt(left);
                //判断
                if(count==s1.length()){
                    return true;
                }
                // 继续
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return false;
    }
}
```

### [子串问题-3.Leetcode438找到字符串中所有字母异位词](https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/)

给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。
示例 1:

输入:
s: "cbaebabacd" p: "abc"

输出:
[0, 6]

解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的字母异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的字母异位词

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        // 字母异位词
        int[] need = new int[128];
        int[] window = new int[128];
        for(char c:p.toCharArray()){
            need[c]++;
        }
        int left = 0;
        int right = 0;
        int count  = 0;
        // 结果
        List<Integer> res = new ArrayList<>();
        while(right<s.length()){
            char c = s.charAt(right);
            window[c]++;
            if(need[c]>0&&need[c]>=window[c]){
                count++;
            }
            // 开始缩减
            while(right-left+1>=p.length()){
                if(count==p.length()){
                    res.add(left);
                }
                c = s.charAt(left);
                if(need[c]>0&&need[c]>=window[c]){
                    count--;
                }
                window[c]--;
                left++;
            }
            right++;
        }
        return res;
    }
}
```



### [单个的子串问题-1.Leetcode003无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
示例 2:

输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

> 解题思路：hashmap+滑窗的思路

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        HashMap<Character,Integer> dict = new HashMap<>();
        char[] arr = s.toCharArray();
        int left = 0;
        int right = 0;
        // 结果
        int maxLen = 0;
        while(right<arr.length){
            if(dict.containsKey(arr[right])){
                left = Math.max(left,dict.get(arr[right])+1);
            }
            dict.put(arr[right],right);
            maxLen = Math.max(maxLen,right-left+1);
            right++;
        }
        return maxLen;
    }
}
```

### [单个的子串问题-2.Leetcode674最长连续递增序列](https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/)

给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。

连续递增的子序列 可以由两个下标 l 和 r（l < r）确定，如果对于每个 l <= i < r，都有 nums[i] < nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。

 

示例 1：

输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
示例 2：

输入：nums = [2,2,2,2,2]
输出：1
解释：最长连续递增序列是 [2], 长度为1。

```java
class Solution {
    public int findLengthOfLCIS(int[] nums) {
        int left = 0;
        int right = 1;
        int res = 1;
        while(right<nums.length){
            if(nums[right-1]>=nums[right]){
                left = right;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [单个的子串问题-3.Leetcode485 最大连续1的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

给定一个二进制数组， 计算其中最大连续 1 的个数。

 

示例：

输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        // 滑窗
        int left = 0;
        int right = 0;
        int res = 0;
        while(right<nums.length){
            // 缩
            if(nums[right]!=1){
                left = right+1;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [单个子串给定操作次数问题-1.Leetcode1004最大连续1的个数III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

返回仅包含 1 的最长（连续）子数组的长度。

 

示例 1：

输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
示例 2：

输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
输出：10
解释：
[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 10。

> 解题思路：滑窗

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0;
        int right = 0;
        // 判断操作的次数
        int zeros = 0;
        // 记录结果
        int res = 0;
        while(right<nums.length){
            if(nums[right]==0){
                zeros++;
            }
            // 满足缩的条件了
            while(zeros>k){
                if(nums[left]==0){
                    zeros--;
                }
                left++;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [单个子串给定操作次数问题-2.Leetcode1493删掉一个元素以后全为1的最长子数组](https://leetcode-cn.com/problems/longest-subarray-of-1s-after-deleting-one-element/)

给你一个二进制数组 nums ，你需要从中删掉一个元素。

请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。

如果不存在这样的子数组，请返回 0 。

 

提示 1：

输入：nums = [1,1,0,1]
输出：3
解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。

示例 2：

输入：nums = [0,1,1,1,0,1,1,0,1]
输出：5
解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。

> 解题思路：对操作次数限制即可了。

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0;
        int right = 0;
        int zeros = 0;
        int res = 0;
        while(right<nums.length){
            if(nums[right]==0){
                zeros++;
            }
            //缩的条件
            while(zeros>1){
                if(nums[left]==0){
                    zeros--;
                }
                left++;
            }
            // 记录
            res = Math.max(res,right-left);
            right++;
        }
        return res;
    }
}
```

### [单个字符串给定操作次数-3.Leetcode424替换后的最长重复字符](https://leetcode-cn.com/problems/longest-repeating-character-replacement/)

给你一个仅由大写英文字母组成的字符串，你可以将任意位置上的字符替换成另外的字符，总共可最多替换 k 次。在执行上述操作后，找到包含重复字母的最长子串的长度。

注意：字符串长度 和 k 不会超过 104。

 

示例 1：

输入：s = "ABAB", k = 2
输出：4
解释：用两个'A'替换为两个'B',反之亦然。
示例 2：

输入：s = "AABABBA", k = 1
输出：4
解释：
将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
子串 "BBBB" 有最长重复字母, 答案为 4。

```java
class Solution {
    public int characterReplacement(String s, int k) {
        char[] arr = s.toCharArray();
        int left = 0;
        int right = 0;
        // 记录
        int[] windows = new int[128];
        // 记录此时的最大频率
        int cur = 0;
        // 结果记录
        int res = 0;
        while(right<arr.length){
            //记录
            char c = arr[right];
            windows[c]++;
            cur = Math.max(cur,windows[c]);
            // 看是否满足缩招的条件了
            while(right-left+1-cur>k){
                c = arr[left];
                windows[c]--;
                left++;
            }
            res = Math.max(res,right-left+1);
            right++;
        }
        return res;
    }
}
```

### [字符串代价问题-1.Leetcode209 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0;
        int right = 0;
        int temp_target = 0;
        int minlen = nums.length+1;
        while(right<nums.length){
            temp_target += nums[right];
            // 是否需要缩招
            while(temp_target>=target){
                minlen = Math.min(minlen,right-left+1);
                temp_target -= nums[left];
                left++;
            }
            right++;
        }
        return minlen==nums.length+1?0:minlen;
    }
}
```

### [字符串代价问题-2.Leetcode1208尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

给你两个长度相同的字符串，s 和 t。

将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。

用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。

如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。

如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。

 

示例 1：

输入：s = "abcd", t = "bcdf", maxCost = 3
输出：3
解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。

```java
class Solution {
    public int equalSubstring(String s, String t, int maxCost) {
        char[] s_arr = s.toCharArray();
        char[] t_arr = t.toCharArray();
        int[] cost = new int[s_arr.length];
        for(int i=0;i<s_arr.length;i++){
            cost[i] = Math.abs(s_arr[i]-t_arr[i]);
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int temp_cost = 0;
        int len = 0;
        while(right<cost.length){
            temp_cost += cost[right];
            //缩招
            while(temp_cost>maxCost){
                temp_cost -= cost[left];
                left++;
            }
            len = Math.max(len,right-left+1);
            right++;
        }
        return len;
    }
}
```

### [字符串代价问题-3.Leetcode1052 爱生气的书店老板](https://leetcode-cn.com/problems/grumpy-bookstore-owner/)


今天，书店老板有一家店打算试营业 `customers.length` 分钟。每分钟都有一些顾客（`customers[i]`）会进入书店，所有这些顾客都会在那一分钟结束后离开。

在某些时候，书店老板会生气。 如果书店老板在第 `i` 分钟生气，那么 `grumpy[i] = 1`，否则 `grumpy[i] = 0`。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。

书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 `X` 分钟不生气，但却只能使用一次。

请你返回这一天营业下来，最多有多少客户能够感到满意。


**示例：**

```
输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3
输出：16
解释：
书店老板在最后 3 分钟保持冷静。
感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.
```



```java
class Solution {
    public int maxSatisfied(int[] customers, int[] grumpy, int minutes) {
        int sum1 = 0;
        for(int i=0;i<customers.length;i++){
            if(grumpy[i]==0){
                sum1 += customers[i];
                customers[i] = 0;
            }
        }
        // 滑窗
        int left = 0;
        int right = 0;
        int temp_sum = 0;
        int sum2 = 0;
        while(right<customers.length){
            temp_sum += customers[right];
            // 是否缩招
            while(right-left+1>minutes){
                temp_sum -= customers[left];
                left++;
            }
            sum2 = Math.max(sum2,temp_sum);
            right++;
        }
        return sum1+sum2;
    }
}
```









## 图

## 创建图

### [1.Leetcode133 克隆图](https://leetcode-cn.com/problems/clone-graph/)

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

class Node {
    public int val;
    public List<Node> neighbors;
}


测试用例格式：

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。

邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)

输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public List<Node> neighbors;
    public Node() {
        val = 0;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val) {
        val = _val;
        neighbors = new ArrayList<Node>();
    }
    public Node(int _val, ArrayList<Node> _neighbors) {
        val = _val;
        neighbors = _neighbors;
    }
}
*/

class Solution {
    public Node cloneGraph(Node node) {
        if(node==null){
            return node;
        }
        // 用HashMap来进行拷贝
        HashMap<Node,Node> dict = new HashMap<>();
        // 层序遍历
        Queue<Node> queue = new LinkedList<>();
        queue.offer(node);
        // 克隆 
        dict.put(node,new Node(node.val,new ArrayList<>()));
        // 广度优先搜索
        while(!queue.isEmpty()){
            Node n = queue.poll();
            // 其余
            for(Node neighbor:n.neighbors){
                if(!dict.containsKey(neighbor)){
                    dict.put(neighbor,new Node(neighbor.val,new ArrayList<>()));
                    queue.offer(neighbor);
                }
                // 更新
                dict.get(n).neighbors.add(dict.get(neighbor));
            }
        }
        return dict.get(node);
    }
}
```

## 单纯考察入度和出度

### [1.Leetcode997 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)

在一个小镇里，按从 `1` 到 `N` 标记了 `N` 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

1. 小镇的法官不相信任何人。
2. 每个人（除了小镇法官外）都信任小镇的法官。
3. 只有一个人同时满足属性 1 和属性 2 。

给定数组 `trust`，该数组由信任对 `trust[i] = [a, b]` 组成，表示标记为 `a` 的人信任标记为 `b` 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 `-1`。

 

**示例 1：**

```
输入：N = 2, trust = [[1,2]]
输出：2
```

**示例 2：**

```
输入：N = 3, trust = [[1,3],[2,3]]
输出：3
```

```java
class Solution {
    public int findJudge(int n, int[][] trust) {
        // 两个数组，一个代表出度，一个代表入度
        // 人人都相信法官 法官的入度为n-1
        // 法官不相信任何人：法官的出度为0
        int[][] degree = new int[n][2];
        for(int[] item:trust){
            degree[item[0]-1][0]++;
            degree[item[1]-1][1]++;
        }
        for(int i=0;i<degree.length;i++){
            if(degree[i][0]==0&&degree[i][1]==n-1){
                return i+1;
            }
        }
        return -1;
    }
}
```

### [2.Leetcode1791 找出星型图的中心节点](https://leetcode-cn.com/problems/find-center-of-star-graph/)

有一个无向的 星型 图，由 n 个编号从 1 到 n 的节点组成。星型图有一个 中心 节点，并且恰有 n - 1 条边将中心节点与其他每个节点连接起来。

给你一个二维整数数组 edges ，其中 edges[i] = [ui, vi] 表示在节点 ui 和 vi 之间存在一条边。请你找出并返回 edges 所表示星型图的中心节点。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/14/star_graph.png)


输入：edges = [[1,2],[2,3],[4,2]]
输出：2
解释：如上图所示，节点 2 与其他每个节点都相连，所以节点 2 是中心节点。

```java
class Solution {
    public int findCenter(int[][] edges) {
        //就是找到第二次出现的数字
        HashMap<Integer,Integer> dict = new HashMap<>();
        for(int i=0;i<edges.length;i++){
            for(int j=0;j<edges[i].length;j++){
                if(!dict.containsKey(edges[i][j])){
                    dict.put(edges[i][j],1);
                }else{
                    return edges[i][j];
                }
            }
        }
        return 0;
    }
}
```

### [3.Leetcode1557 可以到达所有点的最少数目](https://leetcode-cn.com/problems/minimum-number-of-vertices-to-reach-all-nodes/)

给你一个 有向无环图 ， n 个节点编号为 0 到 n-1 ，以及一个边数组 edges ，其中 edges[i] = [fromi, toi] 表示一条从点  fromi 到点 toi 的有向边。

找到最小的点集使得从这些点出发能到达图中所有点。题目保证解存在且唯一。

你可以以任意顺序返回这些节点编号。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/08/22/5480e1.png)

输入：n = 6, edges = [[0,1],[0,2],[2,5],[3,4],[4,2]]
输出：[0,3]
解释：从单个节点出发无法到达所有节点。从 0 出发我们可以到达 [0,1,2,5] 。从 3 出发我们可以到达 [3,4,2,5] 。所以我们输出 [0,3] 。

```java
class Solution {
    public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {
        // 寻找入度为0
        List<Integer> res = new ArrayList<>();
        // 寻找
        Set<Integer> endSet = new HashSet<>();
        for(List<Integer> edge:edges){
            endSet.add(edge.get(1));
        }
        // 开始
        for(int i=0;i<n;i++){
            if(!endSet.contains(i)){
                res.add(i);
            }
        }
        return res;
    }
}
```

### [4.Leetcode1615 最大网络秩](https://leetcode-cn.com/problems/maximal-network-rank/)

n 座城市和一些连接这些城市的道路 roads 共同组成一个基础设施网络。每个 roads[i] = [ai, bi] 都表示在城市 ai 和 bi 之间有一条双向道路。

两座不同城市构成的 城市对 的 网络秩 定义为：与这两座城市 直接 相连的道路总数。如果存在一条道路直接连接这两座城市，则这条道路只计算 一次 。

整个基础设施网络的 最大网络秩 是所有不同城市对中的 最大网络秩 。

给你整数 n 和数组 roads，返回整个基础设施网络的 最大网络秩 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex1.png)

输入：n = 4, roads = [[0,1],[0,3],[1,2],[1,3]]
输出：4
解释：城市 0 和 1 的网络秩是 4，因为共有 4 条道路与城市 0 或 1 相连。位于 0 和 1 之间的道路只计算一次。

示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/11/ex2.png)

输入：n = 5, roads = [[0,1],[0,3],[1,2],[1,3],[2,3],[2,4]]
输出：5
解释：共有 5 条道路与城市 1 或 2 相连。

```java
class Solution {
    public int maximalNetworkRank(int n, int[][] roads) {
        // 邻接矩阵
        int[][] graph = new int[n][n];
        // 出度
        int[] degree = new int[n];
        for(int[] road:roads){
            graph[road[0]][road[1]]++;
            graph[road[1]][road[0]]++;
            degree[road[0]]++;
            degree[road[1]]++;
        }
        int res = Integer.MIN_VALUE;
        for(int i=0;i<n-1;i++){
            for(int j=i+1;j<n;j++){
                int temp = degree[i]+degree[j]-graph[i][j];
                res = Math.max(res,temp);
            }
        }
        return res;
    }
}
```

## 最小生成树

### 最小生成树-NC159最小生成树(Kruskal算法)

**描述**

一个有n户人家的村庄，有m条路连接着。村里现在要修路，每条路都有一个代价，现在请你帮忙计算下，最少需要花费多少的代价，就能让这n户人家连接起来。

**示例1**

输入：

```
3,3,[[1,3,3],[1,2,1],[2,3,1]]
```

复制

返回值：

```
2
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost int二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    public int miniSpanningTree (int n, int m, int[][] cost) {
        // write code here
        int[] parent = new int[n+1];
        for(int i=0;i<parent.length;i++){
            parent[i] = i;
        }
        //优先级队列
        PriorityQueue<Node> queue = new PriorityQueue<>((a,b)->(a.cost-b.cost));
        for(int[] c:cost){
            queue.offer(new Node(c[1],c[0],c[2]));
        }
        int res = 0;
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            if(find(parent,cur.start)!=find(parent,cur.end)){
                res += cur.cost;
                union(parent,cur.start,cur.end);
            }
        }
        return res;
    }
    // 结点
    static class Node{
        int start;
        int end;
        int cost;
        public Node(int s,int e,int c){
            this.start = s;
            this.end = e;
            this.cost = c;
        }
    }
    
     public int find(int[] parent,int node){
           while(node!=parent[node]){
               parent[node] = parent[parent[node]];
               node = parent[node];
           }
           return node;
        }
        public void union(int[] parent,int node1,int node2){
            int p1 = find(parent,node1);
            int p2 = find(parent,node2);
            parent[p1] = p2;
        }
}
```

### [NC158 单源最短路](https://www.nowcoder.com/practice/9f15b34a2a944a7798a5340ff0dba8b7?tpId=188&&tqId=38651&rp=1&ru=/activity/oj&qru=/ta/job-code-high-week/question-ranking)

**描述**

在一个有 n*n* 个点， m*m* 个边的有向图中，已知每条边长，求出 11 到 n*n* 的最短路径，返回 11 到 n*n* 的最短路径值。如果 11 无法到 n*n* ，输出 -1−1

图中可能有重边，无自环。

数据范围：

1 \le n \le 50001≤*n*≤5000

1 \le m \le 500001≤*m*≤50000

1 \le dist(n, m) \le 10001≤*d**i**s**t*(*n*,*m*)≤1000

**示例1**

输入：

```
5,5,[[1,2,2],[1,4,5],[2,3,3],[3,5,4],[4,5,5]]
```

复制

返回值：

```
9
```

复制

**备注：**

```
两个整数n和m,表示图的顶点数和边数。
一个二维数组，一维3个数据，表示顶点到另外一个顶点的边长度是多少
每条边的长度范围[0,1000]。
注意数据中可能有重边
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int 顶点数
     * @param m int 边数
     * @param graph int二维数组 一维3个数据，表示顶点到另外一个顶点的边长度是多少​
     * @return int
     */
    public int findShortestPath (int n, int m, int[][] graph) {
        // write code here
        int[] min = new int[n]; // 存储1到i+1节点的最短距离
        Arrays.fill(min, Integer.MAX_VALUE);
        min[0] = 0; // 1到1肯定就是0啦
        for (int i = 0; i < m; i++) { // 第一重遍历是遍历所有的点
            for (int j = 0; j < m; j++) { // 遍历所有的路径
                if (i + 1 == graph[j][0]) { // 只要起点是i + 1 就可以用作更新最短距离
                    int path = Integer.MAX_VALUE == min[i] ? Integer.MAX_VALUE : graph[j][2] + min[i];
                    min[graph[j][1] - 1] = Math.min(min[graph[j][1] - 1], path); // 这里注意要减一，不想减一就把数组扩大一即可
                }
            }
        }

        return min[n - 1] == Integer.MAX_VALUE ? -1 : min[n - 1]; //返回1到n的最短路径
    }
}
```





```java
import java.util.*;

class CityInfo{
    int dst;
    int cost;
    public CityInfo(int dst ,int cost){
        this.dst = dst;
        this.cost = cost;
    }
}
public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param n int 顶点数
     * @param m int 边数
     * @param graph int二维数组 一维3个数据，表示顶点到另外一个顶点的边长度是多少​
     * @return int
     */
    public int findShortestPath (int n, int m, int[][] graph) {
         int[][] dp = new int[n][n];
        for(int[] d : dp){
            Arrays.fill(d , Integer.MAX_VALUE);
        }
        for(int[] edge : graph){
            dp[edge[0] - 1][edge[1] - 1] = Math.min(edge[2] , dp[edge[0] - 1][edge[1] - 1]);
        }
        //优先队列按照花费进行从小到大的排序
        PriorityQueue<CityInfo> queue = new PriorityQueue<CityInfo>((o1,o2) ->{return o1.cost - o2.cost;});
        queue.offer(new CityInfo(0, 0));
        while(!queue.isEmpty()){
            CityInfo info = queue.poll();
            //如果到达了终点，而queue.poll的就是花费最低的，那么就给其返回
            if(info.dst == n - 1){
                return info.cost;
            }
            //到达目前的该点到其他点的路线是否存在，如果存在，就加入到队列中
            for(int i = 0 ;i < n ;i++){
                if(dp[info.dst][i] != Integer.MAX_VALUE){
                    queue.offer(new CityInfo(i , dp[info.dst][i] + info.cost));
                }
            }
        }
        return -1;
    }
}
```





## 循环依赖检测

### 0.检测循环依赖（类似于课程表）

[['A', 'B'], ['B', 'C'], ['C', 'D'], ['B', 'D']] => false，[['A', 'B'], ['B', 'C'], ['C', 'A']] => true

**题目描述：**

现有n个编译项，编号为0 ~ n-1。给定一个二维数组，表示编译项之间有依赖关系。如[0, 1]表示1依赖于0。

若存在循环依赖则返回空；不存在依赖则返回可行的编译顺序。

**题目分析：**

若给定一个依赖关系是[[0,2],[1,2],[2,3],[2,4]]，如图所示

![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHOSu5k160b070ZdrAMyjL3by5C0ju2jsLq9VlxOmDXArYaYSoP6LC0WqP9VUaAfONbICrlV8Y9vQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看出，它们之间不存在循环依赖。

可行的编译序列是[0,1,2,3,4]，也可以是[1,0,2,4,3]等。

拓扑排序可以求这样的一个序列。可以看出，这个序列结果可能不唯一。

> > 拓扑排序算法过程：
> >
> > 1. 选择图中一个入度为0的点，记录下来
> > 2. 在图中删除该点和所有以它为起点的边
> > 3. 重复1和2，直到图为空或没有入度为0的点。

```java
vector<int> haveCircularDependency(int n, vector<vector<int>> &prerequisites) {
    vector<vector<int>> g(n); //邻接表存储图结构
    vector<int> indeg(n); //每个点的入度
    vector<int> res; //存储结果序列
    for(int i = 0; i < prerequisites.size(); i ++) {
        int a = prerequisites[i][0], b = prerequisites[i][1]; 
        g[a].push_back(b);
        indeg[b] ++;
    }
    queue<int> q;
    //一次性将入度为0的点全部入队
    for(int i = 0; i < n; i ++) {
        if(indeg[i] == 0) q.push(i);
    }
    while(q.size()) {
        int t = q.front();
        q.pop();
        res.push_back(t);
        //删除边时，将终点的入度-1。若入度为0，果断入队
        for(int i = 0; i < g[t].size(); i ++) {
            int j = g[t][i];
            indeg[j] --;
            if(indeg[j] == 0) {
                q.push(j);
            }
        }
    }
    if(res.size() == n) return res;
    else return {};
}
```

### [1.Leetcode207 课程表](https://leetcode-cn.com/problems/course-schedule/)

你这个学期必须选修 numCourses 门课程，记为 0 到 numCourses - 1 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 prerequisites 给出，其中 prerequisites[i] = [ai, bi] ，表示如果要学习课程 ai 则 必须 先学习课程  bi 。

例如，先修课程对 [0, 1] 表示：想要学习课程 0 ，你需要先完成课程 1 。
请你判断是否可能完成所有课程的学习？如果可以，返回 true ；否则，返回 false 。

 

示例 1：

输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

示例 2：

输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。

> 解题思路：List<List<Integer>> 构建有向图，以及入度数组
>
> BFS先将度为0的入，之后统计。

```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        //构建图
        List<List<Integer>> list = new ArrayList<>();
        int[] indeg = new int[numCourses];
        // 初始化
        for(int i=0;i<numCourses;i++){
            list.add(new ArrayList<>());
        }
        //赋值
        for(int i=0;i<prerequisites.length;i++){
            list.get(prerequisites[i][1]).add(prerequisites[i][0]);
            indeg[prerequisites[i][0]]++;
        }
        //BFS算法 度为0的
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<indeg.length;i++){
            if(indeg[i]==0){
                queue.offer(i);
            }
        }
        while(!queue.isEmpty()){
            int u = queue.poll();
            numCourses--;
            // 其余
            for(int v:list.get(u)){
                // 度减一
                indeg[v]--;
                if(indeg[v]==0){
                    queue.offer(v);
                }
            }
        }
        return numCourses==0;
    }
}
```

### [2.Leetcode210 课程表II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 n 门课需要选，记为 0 到 n-1。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

示例 1:

输入: 2, [[1,0]] 
输出: [0,1]
解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
示例 2:

输入: 4, [[1,0],[2,0],[3,1],[3,2]]
输出: [0,1,2,3] or [0,2,1,3]
解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
     因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

> 解题思路：List<List<Integer>> 构建有向图，以及入度数组
>
> BFS先将度为0的入，之后统计

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 构建图
        List<List<Integer>> graph = new ArrayList<>();
        int[] indeg = new int[numCourses];
        // 初始化
        for(int i=0;i<numCourses;i++){
            graph.add(new ArrayList<>());
        }
        for(int i=0;i<prerequisites.length;i++){
            graph.get(prerequisites[i][1]).add(prerequisites[i][0]);
            indeg[prerequisites[i][0]]++;
        }
        // 开始bFS
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<indeg.length;i++){
            if(indeg[i]==0){
                queue.offer(i);
            }
        }
        // 结果记录
        int[] res = new int[numCourses];
        int index = 0;
        // 继续
        while(!queue.isEmpty()){
            int u = queue.poll();
            numCourses--;
            res[index++]  = u;

            for(int v:graph.get(u)){
                indeg[v]--;
                if(indeg[v]==0){
                    queue.offer(v);
                }
            }
        }

        if(numCourses==0){
            return res;
        }else{
            return new int[0];
        }
    }
}
```

### [Leetcode1361 验证二叉树](https://leetcode-cn.com/problems/validate-binary-tree-nodes/)

二叉树上有 n 个节点，按从 0 到 n - 1 编号，其中节点 i 的两个子节点分别是 leftChild[i] 和 rightChild[i]。

只有 所有 节点能够形成且 只 形成 一颗 有效的二叉树时，返回 true；否则返回 false。

如果节点 i 没有左子节点，那么 leftChild[i] 就等于 -1。右子节点也符合该规则。

注意：节点没有值，本问题中仅仅使用节点编号。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/23/1503_ex1.png)

输入：n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]
输出：true

```java
class Solution {
    // BFS来验证
    public boolean validateBinaryTreeNodes(int n, int[] leftChild, int[] rightChild) {
        // 先计算入度从而确定根节点
        int[] indeg = new int[n];
        for(int i=0;i<n;i++){
            if(leftChild[i]!=-1){
                indeg[leftChild[i]]++;
            }
            if(rightChild[i]!=-1){
                indeg[rightChild[i]]++;
            }
        }
        // 确定根节点
        int root = -1;
        for(int i=0;i<n;i++){
            if(indeg[i]==0){
                root = i;
                break;
            }
        }
        if(root==-1){
            //没有入度为0的 没有根节点
            return false;
        }
        // 开始搜索
        Queue<Integer> queue = new LinkedList<>();
        // 标记访问过的
        Set<Integer> set = new HashSet<>();
        queue.offer(root);
        set.add(root);
        while(!queue.isEmpty()){
            int node = queue.poll();
            if(leftChild[node]!=-1){
                // 左子树不为空
                if(set.contains(leftChild[node])){
                    return false;
                }
                queue.offer(leftChild[node]);
                set.add(leftChild[node]);
            }

            if(rightChild[node]!=-1){
                // 右子树不为空
                if(set.contains(rightChild[node])){
                    return false;
                }
                queue.offer(rightChild[node]);
                set.add(rightChild[node]);
            }
        }
        return set.size()==n;

    }
}
```





## 从一点遍历完其余点

### [1.Leetcode841 钥匙和房间](https://leetcode-cn.com/problems/keys-and-rooms/)

有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。

最初，除 0 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 true，否则返回 false。

示例 1：

输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
示例 2：

输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。

> 解题思路：
>
> 当 xx 号房间中有 yy 号房间的钥匙时，我们就可以从 xx 号房间去往 yy 号房间。如果我们将这 nn 个房间看成有向图中的 nn 个节点，那么上述关系就可以看作是图中的 xx 号点到 yy 号点的一条有向边。
>
> 这样一来，问题就变成了给定一张有向图，询问从 00 号节点出发是否能够到达所有的节点。

我们可以使用深度优先搜索的方式遍历整张图，统计可以到达的节点个数，并利用数组vis标记当前节点是否访问过，以防止重复访问。

```java
class Solution {
    // dfs解题
    //访问过的
    boolean[] visited;
    int sum;
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        visited = new boolean[n];
        sum = 0;
        //dfs从0开始
        dfs(rooms,0);
        return sum==n;
    }
    // dfs
    public void dfs(List<List<Integer>> rooms,int i){
        visited[i] = true;
        sum++;
        //访问其它的
        for(int n:rooms.get(i)){
            //未访问过
            if(!visited[n]){
                dfs(rooms,n);
            }
        }
    }
}


// 主函数增加
public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		String[] str_arr = str.split(";");
		int n = str_arr.length;
		// 结果存储
		List<List<Integer>> list = new ArrayList<>();
		for(int i=0;i<n;i++) {
			List<Integer> temp = new ArrayList<>();
			String[] temp_num = str_arr[i].split(",");
			for(String num:temp_num) {
				temp.add(Integer.valueOf(num));
			}
			list.add(temp);
		}
		// 输出
	}
```

### [2.Leetcode322 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。

 

提示：

如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 ["JFK", "LGA"] 与 ["JFK", "LGB"] 相比就更小，排序更靠前
所有的机场都用三个大写字母表示（机场代码）。
假定所有机票至少存在一种合理的行程。
所有的机票必须都用一次 且 只能用一次。


示例 1：

输入：[["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]]
输出：["JFK", "MUC", "LHR", "SFO", "SJC"]
示例 2：

示例 2：

输入：[["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]
输出：["JFK","ATL","JFK","SFO","ATL","SFO"]
解释：另一种有效的行程是 ["JFK","SFO","ATL","JFK","ATL","SFO"]。但是它自然排序更大更靠后。

```java
class Solution {
    // src和dst，dst可能有多个
    HashMap<String,PriorityQueue<String>> dict = new HashMap<>();
    // 结果存储
    List<String> res = new ArrayList<>();
    public List<String> findItinerary(List<List<String>> tickets) {
        // 开始构建
        for(List<String> list:tickets){
            String src = list.get(0);
            String dst = list.get(1);
            // 如果未包含
            if(!dict.containsKey(src)){
                dict.put(src,new PriorityQueue<>());
            }
            dict.get(src).offer(dst);
        }
        //开始搜索
        dfs("JFK");
        // 反转
        Collections.reverse(res);
        return res;
    }

    // 深度搜索
    public void dfs(String src){
        // 是否包含
        while(dict.containsKey(src)&&dict.get(src).size()>0){
            // 排出来一个
            String temp = dict.get(src).poll();
            // 接着走
            dfs(temp);
        }
        // 记录
        res.add(src);

    }
}
```

### [3.Leetcode802 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/)



有向图中，从某个节点和每个转向处开始出发，沿着图的有向边走。如果到达的节点是终点（即它没有连出的有向边），则停止。

如果从起始节点出发，最后必然能走到终点，就认为起始节点是 最终安全 的。更具体地说，对于最终安全的起始节点而言，存在一个自然数 k ，无论选择沿哪条有向边行走 ，走了不到 k 步后必能停止在一个终点上。

返回一个由图中所有最终安全的起始节点组成的数组作为答案。答案数组中的元素应当按 升序 排列。

该有向图有 n 个节点，按 0 到 n - 1 编号，其中 n 是 graph 的节点数。图以下述形式给出：graph[i] 是编号 j 节点的一个列表，满足 (i, j) 是图的一条有向边。

 

示例 1：

![Illustration of graph](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png)


输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]
输出：[2,4,5,6]
解释：示意图如上。

```java
class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int N = graph.length;
        int[] color = new int[N];
        List<Integer> ans = new ArrayList();

        for (int i = 0; i < N; ++i){
             if (dfs(i, color, graph)){
                ans.add(i);
             }
        }
        return ans;
    }

    // colors: WHITE 0, GRAY 1, BLACK 2;
    public boolean dfs(int node, int[] color, int[][] graph) {
        if (color[node] > 0)
            return color[node] == 2;

        color[node] = 1;
        for (int nei: graph[node]) {
            if (color[node] == 2)
                continue;
            if (color[nei] == 1 || !dfs(nei, color, graph))
                return false;
        }

        color[node] = 2;
        return true;
    }
}
```







## 图中的冗余连接

### [1.Leetcode685 冗余连接II](https://leetcode-cn.com/problems/redundant-connection-ii/)

在本问题中，有根树指满足以下条件的 **有向** 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。

输入一个有向图，该图由一个有着 `n` 个节点（节点值不重复，从 `1` 到 `n`）的树及一条附加的有向边构成。附加的边包含在 `1` 到 `n` 中的两个不同顶点间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组 `edges` 。 每个元素是一对 `[ui, vi]`，用以表示 **有向** 图中连接顶点 `ui` 和顶点 `vi` 的边，其中 `ui` 是 `vi` 的一个父节点。

返回一条能删除的边，使得剩下的图是有 `n` 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/12/20/graph1.jpg)

```
输入：edges = [[1,2],[1,3],[2,3]]
输出：[2,3]
```

```java
class UnionFind{
    int[] parent;
    public UnionFind(int n){
        parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // find
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x  = parent[x];
        }
        return x;
    }
    // union
    public boolean union(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty){
            return false;
        }
        parent[rootx] = rooty;
        return true;
    }

}

class Solution {
    // 判断是否成环
    public boolean judgeCircle(int[][] edges,int len,int removeEdegeIndex){
        UnionFind union = new UnionFind(len+1);
        for(int i=0;i<len;i++){
            if(i==removeEdegeIndex){
                continue;
            }
            if(!union.union(edges[i][0],edges[i][1])){
                // 合并失败，表示其已经在一个连通分量里面了
                return true;
            }
        }
        return false;
    }

    public int[] findRedundantDirectedConnection(int[][] edges) {
        // 边的条数
        int len = edges.length;
        int[] indeg = new int[len+1];
        for(int[] edge:edges){
            indeg[edge[1]]++;
        }
        // 尝试删除入度为2的，看是否形成环
        for(int i=len-1;i>=0;i--){
            if(indeg[edges[i][1]]==2){
                if(!judgeCircle(edges,len,i)){
                    return edges[i];
                }
            }
        }
        // 尝试删除入度为1的，看是否形成环
        for(int i=len-1;i>=0;i--){
            if(indeg[edges[i][1]]==1){
                if(!judgeCircle(edges,len,i)){
                    return edges[i];
                }
            }
        }
        // 尝试删除入度为0的，看是否形成环
        for(int i=len-1;i>=0;i--){
            if(indeg[edges[i][1]]==1){
                if(!judgeCircle(edges,len,i)){
                    return edges[i];
                }
            }
        }
        return new int[0];
    }
}
```

## Floyd判断是否为先修

### Floyd-[1.Leetcode1462课程表IV](https://leetcode-cn.com/problems/course-schedule-iv/)

你总共需要上 n 门课，课程编号依次为 0 到 n-1 。

有的课会有直接的先修课程，比如如果想上课程 0 ，你必须先上课程 1 ，那么会以 [1,0] 数对的形式给出先修课程数对。

给你课程总数 n 和一个直接先修课程数对列表 prerequisite 和一个查询对列表 queries 。

对于每个查询对 queries[i] ，请判断 queries[i][0] 是否是 queries[i][1] 的先修课程。

请返回一个布尔值列表，列表中每个元素依次分别对应 queries 每个查询对的判断结果。

注意：如果课程 a 是课程 b 的先修课程且课程 b 是课程 c 的先修课程，那么课程 a 也是课程 c 的先修课程。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/05/30/graph.png)

输入：n = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
输出：[false,true]
解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。

```java
class Solution {
    public List<Boolean> checkIfPrerequisite(int n, int[][] prerequisites, int[][] queries) {
        // 计算该结点到其它结点的距离
        boolean[][] G = new boolean[n][n];
        // 初始化
        for(int i=0;i<prerequisites.length;i++){
            G[prerequisites[i][0]][prerequisites[i][1]] = true;
        }
        // 查看传递连接的
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                for(int k=0;k<n;k++){
                    if(G[j][i]&&G[i][k]){
                        G[j][k] = true;
                    }
                }
            }
        }
        // 判断
        List<Boolean> res = new ArrayList<>();
        for(int i=0;i<queries.length;i++){
            res.add(G[queries[i][0]][queries[i][1]]);
        }
        return res;
    }
}
```

## 无向图-染色

### BFS[1.Leetcode310 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

树是一个无向图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。

给你一棵包含 n 个节点的树，标记为 0 到 n - 1 。给定数字 n 和一个有 n - 1 条无向边的 edges 列表（每一个边都是一对标签），其中 edges[i] = [ai, bi] 表示树中节点 ai 和 bi 之间存在一条无向边。

可选择树中任何一个节点作为根。当选择节点 x 作为根节点时，设结果树的高度为 h 。在所有可能的树中，具有最小高度的树（即，min(h)）被称为 最小高度树 。

请你找到所有的 最小高度树 并按 任意顺序 返回它们的根节点标签列表。

树的 高度 是指根节点和叶子节点之间最长向下路径上边的数量。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/01/e1.jpg)


输入：n = 4, edges = [[1,0],[1,2],[1,3]]
输出：[1]
解释：如图所示，当根是标签为 1 的节点时，树的高度是 1 ，这是唯一的最小高度树。

> 得到最后度为1的，即为结果。

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        // 如果n为2那么直接返回即可了
        List<Integer> res = new ArrayList<>();
        if(n<=2){
            for(int i=0;i<n;i++){
                res.add(i);
            }
            return res;
        }
        // 构建无向图
        List<List<Integer>> graph = new ArrayList<>();
        // 入度
        int[] indeg = new int[n];
        // 初始化
        for(int i=0;i<n;i++){
            graph.add(new ArrayList<>());
        }
        // 初始化赋值
        for(int[] edge:edges){
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
            indeg[edge[0]]++;
            indeg[edge[1]]++;
        }
        // 层次遍历
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<n;i++){
            if(indeg[i]==1){
                queue.offer(i);
            }
        }
        while(!queue.isEmpty()){
            int size = queue.size();
            res = new ArrayList<>();
            // 对其遍历
            for(int i=0;i<size;i++){
                int curr = queue.poll();
                res.add(curr);
                // 对其邻居遍历
                for(Integer next:graph.get(curr)){
                    indeg[next]--;
                    if(indeg[next]==1){
                        queue.offer(next);
                    }
                }
            }
        }
        return res;

    }
}
```

### 染色问题-[1.Leetcode785 判断二分图](https://leetcode-cn.com/problems/is-graph-bipartite/)

存在一个 无向图 ，图中有 n 个节点。其中每个节点都有一个介于 0 到 n - 1 之间的唯一编号。给你一个二维数组 graph ，其中 graph[u] 是一个节点数组，由节点 u 的邻接节点组成。形式上，对于 graph[u] 中的每个 v ，都存在一条位于节点 u 和节点 v 之间的无向边。该无向图同时具有以下属性：
不存在自环（graph[u] 不包含 u）。
不存在平行边（graph[u] 不包含重复值）。
如果 v 在 graph[u] 内，那么 u 也应该在 graph[v] 内（该图是无向图）
这个图可能不是连通图，也就是说两个节点 u 和 v 之间可能不存在一条连通彼此的路径。
二分图 定义：如果能将一个图的节点集合分割成两个独立的子集 A 和 B ，并使图中的每一条边的两个节点一个来自 A 集合，一个来自 B 集合，就将这个图称为 二分图 。

如果图是二分图，返回 true ；否则，返回 false 。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/21/bi2.jpg)


输入：graph = [[1,2,3],[0,2],[0,1,3],[0,2]]
输出：false
解释：不能将节点分割成两个独立的子集，以使每条边都连通一个子集中的一个节点与另一个子集中的一个节点。

示例 2：

![img](https://assets.leetcode.com/uploads/2020/10/21/bi1.jpg)


输入：graph = [[1,3],[0,2],[1,3],[0,2]]
输出：true
解释：可以将节点分成两组: {0, 2} 和 {1, 3} 。

> 解题思路：
>
> 若无向图 G=(V,E)*G*=(*V*,*E*) 的顶点集 V*V* 可以分割为两个互不相交的子集，且图中每条边的两个顶点分别属于不同的子集，则称图 G*G* 为一个二分图。
>
> 我们使用图搜索算法从各个连通域的任一顶点开始遍历整个连通域，遍历的过程中用两种不同的颜色对顶点进行染色，相邻顶点染成相反的颜色。这个过程中倘若发现相邻的顶点被染成了相同的颜色，说明它不是二分图；反之，如果所有的连通域都染色成功，说明它是二分图



> 输入的处理方式

```java
public class Test2 {
	// 输入是1,2,3;0,2;0,1,3;0,2
	//[[1,2,3],[0,2],[0,1,3],[0,2]]
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		String[] arr = str.split(";");
		// 存储
		List<int[]> list = new ArrayList<>();
		for(int i=0;i<arr.length;i++) {
			String[] temp = arr[i].split(",");
			//添加
			List<Integer> temp_l = new ArrayList<>();
			for(String n:temp) {
				temp_l.add(Integer.valueOf(n));
			}
			int[] intArr = temp_l.stream().mapToInt(Integer::intValue).toArray();
			list.add(intArr);
		}
		// 转为数组
		int[][] graph = list.toArray(new int[list.size()][]);
		for(int i=0;i<graph.length;i++) {
			for(int j=0;j<graph[i].length;j++) {
				System.out.print(graph[i][j]);
			}
			System.out.println();
		}		
	}
}

```



**BFS的算法**

```java
class Solution {
    public boolean isBipartite(int[][] graph) {
        // 给出的依赖关系
        // 是否遍历过
        int n = graph.length;
        int[] visited = new int[n];
        // BFS
        Queue<Integer> queue = new LinkedList<>();
        for(int i=0;i<graph.length;i++){
            // 遍历顶点连接
            // 未访问过的要
            if(visited[i]!=0){
                // 访问过的结点了
                continue;
            }
            // 入结点
            queue.offer(i);
            visited[i] = 1;
            //继续
            while(!queue.isEmpty()){
                int v = queue.poll();
                // 遍历其余结点
                for(int w:graph[v]){
                    // 如果当前节点和某个邻接点颜色相同则不行
                    if(visited[w]==visited[v]){
                        return false;
                    }
                    if(visited[w]==0){
                        // 染上不同的色
                        visited[w] = -visited[v];
                        queue.offer(w);
                    }
                }
            }
        }
        return true;
    }
}
```

**dfs**

```java
class Solution {
    //dfs算法
    public boolean isBipartite(int[][] graph) {
        int n = graph.length;
        int[] visited = new int[n];
        for(int i=0;i<n;i++){
            if(visited[i]==0&&!dfs(graph,i,1,visited)){
                return false;
            }
        }
        return true;
    }

    // dfs
    public boolean dfs(int[][] graph,int v,int color,int[] visited){
        if(visited[v]!=0){
            return visited[v]==color;
        }
        visited[v] = color;
        for(int w:graph[v]){
            if(!dfs(graph,w,-color,visited)){
                return false;
            }
        }
        return true;
    }
}
```

### 染色问题-[Leetcode1042 不邻接值花](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

有 n 个花园，按从 1 到 n 标记。另有数组 paths ，其中 paths[i] = [xi, yi] 描述了花园 xi 到花园 yi 的双向路径。在每个花园中，你打算种下四种花之一。

另外，所有花园 最多 有 3 条路径可以进入或离开.

你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。

以数组形式返回 任一 可行的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1、2、3、4 表示。保证存在答案。

 

示例 1：

输入：n = 3, paths = [[1,2],[2,3],[3,1]]
输出：[1,2,3]
解释：
花园 1 和 2 花的种类不同。
花园 2 和 3 花的种类不同。
花园 3 和 1 花的种类不同。
因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]

```java
class Solution {
    // 限制了每个结点的度为3，同时提供四种颜色
    // 存储邻接点信息
    // 遍历所有结点，对于结点
    // 查看其邻接点颜色，使用不同的颜色对其染色即可。
    public int[] gardenNoAdj(int n, int[][] paths) {
        Map<Integer,List<Integer>> graph = new HashMap<>();
        for(int i=0;i<n;i++){
            graph.put(i,new ArrayList<>());
        }
        // 初始化
        for(int[] path:paths){
            int a = path[0]-1;
            int b = path[1]-1;
            graph.get(a).add(b);
            graph.get(b).add(a);
        }
        // 结果
        int[] res = new int[n];
        for(int i=0;i<n;i++){
            boolean[] used = new boolean[5];
            for(int adj:graph.get(i)){
                used[res[adj]] = true;
            }
            // 为当前节点染色
            for(int j=1;j<=4;j++){
                if(!used[j]){
                    res[i] = j;
                }
            }
        }
        
        return res;
    }
}
```

### 染色问题-[Leetcode1129 颜色交替的最短路径](https://leetcode-cn.com/problems/shortest-path-with-alternating-colors/)

在一个有向图中，节点分别标记为 0, 1, ..., n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。

red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。

返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的红色边和蓝色边交替出现的最短路径的长度。如果不存在这样的路径，那么 answer[x] = -1。

 

示例 1：

输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []
输出：[0,1,-1]
示例 2：

输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]
输出：[0,1,-1]

```java
class Solution {
    public int[] shortestAlternatingPaths(int n, int[][] red_edges, int[][] blue_edges) {
		List<List<Integer>> rg = new ArrayList<>();//这是 红色线的集合
		List<List<Integer>> bg = new ArrayList<>();//这是 蓝色线的集合

		for (int i = 0; i < n; i++) {
			//初始化两条线的集合
			rg.add(new ArrayList<>());
			bg.add(new ArrayList<>());
		}

		//根据数组改变 红蓝色线 集合
		for (int[] red : red_edges)rg.get(red[0]).add(red[1]);
		for (int[] blue : blue_edges)bg.get(blue[0]).add(blue[1]);

		int[][] ans = new int[n][2];
		for (int[] ansColor : ans) {
			//初始化所有距离为MAX
			ansColor[0] = Integer.MAX_VALUE;
			ansColor[1] = Integer.MAX_VALUE;
		}
		//出发点距离设为0
		ans[0][0] = 0;
		ans[0][1] = 0;

		dfs(ans, 0, 0, rg, bg);//从红色线出发
		dfs(ans, 1, 0, rg, bg);//从蓝色线出发

		int[] finalAns = new int[n];
		for (int i = 0; i < n; i++) {
			//取最小值  没有的话为-1
			finalAns[i] = Math.min(ans[i][0], ans[i][1]);
			if (finalAns[i] == Integer.MAX_VALUE)
				finalAns[i] = -1;
		}
		return finalAns;
	}

	public void dfs(int[][] ans, int color, int i, List<List<Integer>> rg, List<List<Integer>> bg) {
		List<List<Integer>> g = color == 0 ? rg : bg;//选择 红蓝色 线
		for (int j : g.get(i)) {
			//遍历该线段 以 i 为出发点的终点

			if (ans[i][color] + 1 < ans[j][Math.abs(color - 1)]) {
				//判断 0 -> i -> j 的长度是否 比 已有的 0 -> j 的路径长度长 若是 则更新 
				//!!!这个判断是整个算法的核心 
				//当在也找不到更短的路径时 dfs会停止搜索 否则继续

				ans[j][Math.abs(color - 1)] = ans[i][color] + 1;
				dfs(ans, Math.abs(color - 1), j, rg, bg);
			}
		}
	}
}
```

### 染色问题-[Leetcode886 可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)

给定一组 N 人（编号为 1, 2, ..., N）， 我们想把每个人分进任意大小的两组。

每个人都可能不喜欢其他人，那么他们不应该属于同一组。

形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。

当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。

 

示例 1：

输入：N = 4, dislikes = [[1,2],[1,3],[2,4]]
输出：true
解释：group1 [1,4], group2 [2,3]
示例 2：

输入：N = 3, dislikes = [[1,2],[1,3],[2,3]]
输出：false
示例 3：

输入：N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]
输出：false

```java
class Solution {
    // 表示是否能够二分
    boolean isTwoColor = true;
    public boolean possibleBipartition(int n, int[][] dislikes) {
        // 将图构建成邻接矩阵的表示
        int[][] graph = new int[n+1][n+1];
        for(int[] edges:dislikes){
            graph[edges[0]][edges[1]] = 1;
            graph[edges[1]][edges[0]] = 1;
        }
        // 标识每个结点的颜色 trues
        boolean[] colors = new boolean[n+1];
        // 表示是否访问过了
        boolean[] visited = new boolean[n+1];
        // 开始
        for(int i=1;i<=n;i++){
            // 如果没有访问
            if(!visited[i]){
                dfs(graph,visited,colors,i);
            }
            // 如果不能二分就返回false
            if(!isTwoColor){
                return false;
            }
        }
        return true;
    }
    // 深度优先搜索
    public void dfs(int[][] graph,boolean[] visited,boolean[] colors,int start){
        visited[start] = true;
        // 接着对该结点的邻居访问
        for(int i=1;i<graph.length;i++){
            if(graph[start][i]==0){
                continue;
            }
            if(!visited[i]){
                colors[i] = !colors[start];
                dfs(graph,visited,colors,i);
            }else if(colors[i]==colors[start]){
                isTwoColor = false;
            }
        }
    }

}
```

### [Leetcode256粉刷房子](https://leetcode-cn.com/problems/paint-house/)

假如有一排房子，共 n 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 n x 3 的正整数矩阵 costs 来表示的。

例如，costs[0][0] 表示第 0 号房子粉刷成红色的成本花费；costs[1][2] 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

 

示例 1：

输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。
示例 2：

输入: costs = [[7,6,2]]
输出: 2

```java
class Solution {
    public int minCost(int[][] costs) {
        int[] pre = new int[3];
        int[] next = new int[3];

        for (int i = 0; i < costs.length; i++) {
            int[] cost = costs[i];
            pre[0] = Math.min(next[1], next[2]) + cost[0];
            pre[1] = Math.min(next[0], next[2]) + cost[1];
            pre[2] = Math.min(next[0], next[1]) + cost[2];
            cost = pre;
            pre = next;
            next = cost;
        }
        return Math.min(Math.min(next[0], next[1]), next[2]);
    }
}
```

### Leetcode276 栅栏染色

有 k 种颜色的涂料和一个包含 n 个栅栏柱的栅栏，请你按下述规则为栅栏设计涂色方案：

每个栅栏柱可以用其中 一种 颜色进行上色。
相邻的栅栏柱 最多连续两个 颜色相同。
给你两个整数 k 和 n ，返回所有有效的涂色 方案数 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/02/28/paintfenceex1.png)


输入：n = 3, k = 2
输出：6
解释：所有的可能涂色方案如上图所示。注意，全涂红或者全涂绿的方案属于无效方案，因为相邻的栅栏柱 最多连续两个 颜色相同。

```java
class Solution {
    public int numWays(int n, int k){
        int [] dp = new int[n+1];
        for(int i = 1; i < dp.length; i++){
            if(i == 1){//初始条件
                dp[i] = k;
            }else if( i == 2){//初始条件
                dp[i] = k * k;
            }else{//转换方程
                dp[i] = dp[i-1] * (k-1) + dp[i-2] * (k-1);
            }
        }
        return dp[n];
    }
}
```



##  无向连通图

### Leetcode323 无向图中联通分量的数目

给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。

示例 1:

输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4 

输出: 2
示例 2:

输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

输出:  1

```java
class Solution {
    public int countComponents(int n, int[][] edges) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = i;
        }
        for (int[] edge : edges) {
            arr[findParent(arr, edge[0])] = arr[findParent(arr, edge[1])];
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == i) {
                count++;
            }
        }
        return count;
    }

    public int findParent(int[] arr, int idx) {
        return arr[idx] == idx ? idx : (arr[idx] = findParent(arr, arr[idx]));
    }
}
```



### 并查集-[1.Leetcode684 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

**注意：连通无向图 n个结点 n-1条边相连的信息**

在本问题中, 树指的是一个**连通且无环的无向图**。

输入一个图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。每一个边的元素是一对[u, v] ，满足 u < v，表示连接顶点u 和v的无向图的边。

返回一条可以删去的边，使得结果图是一个有着N个节点的树。如果有多个答案，则返回二维数组中最后出现的边。答案边 [u, v] 应满足相同的格式 u < v。

示例 1：

输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的无向图为:
  1
 / \
2 - 3
示例 2：

输入**: [[1,2], [2,3], [3,4], [1,4], [1,5]]**
输出: [1,4]
解释: 给定的无向图为:
5 - 1 - 2
    |   |
    4 - 3

在一棵树中，边的数量比节点的数量少 11。如果一棵树有 NN 个节点，则这棵树有 N-1N−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 NN。

树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。

可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。

如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。

如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

```java
class Solution {
    public int[] findRedundantConnection(int[][] edges) {
        int nodeCount = edges.length;
        // 并查集
        int[] parent = new int[nodeCount+1];
        // 初始化
        for(int i=1;i<=nodeCount;i++){
            parent[i] = i;
        }
        for(int i=0;i<nodeCount;i++){
            int[] edge = edges[i];
            int node1 = edge[0],node2 = edge[1];
            // 查找
            if(find(parent,node1)!=find(parent,node2)){
                union(parent,node1,node2);
            }else{
                return edge;
            }
        }
        return new int[0];
    }
    // 合并
    public void union(int[] parent,int index1,int index2){
       int root1 = find(parent,index1);
       int root2 = find(parent,index2);
       if(root1!=root2){
           parent[root1] = root2;
       }
    }
    // 查找
    public int find(int[] parent,int index){
        while(index!=parent[index]){
            parent[index] = parent[parent[index]];
            index = parent[index];
        }
        return index;
    }
}
```

### 并查集-[2.Leetcode990 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

 

示例 1：

输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
示例 2：

输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。

```java

class Solution {
    // 查找
    public int find(int[] parent,int index){
        while(index!=parent[index]){
            parent[index] = parent[parent[index]];
            index = parent[index];
        }
        return index;
    }
    // 合并
    public void union(int[] parent,int index1,int index2){
        int root1 = find(parent,index1);
        int root2 = find(parent,index2);
        if(root1!=root2){
            parent[root1] = parent[root2];
        }
    }

    public boolean equationsPossible(String[] equations) {
        // 等式方程，判断26个字母 用并查集
        // 初始化
        int[] parent = new int[26];
        for(int i=0;i<26;i++){
            parent[i] = i;
        }
        // 开始
        for(String str:equations){
            // 判断
            if(str.charAt(1)=='='){
                int index1 = str.charAt(0)-'a';
                int index2 = str.charAt(0)-'a';
                union(parent,index1,index2);
            }
        }

        for(String str:equations){
            if(str.charAt(1)=='!'){
                int index1 = str.charAt(0)-'a';
                int index2 = str.charAt(0)-'a';
                if(find(parent,index1)==find(parent,index2)){
                    return false;
                }
            }
        }
        return true;
    }

}
```

## 有向权值图

### DFS-[1.Leetcode 399 除法求值](https://leetcode-cn.com/problems/evaluate-division/)

给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。每个 Ai 或 Bi 是一个表示单个变量的字符串。

另有一些以数组 queries 表示的问题，其中 queries[j] = [Cj, Dj] 表示第 j 个问题，请你根据已知条件找出 Cj / Dj = ? 的结果作为答案。

返回 所有问题的答案 。如果存在某个无法确定的答案，则用 -1.0 替代这个答案。如果问题中出现了给定的已知条件中没有出现的字符串，也需要用 -1.0 替代这个答案。

注意：输入总是有效的。你可以假设除法运算中不会出现除数为 0 的情况，且不存在任何矛盾的结果。

 

示例 1：

输入：equations = [["a","b"],["b","c"]], values = [2.0,3.0], queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
输出：[6.00000,0.50000,-1.00000,1.00000,-1.00000]
解释：
条件：a / b = 2.0, b / c = 3.0
问题：a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
结果：[6.0, 0.5, -1.0, 1.0, -1.0 ]
示例 2：

输入：equations = [["a","b"],["b","c"],["bc","cd"]], values = [1.5,2.5,5.0], queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]
输出：[3.75000,0.40000,5.00000,0.20000]

> 解题思路: 构建有向图，之后dfs来求解

```java
// 定义邻接结点类
class Node{
    // 邻接结点所代表的字符串
    public String id;
    // 到达邻接结点所需的倍数
    public double num;
    //初始化
    public Node(String i,double n){
        id = i;
        num = n;
    }
}

class Solution {
    // 构建一个map
    Map<String,List<Node>> map;
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // 总数
        int n = equations.size();
        map = new HashMap<>();
        // 结果重新
        double[] res = new double[queries.size()];
        // 构建图
        for(int i=0;i<n;i++){
            //获取除数和被除数
            String divided = equations.get(i).get(0);
            String divisor = equations.get(i).get(1);
            // 如果map中不包含某个节点的字符串，那就添加一个键值对
            if(!map.containsKey(divided)){
                map.put(divided,new ArrayList<>());
            }
            if(!map.containsKey(divisor)){
                map.put(divisor,new ArrayList<>());
            }
            // 除数和被除数都放进去 有向图
            map.get(divided).add(new Node(divisor,values[i]));
            map.get(divisor).add(new Node(divided,1/values[i]));
        }

        // 获取结果
        int index = 0;
        for(List<String> q:queries){
            // 深度搜索
            res[index++] = dfs(q.get(0),q.get(1),1.0,new HashSet<>());  
        }
        return res;
    }

    // 深度 cur当前节点 dest目标节点 kernel 计算的倍数 set已走过的结点
    public double  dfs(String cur,String dest,double kernel,Set<String> set){
        // 如果map不包含当前的节点或者已经走过当前节点说明这条路不会产生答案
        if(!map.containsKey(cur)||set.contains(cur)){
            return -1.0;
        }
        //走到终点了
        if(cur.equals(dest)){
            return kernel;
        }
        // 添加过走过的结点
        set.add(cur);
        // 遍历当前节点的邻接节点
        for(Node node:map.get(cur)){
            // 继续深搜
            double temp =  dfs(node.id,dest,kernel*node.num,set);
            if(temp!=-1.0){
                return temp;
            }
        }
        //没有搜到
        return -1.0;
    }


}
```

### DFS-[2.Leetcode743 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

有 n 个网络节点，标记为 1 到 n。

给你一个列表 times，表示信号经过 有向 边的传递时间。 times[i] = (ui, vi, wi)，其中 ui 是源节点，vi 是目标节点， wi 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 K 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2

```java
class Solution {
    // 构建图
    // 构建从起点到每个结点的时间
    Map<Integer,Integer> dist = new HashMap<>();
    public int networkDelayTime(int[][] times, int n, int k) {
        Map<Integer,List<int[]>> graph = new HashMap<>();
        // 初始化构建
        for(int[] edge:times){
            int src = edge[0];
            int dst = edge[1];
            int time = edge[2];
            if(!graph.containsKey(src)){
                graph.put(src,new ArrayList<>());
            }
            graph.get(src).add(new int[]{dst,time});
        }
        // 排序
        for(int node:graph.keySet()){
            Collections.sort(graph.get(node),(a,b)->(a[1]-b[1]));
        }
        
        //初始化
        for(int node=1;node<=n;node++){
            dist.put(node,Integer.MAX_VALUE);
        }
        dfs(graph,k,0);
        // 结果
        int res = 0;
        for(int cand:dist.values()){
            if(cand==Integer.MAX_VALUE){
                return -1;
            }
            res = Math.max(res,cand);
        }
        return res;
    }

    //遍历
    public void dfs(Map<Integer,List<int[]>> graph,int node,int elspsed){
        //访问过了
        if(elspsed>=dist.get(node)){
            return;
        }
        dist.put(node,elspsed);
        if(graph.containsKey(node)){
            for(int[] info:graph.get(node)){
                dfs(graph,info[0],elspsed+info[1]);
            }
        }
    }
}
```

## 无向权值图

### [1.Leetcode1514 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)

给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。

指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png)

输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
输出：0.25000
解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25

```java
//封装一个结点
class Pair implements Comparable<Pair>{
    double probaility;
    int node;

    // 初始化
    public Pair(double probaility,int node){
        this.probaility = probaility;
        this.node = node;
    }
    // 比较
    public int compareTo(Pair pair2){
        if(this.probaility==pair2.probaility){
            return this.node-pair2.node;
        }else{
            return this.probaility-pair2.probaility>0?-1:1;
        }
    }
}

class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        // 构建图
        List<List<Pair>> graph = new ArrayList<>();
        for(int i=0;i<n;i++){
            graph.add(new ArrayList<>());
        }
        for(int i=0;i<edges.length;i++){
            int[] e = edges[i];
            graph.get(e[0]).add(new Pair(succProb[i],e[1]));
            graph.get(e[1]).add(new Pair(succProb[i],e[0]));
        }

        // 权值
        PriorityQueue<Pair> queue = new PriorityQueue<>();
        // 结果
        double[] prob = new double[n];
        queue.offer(new Pair(1,start));
        prob[start] = 1;
        while(!queue.isEmpty()){
            Pair pair = queue.poll();
            double pr = pair.probaility;
            int node = pair.node;
            if(pr<prob[node]){
                continue;
            }
            for(Pair pairNext:graph.get(node)){
                double prNext = pairNext.probaility;
                int nodeNext = pairNext.node;
                if(prob[nodeNext]<prob[node]*prNext){
                    prob[nodeNext] = prob[node]*prNext;
                    queue.offer(new Pair(prob[nodeNext],nodeNext));
                }
            }
        }
        return prob[end];
    }
}
```

### DFS-[2.Leetcode1786 从第一个节点出发到最后一个节点的受限路径数](https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/)

现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。

从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, ..., zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 <= i <= k-1 的节点 zi 和 zi+1 之间存在一条边。

路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) > distanceToLastNode(zi+1) 的一条路径，其中 0 <= i <= k-1 。

返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png)

输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
输出：3
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png)


输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
输出：1
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。

```java
class Solution {
    final int MOD = 1000000007;
    public int countRestrictedPaths(int n, int[][] edges) {
        int cnt = 0;
        Map<Integer, List<int[]>> map = new HashMap<>();
        // 初始化邻接表
        for (int[] t : edges) {
            int x = t[0];
            int y = t[1];
            map.computeIfAbsent(x, k -> new ArrayList<>()).add(new int[]{y, t[2]});
            map.computeIfAbsent(y, k -> new ArrayList<>()).add(new int[]{x, t[2]});
        }
        
        // 保存到n点的 最短距离 和 受限路径数
        int[] distance = findShortPath(map,n,n);
        
        Long[] mem = new Long[n + 1];
        cnt = (int)findLimitedPathCount(map,1,n,distance,mem);
        return cnt;
    }
    public int[] findShortPath( Map<Integer, List<int[]>> map, int n, int start) {
        // 初始化distance数组和visit数组，并用最大值填充作为非连接状态INF
        int[] distance = new int[n + 1];
        Arrays.fill(distance, Integer.MAX_VALUE);
        boolean[] visit = new boolean[n + 1];

        // 初始化，索引0和起点的distance为0
        distance[start] = 0;
        distance[0] = 0;

        // 堆优化，将距离作为排序标准。单独用传入距离是因为PriorityQueue的上浮规则决定
        PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        // 把起点放进去，距离为0
        queue.offer(new int[]{start,0});

        while (!queue.isEmpty()) {
        // 当队列不空，拿出一个源出来
        Integer poll = queue.poll()[0];
        if(visit[poll]) continue;
        // 标记访问
        visit[poll] = true;
        // 遍历它的相邻节点
        List<int[]> list = map.getOrDefault(poll, Collections.emptyList());
        for (int[] arr : list) {
            int next = arr[0];
            if (visit[next]) continue;
            // 更新到这个相邻节点的最短距离，与 poll出来的节点增加的距离 比较
            distance[next] = Math.min(distance[next], distance[poll] + arr[1]);
            //堆中新增节点，这里需要手动传入 next节点堆距离值。否则如果next在队列中，将永远无法上浮。
            queue.offer(new int[]{next,distance[next]});
        }
        }
        return distance;
    }
    
    private long findLimitedPathCount(Map<Integer, List<int[]>> map, int i, int n, int[] distance, Long[] mem) {
        if(mem[i]!=null)return mem[i];
        if(i==n)return 1;
        long cnt = 0;
        List<int[]> list = map.getOrDefault(i,Collections.emptyList());
        for (int[] arr:list){
            int next = arr[0];
            //如果相邻节点距离比当前距离小，说明是受限路径
            if(distance[next] < distance[i]){
                cnt += findLimitedPathCount(map,next,n,distance,mem);
                cnt %= MOD;
            }
        }
        mem[i] = cnt;
        return cnt;
    }
}
```

### Floyd-[3.Leetcode1334阈值邻居内最少的城市](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)

有 n 个城市，按从 0 到 n-1 编号。给你一个边数组 edges，其中 edges[i] = [fromi, toi, weighti] 代表 fromi 和 toi 两个城市之间的双向加权边，距离阈值是一个整数 distanceThreshold。

返回能通过某些路径到达其他城市数目最少、且路径距离 最大 为 distanceThreshold 的城市。如果有多个这样的城市，则返回编号最大的城市。

注意，连接城市 i 和 j 的路径的距离等于沿该路径的所有边的权重之和。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_01.png)

输入：n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
输出：3
解释：城市分布图如上。
每个城市阈值距离 distanceThreshold = 4 内的邻居城市分别是：
城市 0 -> [城市 1, 城市 2] 
城市 1 -> [城市 0, 城市 2, 城市 3] 
城市 2 -> [城市 0, 城市 1, 城市 3] 
城市 3 -> [城市 1, 城市 2] 
城市 0 和 3 在阈值距离 4 以内都有 2 个邻居城市，但是我们必须返回城市 3，因为它的编号最大。
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/26/find_the_city_02.png)

输入：n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
输出：0
解释：城市分布图如上。 
每个城市阈值距离 distanceThreshold = 2 内的邻居城市分别是：
城市 0 -> [城市 1] 
城市 1 -> [城市 0, 城市 4] 
城市 2 -> [城市 3, 城市 4] 
城市 3 -> [城市 2, 城市 4]
城市 4 -> [城市 1, 城市 2, 城市 3] 
城市 0 在阈值距离 2 以内只有 1 个邻居城市。

```java
class Solution {
    public int findTheCity(int n, int[][] edges, int distanceThreshold) {
        int[][] graph = new int[n][n];
        // 初始化
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(i==j){
                    graph[i][j] = 0;
                }else{
                    graph[i][j] = Integer.MAX_VALUE;
                }
            }
        }
        //  初始化
        for(int[] edge:edges){
            graph[edge[0]][edge[1]] = graph[edge[1]][edge[0]] = edge[2];
        }
        // floyd
        for(int k=0;k<n;k++){
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    if(i!=k&&j!=k&&graph[i][k]!=Integer.MAX_VALUE&&graph[k][j]!=Integer.MAX_VALUE){
                        graph[i][j] = Math.min(graph[i][j],graph[i][k]+graph[k][j]);
                    }
                }
            }
        }

        // get res
        int min = n + 1;
        int res = -1;
        for(int i=0;i<n;i++){
            int count = 0;
            for(int j=0;j<n;j++){
                if(i!=j&&graph[i][j]<=distanceThreshold){
                    count++;
                }
            }
            if(min>=count){
                min = count;
                res = i;
            }
        }
        return res;
    }
}
```

## A到B之间的最小以及最大

### DFS-[1.Leetcode 面试题04.01 节点间通路](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

示例1:

 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
示例2:

 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true

```java
class Solution {
    // 访问过的
    Set<Integer> visited = new HashSet<>();
    public boolean findWhetherExistsPath(int n, int[][] edges, int start, int target) {
        // 构建图
        Map<Integer,List<Integer>> graph = new HashMap<>();
        for(int[] arr:edges){
            if(!graph.containsKey(arr[0])){
                graph.put(arr[0],new ArrayList<>());
            }
            graph.get(arr[0]).add(arr[1]);
        }
        // 判断
        if(start==target){
            return true;
        }
        if(!graph.containsKey(start)){
            return false;
        }
        // dfs
        return dfs(start,target,graph);
    }

    public boolean dfs(int cur,int target,Map<Integer,List<Integer>> graph){
        if(cur==target){
            return true;
        }
        if(!graph.containsKey(cur)){
            return false;
        }
        visited.add(cur);
        for(int node:graph.get(cur)){
            if(!visited.contains(node)){
                if(dfs(node,target,graph)){
                    return true;
                }
            }
        }
        return false;
    }
}
```

### DFS-[2.Leetcode797 所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)

给一个有 n 个结点的有向无环图，找到所有从 0 到 n-1 的路径并输出（不要求按顺序）

二维数组的第 i 个数组中的单元都表示有向图中 i 号结点所能到达的下一些结点（译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a ）空就是没有下一个结点了。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

输入：graph = [[1,2],[3],[3],[]]
输出：[[0,1,3],[0,2,3]]
解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
示例 2：

![img](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]



```java
class Solution {
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        return solve(graph,0);
    }

    public List<List<Integer>> solve(int[][] graph,int node){
        // 结点总数
        int n = graph.length;
        List<List<Integer>> res = new ArrayList<>();
        if(node==n-1){
            // 到达最后一个； 
            List<Integer> path = new ArrayList<>();
            path.add(n-1);
            res.add(path);
            return res;
        } 
        // 其余的结点遍历
        for(int nei:graph[node]){
            for(List<Integer> path:solve(graph,nei)){
                path.add(0,node);
                res.add(path);
            }
        }
        return res;
    }
}
```

### DFS-[3.Leetcode1786 从第一个节点出发到最后一个节点的受限路径数](https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/)

现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。

从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, ..., zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 <= i <= k-1 的节点 zi 和 zi+1 之间存在一条边。

路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) > distanceToLastNode(zi+1) 的一条路径，其中 0 <= i <= k-1 。

返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex1.png)

输入：n = 5, edges = [[1,2,3],[1,3,3],[2,3,1],[1,4,2],[5,2,2],[3,5,1],[5,4,10]]
输出：3
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。三条受限路径分别是：
1) 1 --> 2 --> 5
2) 1 --> 2 --> 3 --> 5
3) 1 --> 3 --> 5
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/03/07/restricted_paths_ex22.png)


输入：n = 7, edges = [[1,3,1],[4,1,2],[7,3,4],[2,5,3],[5,6,1],[6,7,2],[7,5,3],[2,6,4]]
输出：1
解释：每个圆包含黑色的节点编号和蓝色的 distanceToLastNode 值。唯一一条受限路径是：1 --> 3 --> 7 。

```java
class Solution {
    final int MOD = 1000000007;
    public int countRestrictedPaths(int n, int[][] edges) {
        int cnt = 0;
        Map<Integer, List<int[]>> map = new HashMap<>();
        // 初始化邻接表
        for (int[] t : edges) {
            int x = t[0];
            int y = t[1];
            map.computeIfAbsent(x, k -> new ArrayList<>()).add(new int[]{y, t[2]});
            map.computeIfAbsent(y, k -> new ArrayList<>()).add(new int[]{x, t[2]});
        }
        
        // 保存到n点的 最短距离 和 受限路径数
        int[] distance = findShortPath(map,n,n);
        
        Long[] mem = new Long[n + 1];
        cnt = (int)findLimitedPathCount(map,1,n,distance,mem);
        return cnt;
    }
    public int[] findShortPath( Map<Integer, List<int[]>> map, int n, int start) {
        // 初始化distance数组和visit数组，并用最大值填充作为非连接状态INF
        int[] distance = new int[n + 1];
        Arrays.fill(distance, Integer.MAX_VALUE);
        boolean[] visit = new boolean[n + 1];

        // 初始化，索引0和起点的distance为0
        distance[start] = 0;
        distance[0] = 0;

        // 堆优化，将距离作为排序标准。单独用传入距离是因为PriorityQueue的上浮规则决定
        PriorityQueue<int[]> queue = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]);
        // 把起点放进去，距离为0
        queue.offer(new int[]{start,0});

        while (!queue.isEmpty()) {
        // 当队列不空，拿出一个源出来
        Integer poll = queue.poll()[0];
        if(visit[poll]) continue;
        // 标记访问
        visit[poll] = true;
        // 遍历它的相邻节点
        List<int[]> list = map.getOrDefault(poll, Collections.emptyList());
        for (int[] arr : list) {
            int next = arr[0];
            if (visit[next]) continue;
            // 更新到这个相邻节点的最短距离，与 poll出来的节点增加的距离 比较
            distance[next] = Math.min(distance[next], distance[poll] + arr[1]);
            //堆中新增节点，这里需要手动传入 next节点堆距离值。否则如果next在队列中，将永远无法上浮。
            queue.offer(new int[]{next,distance[next]});
        }
        }
        return distance;
    }
    
    private long findLimitedPathCount(Map<Integer, List<int[]>> map, int i, int n, int[] distance, Long[] mem) {
        if(mem[i]!=null)return mem[i];
        if(i==n)return 1;
        long cnt = 0;
        List<int[]> list = map.getOrDefault(i,Collections.emptyList());
        for (int[] arr:list){
            int next = arr[0];
            //如果相邻节点距离比当前距离小，说明是受限路径
            if(distance[next] < distance[i]){
                cnt += findLimitedPathCount(map,next,n,distance,mem);
                cnt %= MOD;
            }
        }
        mem[i] = cnt;
        return cnt;
    }
}
```

### BFS-[1.Leetcode1514 概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)

给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。

指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。

如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/07/12/1558_ex1.png)

输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2
输出：0.25000
解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25

```java
//封装一个结点
class Pair implements Comparable<Pair>{
    double probaility;
    int node;

    // 初始化
    public Pair(double probaility,int node){
        this.probaility = probaility;
        this.node = node;
    }
    // 比较
    public int compareTo(Pair pair2){
        if(this.probaility==pair2.probaility){
            return this.node-pair2.node;
        }else{
            return this.probaility-pair2.probaility>0?-1:1;
        }
    }
}

class Solution {
    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {
        // 构建图
        List<List<Pair>> graph = new ArrayList<>();
        for(int i=0;i<n;i++){
            graph.add(new ArrayList<>());
        }
        for(int i=0;i<edges.length;i++){
            int[] e = edges[i];
            graph.get(e[0]).add(new Pair(succProb[i],e[1]));
            graph.get(e[1]).add(new Pair(succProb[i],e[0]));
        }

        // 权值
        PriorityQueue<Pair> queue = new PriorityQueue<>();
        // 结果
        double[] prob = new double[n];
        queue.offer(new Pair(1,start));
        prob[start] = 1;
        while(!queue.isEmpty()){
            Pair pair = queue.poll();
            double pr = pair.probaility;
            int node = pair.node;
            if(pr<prob[node]){
                continue;
            }
            for(Pair pairNext:graph.get(node)){
                double prNext = pairNext.probaility;
                int nodeNext = pairNext.node;
                if(prob[nodeNext]<prob[node]*prNext){
                    prob[nodeNext] = prob[node]*prNext;
                    queue.offer(new Pair(prob[nodeNext],nodeNext));
                }
            }
        }
        return prob[end];
    }
}
```

### 并查集-[1.Leetcode1631 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)

你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png)

输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex2.png)



输入：heights = [[1,2,3],[3,8,4],[5,3,5]]
输出：1
解释：路径 [1,2,3,4,5] 的相邻格子差值绝对值最大为 1 ，比路径 [1,3,5,3,5] 更优。

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        //Kruskal构造连边
        List<int[]> edges = new LinkedList<>();
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                int id = i*cols+j;
                if(i<rows-1){
                    edges.add(new int[]{id,id+cols,Math.abs(heights[i][j]-heights[i+1][j])});
                }
                if(j<cols-1){
                    edges.add(new int[]{id,id+1,Math.abs(heights[i][j]-heights[i][j+1])});
                }
            }
        }
        //根据结点之间的权值进行排序
        Collections.sort(edges,new Comparator<int[]>(){
            public int compare(int[] o1,int[] o2){
                return o1[2] - o2[2];
            }
        });
        int ans = 0;
        //从小到大连通结点
        UnionFind uf = new UnionFind(rows*cols);
        for(int i=0;i<edges.size();i++){
            int[] temp = edges.get(i);
            int x = temp[0];
            int y = temp[1];
            int dp = temp[2];
            if(uf.find(x)!=uf.find(y)){
                uf.union(x,y);
                ans = dp;
            }
            //左上角结点和右下角结点连通
            if(uf.find(0)==uf.find(rows*cols-1)){
                break;
            }
        }
        return ans;
    }
}
// 并查集
class UnionFind{
    private int[] parent;
    private int count;

    public int getCount(){
        return count;
    }
    // 初始化
    public UnionFind(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // 开始找
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    // 合并
    public void union(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty){
            return;
        }
        parent[rootx] = rooty;
        count--;
    }

}
```

## 正方形下的解法

### [1.Leetcode1162 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

你现在手里有一份大小为 N x N 的 网格 grid，上面的每个 单元格 都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的。

我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。

如果网格上只有陆地或者海洋，请返回 -1。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex1.jpeg)

输入：[[1,0,1],[0,0,0],[1,0,1]]
输出：2
解释： 
海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2。
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/08/17/1336_ex2.jpeg)

输入：[[1,0,0],[0,0,0],[0,0,0]]
输出：4
解释： 
海洋单元格 (2, 2) 和所有陆地单元格之间的距离都达到最大，最大距离为 4。

> 解题思路：

相信对于Tree的BFS大家都已经轻车熟路了：要把root节点先入队，然后再一层一层的无脑遍历就行了。

对于图的BFS也是一样滴～ 与Tree的BFS区别如下：

- 1、tree只有1个root，而**图可以有多个源点，所以首先需要把多个源点都入队**。
- 2、**tree是有向的因此不需要标志是否访问**过，而对于**无向图来说，必须得标志是否访问过！**
  **并且为了防止某个节点多次入队，需要在入队之前就将其设置成已访问**！

这是一道典型的BFS基础应用，为什么这么说呢？
因为我们只要先把所有的陆地都入队，然后从各个陆地同时开始一层一层的向海洋扩散，那么最后扩散到的海洋就是最远的海洋！
并且这个海洋肯定是被离他最近的陆地给扩散到的！
下面是扩散的图示，1表示陆地，0表示海洋。每次扩散的时候会标记相邻的4个位置的海洋：

![image.png](https://pic.leetcode-cn.com/367df5172fd16d2637e591f6586d146772758438c66660c86719ffb2d36eb14d-image.png)


你可以想象成你从每个陆地上派了很多支船去踏上伟大航道，踏遍所有的海洋。每当船到了新的海洋，就会分裂成4条新的船，向新的未知海洋前进（访问过的海洋就不去了）。如果船到达了某个未访问过的海洋，那他们是第一个到这片海洋的。很明显，这么多船最后访问到的海洋，肯定是离陆地最远的海洋。

```java
class Solution {
    public int maxDistance(int[][] grid) {
        // 周围的四个点
        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        //BFS的解法
        Queue<int[]> queue = new LinkedList<>();
        // 陆地全入队列
        int n = grid.length;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    queue.offer(new int[]{i,j});
                }
            }
        }
        // 判断是否出现海洋了
        boolean isOcean = false;
        int[] point = null;
        while(!queue.isEmpty()){
            point = queue.poll();
            int x = point[0], y = point[1];
            // 循环
            for(int i=0;i<4;i++){
                int newx = x + dx[i], newy = y+dy[i];
                // 是否越界
                if(newx<0 || newx>=n || newy<0 || newy>=n || grid[newx][newy]!=0){
                    //继续下一个
                    continue;
                }
               
                // 修改其值
                grid[newx][newy] = grid[x][y] + 1;
                 // 入队列
                 isOcean = true;
                queue.offer(new int[]{newx,newy});
            }
        }
        // 没有陆地或者海洋
        if(point==null || !isOcean){
            return -1;
        }
        // 返回最后一次遍历到的海洋距离
        return grid[point[0]][point[1]]-1;

    }
}
```

### [2.Leetcode1765 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

给你一个大小为 m x n 的整数矩阵 isWater ，它代表了一个由 陆地 和 水域 单元格组成的地图。

如果 isWater[i][j] == 0 ，格子 (i, j) 是一个 陆地 格子。
如果 isWater[i][j] == 1 ，格子 (i, j) 是一个 水域 格子。
你需要按照如下规则给每个单元格安排高度：

每个格子的高度都必须是非负的。
如果一个格子是是 水域 ，那么它的高度必须为 0 。
任意相邻的格子高度差 至多 为 1 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）
找到一种安排高度的方案，使得矩阵中的最高高度值 最大 。

请你返回一个大小为 m x n 的整数矩阵 height ，其中 height[i][j] 是格子 (i, j) 的高度。如果有多种解法，请返回 任意一个 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png)

输入：isWater = [[0,1],[0,0]]
输出：[[1,0],[2,1]]
解释：上图展示了给各个格子安排的高度。
蓝色格子是水域格，绿色格子是陆地格。
示例 2：

![img](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png)

输入：isWater = [[0,0,1],[1,0,0],[0,0,0]]
输出：[[1,1,0],[0,1,1],[1,2,2]]
解释：所有安排方案中，最高可行高度为 2 。
任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。

```java
class Solution {
    public int[][] highestPeak(int[][] grid) {
         // 周围的四个点
        int[] dx = {1,-1,0,0};
        int[] dy = {0,0,1,-1};
        //BFS的解法
        Queue<int[]> queue = new LinkedList<>();
        // 水全入队列
        int n = grid.length;
        int m = grid[0].length;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]==1){
                    grid[i][j] = 0;
                    queue.offer(new int[]{i,j});
                }else{
                    grid[i][j]=-1;
                }
            }
        }
        // 判断是否出现海洋了
        boolean isLand = false;
        int[] point = null;
        while(!queue.isEmpty()){
            point = queue.poll();
            int x = point[0], y = point[1];
            // 循环
            for(int i=0;i<4;i++){
                int newx = x + dx[i], newy = y+dy[i];
                // 是否越界
                if(newx>=0 && newx<n && newy>=0 && newy<m && grid[newx][newy]==-1){               
                    // 修改其值
                    grid[newx][newy] = grid[x][y] + 1;

                    queue.offer(new int[]{newx,newy});
                }
            }
        }

        // 返回最后一次遍历到的海洋距离
        return grid;
    }
}
```

### 3.[Leetcode1267 统计参与通信的服务器](https://leetcode-cn.com/problems/count-servers-that-communicate/)

这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。

如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。

请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-6.jpg)

输入：grid = [[1,0],[0,1]]
输出：0
解释：没有一台服务器能与其他服务器进行通信。
示例 2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/24/untitled-diagram-4-1.jpg)

输入：grid = [[1,0],[1,1]]
输出：3
解释：所有这些服务器都至少可以与一台别的服务器进行通信。

```java
class Solution {
    // 位于(x,y)的服务器能够与至少一台其它服务器进行通信，就必须满足第x行有一台其它服务器，要么第y列有一台其它服务器
    public int countServers(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        //开始构建
        int[] rows = new int[m];
        int[] cols = new int[n];
        // 初始化
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1){
                    rows[i]++;
                    cols[j]++;
                }
            }
        }
        // 统计结果
        int res = 0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(grid[i][j]==1&&(rows[i]>1 || cols[j]>1)){
                    res++;
                }
            }
        }
        return res;
    }
}
```

### [4.Leetcode996 正方形数组的数目](https://leetcode-cn.com/problems/number-of-squareful-arrays/)

给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。

返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。

 

示例 1：

输入：[1,17,8]
输出：2
解释：
[1,8,17] 和 [17,8,1] 都是有效的排列。
示例 2：

输入：[2,2,2]
输出：1

```java
class Solution {
    Map<Integer, Integer> count;
    Map<Integer, List<Integer>> graph;
    public int numSquarefulPerms(int[] A) {
        int N = A.length;
        count = new HashMap();
        graph = new HashMap();

        // count.get(v) : 数组 A 中值为 v 的节点数量
        for (int x: A)
            count.put(x, count.getOrDefault(x, 0) + 1);

        // graph.get(v) : 在 A 中的值 w 满足 v + w 是完全平方数
        //                (ie., "vw" is an edge)
        for (int x: count.keySet())
            graph.put(x, new ArrayList());

        for (int x: count.keySet())
            for (int y: count.keySet()) {
                int r = (int) (Math.sqrt(x + y) + 0.5);
                if (r * r == x + y)
                    graph.get(x).add(y);
            }

        // 增加从 x 开始的可行路径数量
        int ans = 0;
        for (int x: count.keySet())
            ans += dfs(x, N - 1);
        return ans;
    }

    public int dfs(int x, int todo) {
        count.put(x, count.get(x) - 1);
        int ans = 1;  
        if (todo != 0) {
            ans = 0;
            for (int y: graph.get(x)) if (count.get(y) != 0) {
                ans += dfs(y, todo - 1);
            }
        }
        count.put(x, count.get(x) + 1);
        return ans;
    }
}
```

### Leetcode1197 进击的骑士

一个坐标可以从 -infinity 延伸到 +infinity 的 无限大的 棋盘上，你的 骑士 驻扎在坐标为 [0, 0] 的方格里。

骑士的走法和中国象棋中的马相似，走 “日” 字：即先向左（或右）走 1 格，再向上（或下）走 2 格；或先向左（或右）走 2 格，再向上（或下）走 1 格。

每次移动，他都可以按图示八个方向之一前进。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/21/knight.png)

现在，骑士需要前去征服坐标为 [x, y] 的部落，请你为他规划路线。

最后返回所需的最小移动次数即可。本题确保答案是一定存在的。

 

示例 1：

输入：x = 2, y = 1
输出：1
解释：[0, 0] → [2, 1]

```java
class Solution {
       List<int[]> dirs = new ArrayList<int[]>(){{
        add(new int[]{-2, 1});
        add(new int[]{-1, 2});
        add(new int[]{1, 2});
        add(new int[]{2, 1});
        add(new int[]{-2, -1});
        add(new int[]{-1, -2});
        add(new int[]{1, -2});
        add(new int[]{2, -1});
    }};
    public int minKnightMoves(int x, int y) {
        if (x == 0 && y == 0) {
            return 0;
        }
        Queue<Node> queue = new LinkedList<>();
        queue.add(new Node(0, 0, getDistance(0, 0,x, y)));
        Set<String> visited = new HashSet<>();
        visited.add(0 + " " + 0);

        int count = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int k = 0; k < size; k++) {
                Node node = queue.poll();
                if (node.x == x && node.y == y) {
                    return count;
                }

                for (int[] dir : dirs) {
                    int newX = node.x + dir[0];
                    int newY = node.y + dir[1];
                    int path = node.path;
                    int newPath = getDistance(newX,newY,x,y);
                    if (visited.contains(newX + " " + newY)) {
                        continue;
                    }
                    if (newPath > path && newPath > 4) {
                        continue;
                    }
                    queue.add(new Node(newX, newY, newPath));
                    visited.add(newX + " " + newY);
                }
            }
            count++;
        }
        return count;
    }

    private int getDistance(int srcX, int srcY, int destX, int destY) {
        return Math.abs(destX - srcX) +  Math.abs(destY - srcY);
    }

    class Node{
        public int x;
        public int y;
        public int path;

        public Node(int x, int y, int path) {
            this.x = x;
            this.y = y;
            this.path = path;
        }
    }
}
```

### Leetcode544 砖墙

你的面前有一堵矩形的、由 n 行砖块组成的砖墙。这些砖块高度相同（也就是一个单位高）但是宽度不同。每一行砖块的宽度之和相等。

你现在要画一条 自顶向下 的、穿过 最少 砖块的垂线。如果你画的线只是从砖块的边缘经过，就不算穿过这块砖。你不能沿着墙的两个垂直边缘之一画线，这样显然是没有穿过一块砖的。

给你一个二维数组 wall ，该数组包含这堵墙的相关信息。其中，wall[i] 是一个代表从左至右每块砖的宽度的数组。你需要找出怎样画才能使这条线 穿过的砖块数量最少 ，并且返回 穿过的砖块数量 。

 

示例 1：

![img](https://assets.leetcode.com/uploads/2021/04/24/cutwall-grid.jpg)

输入：wall = [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]]
输出：2
示例 2：

输入：wall = [[1],[1],[1]]
输出：3

```java
class Solution {
    public int leastBricks(List<List<Integer>> wall) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (List<Integer> list : wall) {
            int index = 0;
            for (Integer i : list) {
                index += i;
                 map.put(index, map.getOrDefault(index, 0) + 1);
            }
        }
        int sum = 0;
        List<Integer> first = wall.get(0);
        for (Integer i : first) {
            sum += i;
       }
        int max = 0;
       if (map.size() > 1) {
    	   map.remove(sum);
    	   for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
    		   max = Math.max(max, entry.getValue());
    	   }
    	   return wall.size() - max;
       } else {
    	   return map.get(sum);
       }
    }
}
```





## 并查集

### Leetcode323 无向图中联通分量的数目

给定编号从 0 到 n-1 的 n 个节点和一个无向边列表（每条边都是一对节点），请编写一个函数来计算无向图中连通分量的数目。

示例 1:

输入: n = 5 和 edges = [[0, 1], [1, 2], [3, 4]]

     0          3
     |          |
     1 --- 2    4 

输出: 2
示例 2:

输入: n = 5 和 edges = [[0, 1], [1, 2], [2, 3], [3, 4]]

     0           4
     |           |
     1 --- 2 --- 3

输出:  1

```java
class Solution {
    public int countComponents(int n, int[][] edges) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = i;
        }
        for (int[] edge : edges) {
            arr[findParent(arr, edge[0])] = arr[findParent(arr, edge[1])];
        }
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (arr[i] == i) {
                count++;
            }
        }
        return count;
    }

    public int findParent(int[] arr, int idx) {
        return arr[idx] == idx ? idx : (arr[idx] = findParent(arr, arr[idx]));
    }
}
```



### [Leetcode547 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。

省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。

给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。

返回矩阵中 省份 的数量。

 

示例 1：


输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2

**并查集**

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int provinces = isConnected.length;
        int[] parent = new int[provinces];
        for (int i = 0; i < provinces; i++) {
            parent[i] = i;
        }
        for (int i = 0; i < provinces; i++) {
            for (int j = i + 1; j < provinces; j++) {
                if (isConnected[i][j] == 1) {
                    union(parent, i, j);
                }
            }
        }
        int circles = 0;
        for (int i = 0; i < provinces; i++) {
            if (parent[i] == i) {
                circles++;
            }
        }
        return circles;
    }

    public void union(int[] parent, int index1, int index2) {
        parent[find(parent, index1)] = find(parent, index2);
    }

    public int find(int[] parent, int index) {
        if (parent[index] != index) {
            parent[index] = find(parent, parent[index]);
        }
        return parent[index];
    }
}


```



**深度优先搜索**

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int provinces = isConnected.length;
        boolean[] visited = new boolean[provinces];
        int circles = 0;
        for (int i = 0; i < provinces; i++) {
            if (!visited[i]) {
                dfs(isConnected, visited, provinces, i);
                circles++;
            }
        }
        return circles;
    }

    public void dfs(int[][] isConnected, boolean[] visited, int provinces, int i) {
        for (int j = 0; j < provinces; j++) {
            if (isConnected[i][j] == 1 && !visited[j]) {
                visited[j] = true;
                dfs(isConnected, visited, provinces, j);
            }
        }
    }
}


```



### 剑指OfferII-116 朋友圈

一个班上有 n 个同学，其中一些彼此是朋友，另一些不是。朋友关系是可以传递的，如果 a 与 b 直接是朋友，且 b 与 c 是直接朋友，那么 a 与 c 就是间接朋友。

定义 朋友圈 就是一组直接或者间接朋友的同学集合。

给定一个 n x n 的矩阵 isConnected 表示班上的朋友关系，其中 isConnected[i][j] = 1 表示第 i 个同学和第 j 个同学是直接朋友，而 isConnected[i][j] = 0 表示二人不是直接朋友。

返回矩阵中 朋友圈的数量。

 

示例 1：


输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
输出：2

```java
class Solution {
    public int find(int[]fa,int x){
        if(fa[x]!=x) fa[x]=find(fa,fa[x]);
        return fa[x];
    }
    public int findCircleNum(int[][] isConnected) {
        int n=isConnected.length;
        int[] fa=new int[n];
        for(int i=0;i<n;i++){
            fa[i]=i;
        }
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(isConnected[i][j]==1){
                    if(find(fa,i)!=find(fa,j)){
                        fa[find(fa,i)]=find(fa,j);
                    }
                }
            }
        }
        int ans=0;
        for(int i=0;i<n;i++){
            if(find(fa,i)==i) ans++;
        }
        return ans;
    }
}

```




### [1.Leetcode959 由斜杆划分区域](https://leetcode-cn.com/problems/regions-cut-by-slashes/)

在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。

（请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示。）。

返回区域的数目。

 

示例 1：

输入：
[
  " /",
  "/ "
]
输出：2
解释：2x2 网格如下：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/1.png)

示例 2：

输入：
[
  " /",
  "  "
]
输出：1
解释：2x2 网格如下：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/2.png)

示例 3：

输入：
[
  "\\/",
  "/\\"
]
输出：4
解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）
2x2 网格如下：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/15/3.png)



```java
// 并查集
class UnionFind{
    private int[] parent;
    private int count;

    public int getCount(){
        return count;
    }
    // 初始化
    public UnionFind(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // 开始找
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    // 合并
    public void union(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty){
            return;
        }
        parent[rootx] = rooty;
        count--;
    }

}

class Solution {
    public int regionsBySlashes(String[] grid) {
        int n = grid.length;
        int size = 4 * n * n;
        UnionFind unionFind = new UnionFind(size);
        for(int i=0;i<n;i++){
            char[] row = grid[i].toCharArray();
            for(int j=0;j<n;j++){
                int index = 4 * (i*n+j);
                char c = row[j];
                if(c=='/'){
                    //合并0,3 合并1,2
                    unionFind.union(index,index+3);
                    unionFind.union(index+1,index+2);
                }else if(c=='\\'){
                    // 合并0,1 合并2,3
                    unionFind.union(index,index+1);
                    unionFind.union(index+2,index+3);
                }else{
                    unionFind.union(index,index+1);
                    unionFind.union(index+1,index+2);
                    unionFind.union(index+2,index+3);
                }

                //单元格间合并
                if(j+1<n){
                    unionFind.union(index+1,4*(i*n+j+1)+3);
                }
                if(i+1<n){
                    unionFind.union(index+2,4*((i+1)*n+j));
                }
            }
        }
        return unionFind.getCount();
    }
}
```

### [2.Leetcode1631 最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/)- 

你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights ，其中 heights[row][col] 表示格子 (row, col) 的高度。一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1) （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动，你想要找到耗费 体力 最小的一条路径。

一条路径耗费的 体力值 是路径上相邻格子之间 高度差绝对值 的 最大值 决定的。

请你返回从左上角走到右下角的最小 体力消耗值 。

 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/10/25/ex1.png)

输入：heights = [[1,2,2],[3,8,2],[5,3,5]]
输出：2
解释：路径 [1,3,5,3,5] 连续格子的差值绝对值最大为 2 。
这条路径比路径 [1,2,2,2,5] 更优，因为另一条路径差值最大值为 3 。

> 解题思路：

本题中，如果我们定义每个格子的状态是到达该格子的最小体力消耗路径，那么每个格子的状态其实跟上下左右四个方向都有关。如果我们仍然按照从左到右，从上到下的两重 for 循环已经无法搞定 4 个方向，因此只能放弃 DP 方法。

那这个题在考察什么呢？重要的提示就在于 4 个方向！一个格子和周围 4 个方向相邻格子的状态都有关，这就是在考察图！（如果题目说的是 8 个方向，那么更明显）。

我们把每个格子当做图的一个节点，把相邻两个格子的高度差绝对值当做边的权重。就可以把输入的矩阵转化成为每条边都带有权重的图。上文中的示例给出的矩阵可以转成下面的图，可以看到从最左上角到最右下角的最小体力消耗路径为紫色所示的路径，最小体力消耗值是该路径中的边的最大权重，即为 2。

当把题目转成图的问题之后，怎么求解最小体力消耗路径呢？我们认为这是在求从最左上角的节点到最右下角的节点的连通性问题。具体来说，我们可以先把图中的所有边都去掉，然后按照边的权重大小，把边再逐个的添加上。当我们添加到某一条边时，最左上角的节点和最右下角的节点连通了，那么该边的权重就是我们要求的最小体力消耗值。

```java
class Solution {
    public int minimumEffortPath(int[][] heights) {
        int rows = heights.length;
        int cols = heights[0].length;
        //Kruskal构造连边
        List<int[]> edges = new LinkedList<>();
        for(int i=0;i<rows;i++){
            for(int j=0;j<cols;j++){
                int id = i*cols+j;
                if(i<rows-1){
                    edges.add(new int[]{id,id+cols,Math.abs(heights[i][j]-heights[i+1][j])});
                }
                if(j<cols-1){
                    edges.add(new int[]{id,id+1,Math.abs(heights[i][j]-heights[i][j+1])});
                }
            }
        }
        //根据结点之间的权值进行排序
        Collections.sort(edges,new Comparator<int[]>(){
            public int compare(int[] o1,int[] o2){
                return o1[2] - o2[2];
            }
        });
        int ans = 0;
        //从小到大连通结点
        UnionFind uf = new UnionFind(rows*cols);
        for(int i=0;i<edges.size();i++){
            int[] temp = edges.get(i);
            int x = temp[0];
            int y = temp[1];
            int dp = temp[2];
            if(uf.find(x)!=uf.find(y)){
                uf.union(x,y);
                ans = dp;
            }
            //左上角结点和右下角结点连通
            if(uf.find(0)==uf.find(rows*cols-1)){
                break;
            }
        }
        return ans;
    }
}
// 并查集
class UnionFind{
    private int[] parent;
    private int count;

    public int getCount(){
        return count;
    }
    // 初始化
    public UnionFind(int n){
        this.count = n;
        this.parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // 开始找
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    // 合并
    public void union(int x,int y){
        int rootx = find(x);
        int rooty = find(y);
        if(rootx==rooty){
            return;
        }
        parent[rootx] = rooty;
        count--;
    }

}

```

### [3.Leetcode990 等式方程的可满足性](https://leetcode-cn.com/problems/satisfiability-of-equality-equations/)

给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。

只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 

 

示例 1：

输入：["a==b","b!=a"]
输出：false
解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。
示例 2：

输入：["b==a","a==b"]
输出：true
解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。

```java


class Solution {
    // 查找
    public int find(int[] parent,int index){
        while(index!=parent[index]){
            parent[index] = parent[parent[index]];
            index = parent[index];
        }
        return index;
    }
    // 合并
    public void union(int[] parent,int index1,int index2){
        int root1 = find(parent,index1);
        int root2 = find(parent,index2);
        if(root1!=root2){
            parent[root1] = parent[root2];
        }
    }

    public boolean equationsPossible(String[] equations) {
        // 等式方程，判断26个字母 用并查集
        // 初始化
        int[] parent = new int[26];
        for(int i=0;i<26;i++){
            parent[i] = i;
        }
        // 开始
        for(String str:equations){
            // 判断
            if(str.charAt(1)=='='){
                int index1 = str.charAt(0)-'a';
                int index2 = str.charAt(0)-'a';
                union(parent,index1,index2);
            }
        }

        for(String str:equations){
            if(str.charAt(1)=='!'){
                int index1 = str.charAt(0)-'a';
                int index2 = str.charAt(0)-'a';
                if(find(parent,index1)==find(parent,index2)){
                    return false;
                }
            }
        }
        return true;
    }

}
```

### [4.Leetcode765 情侣牵手](https://leetcode-cn.com/problems/couples-holding-hands/)

N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。

人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。

这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。

示例 1:

输入: row = [0, 2, 1, 3]
输出: 1
解释: 我们只需要交换row[1]和row[2]的位置即可。
示例 2:

输入: row = [3, 2, 0, 1]
输出: 0
解释: 无需交换座位，所有的情侣都已经可以手牵手了。

> 解题思路：并查集

```java
// 并查集
class Union{
    int count;
    int[] parent;
    // 初始化
    public Union(int n){
        count = n;
        parent = new int[n];
        // 初始化
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    // 返回
    public int getCount(){
        return count;
    }
    // 查找
    public int find(int x){
        while(x!=parent[x]){
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }
    // 合并
    public void union(int x1,int x2){
        int root1 = find(x1);
        int root2 = find(x2);
        if(root1!=root2){
            parent[root1] = root2;
            count--;
        }
    }
}

class Solution {
    public int minSwapsCouples(int[] row) {
        int len = row.length;
        int n = len/2;
        Union union = new Union(n);
        // 开始
        for(int i=0;i<len;i+=2){
            union.union(row[i]/2,row[i+1]/2);
        }
        return n-union.getCount();
    }
}
```

### [5.Leetcode839 相似字符串组](https://leetcode-cn.com/problems/similar-string-groups/)

如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。

例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。

总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。

给你一个字符串列表 strs。列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。请问 strs 中有多少个相似字符串组？

 

示例 1：

输入：strs = ["tars","rats","arts","star"]
输出：2
示例 2：

输入：strs = ["omv","ovm"]
输出：1

> 解题思路：
>
> 两个字符串相似的含义是能够通过交换两个字符的位置，得到另外一个字符串。判断两个字符串相似的时间的复杂度是 O(N)，因为把所有位置遍历一次，统计两个字符串的对应位置有多少不等即可。
>
> 明白了题意之后，做法也就呼之欲出了：把每个字符串当做图中的一个节点，如果两个字符串相似，那么它们之间就有一条边。图中的每个连通区域是一个相似字符串组。问：图中有多少个不连通的区域？
>
> 很显然，图的连通性问题可以用「并查集」去做。然后套「并查集」的模板就可以了。
>

代码思路：

两重 for 循环，实现对节点之间两两组合，判断两个节点是否相似；
判断相似的方法是：两个字符串的对应位置中只有 0 个或者 2 个不同；
如果两个字符串相似则使用并查集，将此两个节点之间连通上一条边；
统计最终并查集中有多少个不同的连通区域，即为所求。

```java
// 并查集
class UnionFind{
    int[] parent;
    int count;
    // 初始化
    public UnionFind(int n){
        count = n;
        parent = new int[n];
        for(int i=0;i<n;i++){
            parent[i] = i;
        }
    }
    public int getCount(){
        return count;
    }

    // find
    public int find(int index){
        while(parent[index]!=index){
            parent[index] = parent[parent[index]];
            index = parent[index];
        }
        return index;
    }
    public void union(int index1,int index2){
        int root1 = find(index1);
        int root2 = find(index2);
        if(root1!=root2){
            parent[root1] = root2;
            count--;
        }
    }

}
class Solution {
    public int numSimilarGroups(String[] strs) {
        int n = strs.length;
        UnionFind unionFind = new UnionFind(n);
        // 遍历并连通
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(unionFind.find(i)==unionFind.find(j)){
                    // 已连通直接跳过
                    continue;
                }
                // 判断是否相似
                if(isSimilar(strs[i],strs[j])){
                    unionFind.union(i,j);
                }
            }
        }
        return unionFind.getCount();
    }

    // 判断相似
    public boolean isSimilar(String s1,String s2){
        int n = s1.length();
        int count = 0;
        int i = 0;
        while(i<n){
            if(s1.charAt(i)!=s2.charAt(i)){
                count++;
                if(count>2){
                    return false;
                }
          }
            i++;
        }
        return true;
    }
}
```



## Trie树

### [NC124 字典树的实现](https://www.nowcoder.com/practice/a55a584bc0ca4a83a272680174be113b?tpId=117&&tqId=37818&rp=1&ru=/activity/oj&qru=/ta/job-code-high/question-ranking)

**描述**

字典树又称为前缀树或者Trie树，是处理字符串常用的数据结构。假设组成所有单词的字符仅是‘a’～‘z’，请实现字典树的结构，并包含以下四个主要的功能。void insert(String word)：添加word，可重复添加；void delete(String word)：删除word，如果word添加过多次，仅删除一次；boolean search(String word)：查询word是否在字典树中出现过(完整的出现过，前缀式不算)；int prefixNumber(String pre)：返回以字符串pre作为前缀的单词数量。现在给定一个m，表示有m次操作，每次操作都为以上四种操作之一。每次操作会给定一个整数op和一个字符串word，op代表一个操作码，如果op为1，则代表添加word，op为2则代表删除word，op为3则代表查询word是否在字典树中，op为4代表返回以word为前缀的单词数量（数据保证不会删除不存在的word）。

对于每次操作，如果op为3时，如果word在字典树中，请输出“YES”，否则输出“NO”；如果op为4时，请输出返回以word为前缀的单词数量，其它情况不输出。

**示例1**

输入：

```
[["1","qwer"],["1","qwe"],["3","qwer"],["4","q"],["2","qwer"],["3","qwer"],["4","q"]]
```

复制

返回值：

```
["YES","2","NO","1"]
```

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param operators string字符串二维数组 the ops
     * @return string字符串一维数组
     */
    public String[] trieU (String[][] operators) {
        Trie trie = new Trie();
        List<String> list = new ArrayList<String>();
        int len = operators.length;
        for(String[] each:operators){
            if(each[0].equals("1")){
                trie.insert(each[1]);
            }else if(each[0].equals("2")){
                trie.delete(each[1]);
            }else if(each[0].equals("3")){
                boolean tt = trie.search(each[1]);
                if(tt){
                    list.add("YES");
                }else{
                    list.add("NO");
                }
            }else if(each[0].equals("4")){
               list.add(String.valueOf(trie.prefixNumber(each[1])));
            }
        }
        String[] res = new String[list.size()];
        for(int i = 0;i < list.size(); i++){
            res[i] = list.get(i);
        }
        return res;
    }
    
}

class Trie{
    Trie[] child;
    int end;
    int count;
    public Trie(){
        this.end = 0;
        //java数组初始化为null，不会无限初始化
        this.child = new Trie[26];
    }
    
    public void insert(String word){
        Trie cur = this;
        for(char c: word.toCharArray()){
            if(cur.child[c-'a'] == null){
                Trie trie = new Trie();
                cur.child[c-'a'] = trie;
            }
            cur =  cur.child[c-'a'];
            cur.count++;
        }
        cur.end++;
    }
    
    public void delete(String word){
        Trie cur = this;
        for(char c: word.toCharArray()){
            if(cur.child[c-'a'] == null){
                return;
            }
            Trie temp = cur.child[c-'a'];
            if(temp.count == 1){
                cur.child[c-'a'] = null;
            }
            //使用指代寻找
            cur = temp;
            cur.count--;
        }
        cur.end--;
    }
    
    public boolean search(String word){
        Trie cur = this;
        for(char c: word.toCharArray()){
            if(cur.child[c-'a'] == null){
                return false;
            }
            cur = cur.child[c-'a'];
        }
        return cur.end != 0;
    }
    
    public int prefixNumber(String pre){
        Trie cur = this;
        for(char c: pre.toCharArray()){
            if(cur.child[c-'a'] == null){
                return 0;
            }
            cur = cur.child[c-'a'];
        }
        return cur.count;
    }
}
```

### 

