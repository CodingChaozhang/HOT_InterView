# 面试高频统计

## 面试高频Leetcode未出现的题

### TCP中的Socket和UDPSocket

#### TCP Socket编程

![image-20210820214243833](imgs\734.png)

**线程工具类**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;

public class ServerThread implements Runnable{

    Socket socket = null;
    public ServerThread(Socket socket){
        this.socket = socket;
    }
    @Override
    public void run() {
        InputStream is = null;
        InputStreamReader isr = null;
        BufferedReader br = null;
        OutputStream os = null;
        PrintWriter pw = null;
        //与客户端建立通信，获取输入流，读取客户端提供的信息
        try {
            is = socket.getInputStream();
            isr = new InputStreamReader(is,"UTF-8");
            br = new BufferedReader(isr);
            String data = null;
            while((data = br.readLine())!=null){
                System.out.println("我是服务器，客户端提交的信息为："+data);
                socket.shutdownInput();//关闭输入流

                //获取输出流，响应客户端的请求
                os = socket.getOutputStream();
                pw = new PrintWriter(os);
                pw.write("服务器端响应成功");
                pw.flush();
            }
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }finally{
            //关闭资源和相关socket
            try{
                if(pw!=null){
                    pw.close();
                }
                if(os!=null){
                    os.close();
                }
                if(is!=null){
                    is.close();
                }
                if(isr!=null){
                    isr.close();
                }
                if(br!=null){
                    br.close();
                }
                if(socket!=null){
                    socket.close();
                }
            }catch(Exception e){
                e.printStackTrace();
            }
        }
    }
}
```

**服务端**

```java
import java.io.IOException;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.Socket;

public class Server {
    public static void main(String[] args){
        //创建一个服务器端的Socket，即ServerSocket，绑定需要监听的端口
        try {
            ServerSocket serverSocket = new ServerSocket(8888);
            Socket socket = null;
            //记录连接过服务器端客户端数量
            int count = 0;
            System.out.println("服务期即将启动,等待客户端的连接");
            while(true){//循环监听新的客户端的连接
                //调用accept（）方法监听，等待客户端的连接以获取Socket实例
                socket = serverSocket.accept();
                //创建新线程
                Thread thread = new Thread(new ServerThread(socket));
                thread.start();
                count++;
                System.out.println("服务器端被连接过的次数："+count);
                
                InetAddress address = socket.getInetAddress();
                System.out.println("当前客户端IP为："+address.getHostAddress());
            }
            //服务器端的连接不用关闭。
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}
```

**客户端**

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.net.Socket;
import java.net.UnknownHostException;


public class Client1 {
    public static void main(String[] args) {
        try{
            Socket socket = new Socket("localhost",8888);
            OutputStream os = socket.getOutputStream();
            PrintWriter pw = new PrintWriter(os);
            pw.write("用户名:jinxueling;密码：123");
            pw.flush();
            socket.shutdownOutput();
            
            InputStream is = socket.getInputStream();
            InputStreamReader isr = new InputStreamReader(is,"UTF-8");
            BufferedReader br = new BufferedReader(isr);
            String data = null;
            while((data = br.readLine())!=null){
                System.out.println("我是客户端，服务器端响应的数据为："+data);
            }
              socket.close();
        }catch (UnknownHostException e) {
            e.printStackTrace();
        }catch(IOException e){
            e.printStackTrace();
        } 
    }
}
```



#### UDPSocket

![image-20210820215044060](imgs\735.png)

　　**线程工具类**

```java
package UDPSocket;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPThread implements Runnable{
    
    DatagramSocket socket = null;
    DatagramPacket packet = null;
    public UDPThread(DatagramSocket socket,DatagramPacket packet){
        this.socket = socket;
        this.packet = packet;
    }
    @Override
    public void run() {
        String info = null;
        InetAddress address = null;
        int port = 8800;
        byte[] data2 = null;
        DatagramPacket packet2 = null;
        try{
            //打印当前请求socket客户端的请求数据和信息。
            info = new String(packet.getData(),0,packet.getLength());
            System.out.println("我是服务器，客户端说："+info);
            //封装数据包，响应给当前socket实例的客户端
            address = packet.getAddress();
            port = packet.getPort();
            data2 = "我在响应你".getBytes();
            packet2 = new DatagramPacket(data2, data2.length,address,port);
            socket.send(packet2);
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

**服务端**

```java
package UDPSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketException;

public class UDPServer {
    public static void main(String[] args) throws IOException {
        try {
            //创建指定端口的DatagramSocket
            DatagramSocket socket = new DatagramSocket(8800);
            //声明数据报
            DatagramPacket packet = null;
            //声明字节数组
            byte[] data = null;
            //服务器响应的连接计数
            int count = 0;
            System.out.println("服务器启动，等待发送数据");
            //等待客户端连接
            while(true){
                //初始化字节数组容量，指定接收的数据包的大小
                data = new byte[1024];
                //初始化数据包
                packet = new DatagramPacket(data,data.length);
                //等待接收来自服务端的数据包
                socket.receive(packet);
                //到达这一步，socket.receive方法停止阻塞了，说明有客户端在请求了
                //给该客户端创建一个独立的线程，并根据接收到的包，给予响应。
                Thread thread = new Thread(new UDPThread(socket,packet));
                thread.start();
                count++;
                System.out.println("服务器端被连接过的次数："+count);
                //打印当前的客户端socket的ip
                InetAddress address = packet.getAddress();
                System.out.println("当前客户端的IP为："+address.getHostAddress());
            }
        } catch (SocketException e) {
            e.printStackTrace();
        }
    }
}
```

　　**客户端**

```java
package UDPSocket;

import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;

public class UDPClient {
    public static void main(String[] args) throws IOException {
        //定义服务器的地址，端口号，数据
        InetAddress address = InetAddress.getByName("localhost");
        int port = 8800;
        byte[] data = "用户名：admin；密码：123".getBytes();
        //创建数据报
        DatagramPacket packet = new DatagramPacket(data,data.length,address,port);
        //创建DatagramSocket，实现数据发送和接收
        DatagramSocket socket = new DatagramSocket();
        //向服务器发送数据报
        socket.send(packet);
        
        //接收服务器 响应数据
        byte[] data2 = new byte[1024];
        DatagramPacket packet2 = new DatagramPacket(data2,data2.length);
        socket.receive(packet2);
        String info = new String(data2,0,packet2.getLength());
        System.out.println("我是客户端，服务器说："+info);
        socket.close();
    }
}
```

　　所以，一个服务端端口是能建立多个连接的，因为每个连接中clientPort都是不同的，在进行通信时，操作系统接收到向serverPort发来的数据时，会在该端口产生的连接中查找到符合这个唯一标识并传递信息到对应的缓冲区。

#### 1.**为什么服务端需要产生两个socket(listen_socket_fd和connect_socket_fd)**

　　答：监听socket是服务器作为客户端连接请求的一个对端，只需创建一次即可，它存在于服务器的整个生命周期，可为成千上万的客户端服务，而一旦一个客户端和服务器连接成功，完成了TCP三次握手，操作系统内核就为这个客户端生成一个已连接套接字（connect_socket_fd），让应用服务器使用这个connect_socket_fd和客户端进行通信，如果应用服务器完成了对这个客户端的服务，那么关闭的就是已连接套接字，这样就完成了TCP连接的释放。请注意，这个时候释放的只是这一个客户端连接，其它被服务的客户端连接可能还存在。最重要的是，监听套接字一直都处于“监听”状态，等待新的客户请求到达并服务。若只使用一个listen_socket_fd完成从创建监听到被请求连接，处理请求，关闭socket的整个过程，那么这个socket就会一直被占用，而不能被其它的客户端请求，造成服务端性能低下。使用两个socket，按职责分工，listen_socket_fd专门负责响应客户端的请求，每个新的connect_socket_fd专门负责该次连接的数据交互，分层协作，提高服务端的性能。

#### 1.端口号的作用

端口号可以用来标识同一个主机上通信的不同应用程序，端口号+IP地址就可以组成一个套接字，用来标识一个进程。

#### 1.端口号的应用场景

在TCP/IP协议中，用“源IP地址”，“目的IP地址”，“源端口号”，“目的端口号”,协议号（IP协议的协议号为4，TCP的协议号为6）这样的一个五元组来标识一个通信，通信的双方在发送消息时，消息的头部会带着这样的五元组。

#### 2.一个进程是否可以bind多个端口号？可以

因为一个进程可以打开多个文件描述符，而每个文件描述符都对应一个端口号，所以一个进程可以绑定多个端口号。

Linux内核会给每一个socket分配一个唯一的文件描述符，进程通过该文件描述符来区分对应的套接字。

#### 3.**一个端口号是否可以被多个进程绑定？**

同种协议通常不可以，但有一种情况可以。

ps：如果进程先绑定一个端口号，然后在fork一个子进程，这样的话就可以是实现多个进程绑定一个端口号，但是两个不同的进程绑定同一个端口号是不可以的。

#### 4.一台服务器上最多能连接的连接数

>  经常听到有同学说一台机器最多能创建65535个TCP连接，这其实是错误的理解，为什么会有这个错误的理解呢？

**port range**

我们都知道linux下本地随机端口范围由参数控制

```text
# cat /proc/sys/net/ipv4/ip_local_port_range 
10000   65535
```

port range的上限是65535，所以也经常看到这个**误解**：一台机器上最多能创建65535个TCP连接

**到底一台机器上最多能创建多少个TCP连接**

先说**结论**：在内存、文件句柄足够的话可以创建的连接是没有限制的（每个TCP连接至少要消耗一个文件句柄）。

那么/proc/sys/net/ipv4/ip_local_port_range指定的端口范围到底是什么意思呢？

核心规则：**一个TCP连接只要保证四元组(src-ip src-port dest-ip dest-port)唯一就可以了，而不是要求src port唯一**

后面所讲都遵循这个规则，所以在心里反复默念：**四元组唯一** 五个大字，就能分析出来到底能创建多少TCP连接了。

比如如下这个机器上的TCP连接实际状态：

比如如下这个机器上的TCP连接实际状态：

```text
# netstat -ant |grep 18089
tcp        0      0 192.168.1.79:18089      192.168.1.79:22         ESTABLISHED
tcp        0      0 192.168.1.79:18089      192.168.1.79:18080      ESTABLISHED
tcp        0      0 192.168.0.79:18089      192.168.0.79:22         TIME_WAIT 
tcp        0      0 192.168.1.79:22         192.168.1.79:18089      ESTABLISHED
tcp        0      0 192.168.1.79:18080      192.168.1.79:18089      ESTABLISHED
```

从前三行可以清楚地看到18089被用了三次，第一第二行src-ip、dest-ip也是重复的，但是dest port不一样，第三行的src-port还是18089，但是src-ip变了。他们的四元组均不相同。

所以一台机器能创建的TCP连接是没有限制的，而ip_local_port_range是指没有bind的时候OS随机分配端口的范围，但是分配到的端口要同时满足五元组唯一，这样 ip_local_port_range 限制的是连同一个目标（dest-ip和dest-port一样）的port的数量（请忽略本地多网卡的情况，因为dest-ip为以后route只会选用一个本地ip）。

我们在创建连接前，经常会先调bind，bind后可以调listen当做服务端监听，也可以直接调connect当做client来连服务端。

bind(ip,port=0) 的时候是让系统绑定到某个网卡和自动分配的端口，此时系统没有办法确定接下来这个socket是要去connect还是listen. **如果是listen的话，那么肯定是不能出现端口冲突的，如果是connect的话，只要满足4元组唯一即可。**在这种情况下，系统只能尽可能满足更强的要求，就是先要求端口不能冲突，即使之后去connect的时候四元组是唯一的。

**但如果我只是个client端，只需要连接server建立连接，也就不需要bind，直接调connect就可以了，这个时候只要保证四元组唯一就行。**

**bind()的时候内核是还不知道四元组的，只知道src_ip、src_port，所以这个时候单网卡下src_port是没法重复的，但是connect()的时候已经知道了四元组的全部信息，所以只要保证四元组唯一就可以了**，那么这里的src_port完全是可以重复使用的。

**是不是加上了 SO_REUSEADDR、SO_REUSEPORT 就能重用端口了呢？**

#### 5.如果是listen的话，那么肯定是不能出现端口冲突的，如果是connect的话，只要满足4元组唯一即可。

#### 6.结论

- 在内存、文件句柄足够的话一台服务器上可以创建的TCP连接数量是没有限制的
- SO_REUSEADDR 主要用于快速重用 TIME_WAIT状态的TCP端口，避免服务重启就会抛出Address Already in use的错误
- SO_REUSEPORT主要用来解决惊群、性能等问题
- local port的选择是递增搜索的，搜索起始port随时间增加也变大

#### 7.惊群现象

> 惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。

#### 8.TIME_WAIT状态产生的原因

**1）为实现TCP全双工连接的可靠释放**

由TCP状态变迁图可知，假设发起主动关闭的一方（client）最后发送的ACK在网络中丢失，由于TCP协议的重传机制，执行被动关闭的一方（server）将会重发其FIN，在该FIN到达client之前，client必须维护这条连接状态，也就说这条TCP连接所对应的资源（client方的local_ip,local_port）不能被立即释放或重新分配，直到另一方重发的FIN达到之后，client重发ACK后，经过2MSL时间周期没有再收到另一方的FIN之后，该TCP连接才能恢复初始的CLOSED状态。如果主动关闭一方不维护这样一个TIME_WAIT状态，那么当被动关闭一方重发的FIN到达时，主动关闭一方的TCP传输层会用RST包响应对方，这会被对方认为是有错误发生，然而这事实上只是正常的关闭连接过程，并非异常。

**2）为使旧的数据包在网络因过期而消失**

为说明这个问题，我们先假设TCP协议中不存在TIME_WAIT状态的限制，再假设当前有一条TCP连接：(local_ip, local_port, remote_ip,remote_port)，因某些原因，我们先关闭，接着很快以相同的四元组建立一条新连接。本文前面介绍过，TCP连接由四元组唯一标识，因此，在我们假设的情况中，TCP协议栈是无法区分前后两条TCP连接的不同的，在它看来，这根本就是同一条连接，中间先释放再建立的过程对其来说是“感知”不到的。这样就可能发生这样的情况：前一条TCP连接由local peer发送的数据到达remote peer后，会被该remot peer的TCP传输层当做当前TCP连接的正常数据接收并向上传递至应用层（而事实上，在我们假设的场景下，这些旧数据到达remote peer前，旧连接已断开且一条由相同四元组构成的新TCP连接已建立，因此，这些旧数据是不应该被向上传递至应用层的），从而引起数据错乱进而导致各种无法预知的诡异现象。作为一种可靠的传输协议，TCP必须在协议层面考虑并避免这种情况的发生，这正是TIME_WAIT状态存在的第2个原因。

#### 9.TIME_WAIT状态如何避免

首先服务器可以设置SO_REUSEADDR套接字选项来通知内核，如果端口忙，但TCP连接位于TIME_WAIT状态时可以重用端口。在一个非常有用的场景就是，**如果你的服务器程序停止后想立即重启，而新的套接字依旧希望使用同一端口，此时SO_REUSEADDR选项就可以避免TIME_WAIT状态**。

#### 10.TIME_WAIT状态的危害

- 大量 time_wait 状态存在，会导致新建 TCP 连接会出错，address already in use : connect 异常

### 常见的编码方式



讲一下常见编码方式？ 编码的意义：计算机中存储的最小单元是一个字节即8bit，所能表示的字符范围是255个， 而人类要表示的符号太多，无法用一个字节来完全表示，固需要将符号编码，将各种语言翻 译成计算机能懂的语言。

### 水平触发和边缘触发的优缺点

epoll模式下的水平触发、边沿触发。

水平触发通俗来讲：只要有数据，epoll_wait函数就一直返回；边沿触发通俗来讲：只有socket状态发生变化，epoll_wait函数才会返回。

**水平触发优、缺点及应用场景：**

优点：当进行socket通信的时候，保证了数据的完整输出，进行IO操作的时候，如果还有数据，就会一直的通知你。

缺点：由于只要还有数据，内核就会不停的从内核空间转到用户空间，所有占用了大量内核资源，试想一下当有大量数据到来的时候，每次读取一个字节，这样就会不停的进行切换。内核资源的浪费严重。效率来讲也是很低的。

边沿触发优、缺点及应用场景：

优点：每次内核只会通知一次，大大减少了内核资源的浪费，提高效率。

缺点：不能保证数据的完整。不能及时的取出所有的数据。

应用场景：处理大数据。使用non-block模式的socket。



 **边缘触发:**只有电平发生变化(高电平到低电平,或者低电平到高电平)的时候才触发通知.上面提到即使有数据可读,但是io状态没有变化epoll也不会立即返回.

### mysql,nginx,tomcat redis的多进程多线程

多进程单线程模型典型代表：**nginx**

**nginx采用多进程模式：**

对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。

其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，**master进程则很快启动新的worker进程。**

当然，worker进程的异常退出，肯定是程序有bug了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。

**nginx多进程事件模型：异步非阻塞**

虽然nginx采用多worker的方式来处理请求，每个worker里面只有一个主线程，但是nginx采用了异步非阻塞的方式来处理请求，也就是说，nginx是可以同时处理成千上万个请求的。

一个worker进程可以同时处理的请求数只受限于内存大小，而且在架构设计上，不同的worker进程之间处理并发请求时几乎没有同步锁的限制，worker进程通常不会进入睡眠状态。

因此，**当Nginx上的进程数与CPU核心数相等时（最好每一个worker进程都绑定特定的CPU核心），进程间切换的代价是最小的。**



而**apache的常用工作方式**（apache也有异步非阻塞版本，但因其与自带某些模块冲突，所以不常用），**每个进程在一个时刻只处理一个请求。**

因此，当并发数上到几千时，就同时有几千的进程在处理请求了。这对操作系统来说，是个不小的挑战，进程带来的内存占用非常大，进程的上下文切换带来的cpu开销很大，自然性能就上不去了，而这些开销完全是没有意义的。



apache是同步多进程模型，一个连接对应一个进程；而nginx是异步的，多个连接对应一个进程。

Nginx比较Apache：**事件驱动适合于IO密集型服务**，**多进程或线程适合于CPU密集型服务**



**Nginx与Apache对于高并发处理上的区别。**
    回答3：对于Apache，每个请求都会独占一个工作线程，当并发数到达几千时，就同时有几千的线程在处理请求了。这对于操作系统来说，占用的内存非常大，线程的上下文切换带来的cpu开销也很大，性能就难以上去，同时这些开销是完全没有意义的。

   对于Nginx来讲，一个进程只有一个主线程，通过异步非阻塞的事件处理机制，实现了循环处理多个准备好的事件，从而实现轻量级和高并发。



**Mysql是的单进程多线程的数据库，而oracle使用多进程**

传统的unix系统，早期没有提供多线程，只有多进程。linux是最近的版本才加入多线程支持，以前一直都是多进程。windows很早就支持多线程，本地应用大部分也是多线程。因此**oracle在windows上一直都是多线程，在unix上才是多进程。**

多进程的好处是，**一个进程崩溃不会影响其他进程**，多线程的好处是不需要__共享内存__这样的手段来访问数据库缓冲区




- Nginx优点：负载均衡、反向代理、处理静态文件优势。nginx处理静态请求的速度高于apache；
-  Apache优点：相对于Tomcat服务器来说处理静态文件是它的优势，速度快。Apache是静态解析，适合静态HTML、图片等。
- Tomcat：动态解析容器，处理动态请求，是编译JSP\Servlet的容器，Nginx有动态分离机制，静态请求直接就可以通过Nginx处理，动态请求才转发请求到后台交由Tomcat进行处理。



### HashMap遍历的问题

- KeySet：通过keySet()方法获取一个KeySet集合，这个类里封装的是map的key。
- Values：通过values()方法获取Values集合，这个类里封装的是map的值。
- EntrySet()：通过entrySet()获取EnterSet集合，这个类里封装的是map的键值对。

```java
public static void main(String[] args) {
		HashMap<Integer,Integer> dict = new HashMap<>();
		dict.put(1, 1);
		dict.put(2, 2);
		dict.put(3,3);
		//遍历的方式一
		for(Map.Entry<Integer, Integer> map:dict.entrySet()) {
			int key = map.getKey();
			int value = map.getValue();
			System.out.println("key:"+key+"value:"+value);
		}
		//遍历的方式二
		Iterator it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map = (Entry<Integer, Integer>) it.next();
			System.out.println("key:"+map.getKey());
			System.out.println("value:"+map.getValue());
		}
	}
```

**数组的遍历**

```java
//对数组的遍历
		List<Integer> list = new ArrayList<>();
		list.add(4);
		list.add(5);
		Iterator it_list = list.iterator();
		while(it_list.hasNext()) {
			Integer key = (Integer) it_list.next();
			System.out.println("key:"+key);
 		}
```

### HashMap,ArrayList删除的问题

**错误的删除**

```java
//对数组的遍历
		List<Integer> list = new ArrayList<>();
		list.add(3);
		list.add(4);
		list.add(4);
		list.add(5);
		Iterator it_list = list.iterator();
		while(it_list.hasNext()) {
			Integer key = (Integer) it_list.next();
			if(key==4) {
				list.remove(key);
			}
 		}
```

Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)
	at java.util.ArrayList$Itr.next(ArrayList.java:859)
	at com.lcz.security.Test11.main(Test11.java:32)



**正确的删除**

```java
List<Integer> list = new ArrayList<>();
list.add(3);
list.add(4);
list.add(4);
list.add(5);
Iterator it_list = list.iterator();
while(it_list.hasNext()) {
    Integer key = (Integer) it_list.next();
    if(key==4) {
        it_list.remove();
    }
}
```



**错误做法**

```java
		//遍历的方式二
		Iterator it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map = (Entry<Integer, Integer>) it.next();
			if(map.getValue()==3) {
				dict.remove(map.getKey());
			}
		}
```

Exception in thread "main" java.util.ConcurrentModificationException
	at java.util.HashMap$HashIterator.nextNode(HashMap.java:1445)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1479)
	at java.util.HashMap$EntryIterator.next(HashMap.java:1477)
	at com.lcz.security.Test11.main(Test11.java:20)

**正确做法**

```java
HashMap<Integer,Integer> dict = new HashMap<>();
		dict.put(1, 1);
		dict.put(2, 3);
		dict.put(3, 3);

		//遍历的方式二
		Iterator<Map.Entry<Integer, Integer>> it = dict.entrySet().iterator();
		while(it.hasNext()) {
			Map.Entry<Integer, Integer> map =  it.next();
			if(map.getValue()==3) {
				it.remove();
			}
		}
```



更加简洁的做法

```java

Map<String, Integer> map = new HashMap<>();
map.put("a", 1);
map.put("b", 2);
map.put("c", 3);
map.put("d", 4);
map.entrySet().removeIf(entry -> entry.getValue() % 2 == 0);
```



### Leetcode66 加一

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

 

示例 1：

输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。

```java
class Solution {
    public int[] plusOne(int[] digits) {
           // 为防止超出界限
	    	int flag = 1;
	    	for(int i=digits.length-1;i>=0;i--) {
	    		if(digits[i]+flag>=10) {
	    			digits[i] = 0;
	    			flag = 1;
	    		}else {
	    			digits[i]  = digits[i] + flag;
	    			flag = 0;
	    		}
	    	}
	    	// 查看此时的flag
	    	if(flag!=0) {
	    		// 还有余数
	    		int[] new_digits = new int[digits.length+1];
	    		new_digits[0]    = 1;
	    		return new_digits;
	    	}else {
	    		return digits;
	    	}
    }
}
```



### 两个有序数组的topK问题





给定两个有序数组arr1和arr2，再给定一个整数k，返回来自arr1和arr2的两个数相加和最大的前k个，两个数必须分别来自两个数组 

  按照降序输出 

  [要求] 

  时间复杂度为O(klog⁡k)O(k \log k)O(klogk)  

**输入描述:**

```
第一行三个整数N, K分别表示数组arr1, arr2的大小，以及需要询问的数
接下来一行N个整数，表示arr1内的元素
再接下来一行N个整数，表示arr2内的元素
```

**输出描述:**

```
输出K个整数表示答案
```

示例1

**输入**

```
5 4
1 2 3 4 5
3 5 7 9 11
```

**输出**

```
16 15 14 14
```

```java
import java.util.*;
public class Main {
    //放入大根堆中的结构
    static class Node {
        public int index1;  //arr1中的位置
        public int index2;  //arr2中的位置
        public int sum;     //arr1[index1]+arr2[index2]
        public Node(int i1, int i2, int s) {
            index1 = i1;
            index2 = i2;
            sum = s;
        }
    }

    public static int[] topKSum(Integer[] arr1, Integer[] arr2, int topK) {
        if (arr1 == null || arr2 == null || topK < 1) {
            return null;
        }
        topK = Math.min(topK, arr1.length * arr2.length);
        int[] res = new int[topK];
        int resIndex = 0;
        //自定义比较器，实现大根堆
        PriorityQueue<Node> maxHeap = new PriorityQueue<>((N1, N2) -> N2.sum - N1.sum);
        // set[i][j] == false , arr1[i] arr2[j] 之前没进过堆
        // set[i][j] == true , arr1[i] arr2[j] 之前进过堆
        //boolean[][] set = new boolean[arr1.length][arr2.length];
        //使用hashset解决超内存问题
        HashSet<String> positionSet = new HashSet<>();
        //从右下角开始
        int i1 = arr1.length - 1;
        int i2 = arr2.length - 1;
        maxHeap.add(new Node(i1, i2, arr1[i1] + arr2[i2]));
        //set[i1][i2] = true;
        positionSet.add(i1 + "_" + i2);
        while (resIndex != topK) {
            Node curNode = maxHeap.poll();
            res[resIndex++] = curNode.sum;
            i1 = curNode.index1;
            i2 = curNode.index2;
//            if (i1 - 1 >= 0 && set[i1 - 1][i2] == false) {
//                set[i1 - 1][i2] = true;
//                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
//            }
//            if (i2 - 1 >= 0 && set[i1][i2 - 1] == false) {
//                set[i1][i2 - 1] = true;
//                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
//            }
            if (i1 - 1 >= 0 && !positionSet.contains(i1 - 1 + "_" + i2)) {
                positionSet.add(i1 - 1 + "_" + i2);
                maxHeap.add(new Node(i1 - 1, i2, arr1[i1 - 1] + arr2[i2]));
            }
            if (i2 - 1 >= 0 && !positionSet.contains(i1 + "_" + (i2 - 1))) {
                positionSet.add(i1 + "_" + (i2 - 1));
                maxHeap.add(new Node(i1, i2 - 1, arr1[i1] + arr2[i2 - 1]));
            }
        }
        return res;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n = in.nextInt();
        int k = in.nextInt();
        Integer[] arr1 = new Integer[n];
        Integer[] arr2 = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr1[i] = in.nextInt();
        }
        for (int i = 0; i < n; i++) {
            arr2[i] = in.nextInt();
        }
        //要将输入的两个数字排序
        Arrays.sort(arr1);
        Arrays.sort(arr2);
        int[] res = topKSum(arr1, arr2, k);
        for (int re : res) {
            System.out.print(re + " ");
        }
    }
}
```



### 基于用户登录日志计算任一时间在线人数

给定一些用户登录的日志，计算任意时间的在线人数。其中用户登录日志包括如下信息：

```java
type LoginLog struct {
    userId     int
    loginTime  int
    logoutTime int
}
```

根据题目，一天24小时，我们有一堆的用户登录日志。简单的做法是我们遍历获取日志，然后对于用户在线的这段时间，对每一个时间点对在线人数加一。则程序如下：

```Go
func calOnlineUserCount(logList []*LoginLog) map[int]int {
    var timeToOnlineUserCountMap = make(map[int]int)
    for _, log := range logList {
        for i := log.loginTime; i <= log.logoutTime; i++ {
            timeToOnlineUserCountMap[i]++
        }
    }
    return timeToOnlineUserCountMap 
}
```

可以知道，这种方法的时间复杂度为O(kn)。在面试的时候面试官会希望给出O(n)事件复杂度的解法。



简单考虑一下，如果我们知道k时间的在线人数，我们很容易知道k+1时间的在线认识：

**k+1时刻的在线人数** = **k时刻在线人数** + **k+1时刻上线人数 - k+1时刻下线人数**

```js
func calOnlineUserCount(logList []*LoginLog) map[int]int {
	var timeToOnlineUserCountMap = make(map[int]int)
	var timeToLoginUserCountMap = make(map[int]int)
	var timeToLogoutUserCountMap = make(map[int]int)
	for _, log := range logList {
		timeToLoginUserCountMap[log.loginTime]++
		timeToLogoutUserCountMap[log.logoutTime]++
	}
	var startTime int // 根据统计时间
	var endTime int // 根据统计时间
	for i := startTime; i <= endTime; i++ {
		timeToOnlineUserCountMap[i] = max(timeToOnlineUserCountMap[i-1] +  timeToLoginUserCountMap[i] - timeToLogoutUserCountMap[i], 0)
	}
	return timeToOnlineUserCountMap
}
```



### 中文数字转阿拉伯数字

中文数字格式：一万三千五百四十一     

​      阿拉伯数字格式：13541     

​      中文数字中要分     单位     和     数字     分别处理，可以用两个数组分别保存中文数字和中文单位，每次循环扫描给的中文数字，去匹配对应的数字。中文数字数字可以用数组下标对应数字。

```java
public class Solution{
   static char[] cnArr = {'零','一', '二', '三', '四', '五', '六', '七', '八', '九'};
   static char[] chArr = {'十', '百', '千', '万', '亿'};
public static int chineseNumToArabicNum(String chineseNum) {
    int result = 0;
    int temp = 1;//存放一个单位的数字如：十万
    int count = 0;//判断是否有表示单位的文字
    for (int i = 0; i < chineseNum.length(); i++) {
        boolean b = true;//判断是否是单位
        char c = chineseNum.charAt(i);
        for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
            if (c == cnArr[j]) {
                if (count != 0) {//添加下一个单位之前，先把上一个单位值添加到结果中
                    result += temp;
                    temp = 1;
                    count = 0;
                }
                // 下标+1，就是对应的值
                temp = j;
                b = false;
                break;
            }
        }
        if (b) {//单位{'十','百','千','万','亿'}
            for (int j = 0; j < chArr.length; j++) {
                if (c == chArr[j]) {
                    switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                    }
                    count++;
                }
            }
        }
        if (i == chineseNum.length() - 1) {//遍历到最后一个字符
            result += temp;
        }
    }
    return result;
}
}
```

```java
package cn.utstarcom.idpvoice.util;
 
/**
 * 工具类，用于将汉语的数字转换为阿拉伯数字
 * @author utsc1243
 * @date 2019年6月12日
 */
public class ChineseNumToArabicNumUtil {
	static char[] cnArr = new char [] {'一','二','三','四','五','六','七','八','九'};
	static char[] chArr = new char [] {'十','百','千','万','亿'};
	static String allChineseNum = "零一二三四五六七八九十百千万亿";
	
	/**
	 * 将汉字中的数字转换为阿拉伯数字
	 * @param chineseNum
	 * @return
	 */
	public static int chineseNumToArabicNum(String chineseNum) {
        int result = 0;
        int temp = 1;//存放一个单位的数字如：十万
        int count = 0;//判断是否有chArr
        for (int i = 0; i < chineseNum.length(); i++) {
            boolean b = true;//判断是否是chArr
            char c = chineseNum.charAt(i);
            for (int j = 0; j < cnArr.length; j++) {//非单位，即数字
                if (c == cnArr[j]) {
                    if(0 != count){//添加下一个单位之前，先把上一个单位值添加到结果中
                        result += temp;
                        temp = 1;
                        count = 0;
                    }
                    // 下标+1，就是对应的值
                    temp = j + 1;
                    b = false;
                    break;
                }
            }
            if(b){//单位{'十','百','千','万','亿'}
                for (int j = 0; j < chArr.length; j++) {
                    if (c == chArr[j]) {
                        switch (j) {
                        case 0:
                            temp *= 10;
                            break;
                        case 1:
                            temp *= 100;
                            break;
                        case 2:
                            temp *= 1000;
                            break;
                        case 3:
                            temp *= 10000;
                            break;
                        case 4:
                            temp *= 100000000;
                            break;
                        default:
                            break;
                        }
                        count++;
                    }
                }
            }
            if (i == chineseNum.length() - 1) {//遍历到最后一个字符
                result += temp;
            }
        }
        return result;
	}
	
	/**
	 * 将数字转换为中文数字， 这里只写到了万
	 * @param intInput
	 * @return
	 */
	public static String arabicNumToChineseNum(int intInput) {
		String si = String.valueOf(intInput);
		String sd = "";
		if (si.length() == 1) {
			if (intInput == 0) {
				return sd;
			}
			sd += cnArr[intInput - 1];
			return sd;
		} else if (si.length() == 2) {
			if (si.substring(0, 1).equals("1")) {
				sd += "十";
				if (intInput % 10 == 0) {
					return sd;
				}
			}
			else
				sd += (cnArr[intInput / 10 - 1] + "十");
			sd += arabicNumToChineseNum(intInput % 10);
		} else if (si.length() == 3) {
			sd += (cnArr[intInput / 100 - 1] + "百");
			if (String.valueOf(intInput % 100).length() < 2) {
				if (intInput % 100 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 100);
		} else if (si.length() == 4) {
			sd += (cnArr[intInput / 1000 - 1] + "千");
			if (String.valueOf(intInput % 1000).length() < 3) {
				if (intInput % 1000 == 0) {
					return sd;
				}			
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 1000);
		} else if (si.length() == 5) {
			sd += (cnArr[intInput / 10000 - 1] + "万");
			if (String.valueOf(intInput % 10000).length() < 4) {
				if (intInput % 10000 == 0) {
					return sd;
				}
				sd += "零";
			}
			sd += arabicNumToChineseNum(intInput % 10000);
		}
 
		return sd;
	}
 
	/**
	 * 判断传入的字符串是否全是汉字数字
	 * @param chineseStr
	 * @return
	 */
	public static boolean isChineseNum(String chineseStr) {
		char [] ch = chineseStr.toCharArray();
		for (char c : ch) {
			if (!allChineseNum.contains(String.valueOf(c))) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * 判断数字字符串是否是整数字符串
	 * @param str
	 * @return
	 */
	public static boolean isNum(String str) {
		String reg = "[0-9]+";
		return str.matches(reg);
	}
	
	public static void main(String[] args) {
		System.out.println(arabicNumToChineseNum(39999));
	}
}
```



### 0.检测循环依赖（类似于课程表）

[['A', 'B'], ['B', 'C'], ['C', 'D'], ['B', 'D']] => false，[['A', 'B'], ['B', 'C'], ['C', 'A']] => true

**题目描述：**

现有n个编译项，编号为0 ~ n-1。给定一个二维数组，表示编译项之间有依赖关系。如[0, 1]表示1依赖于0。

若存在循环依赖则返回空；不存在依赖则返回可行的编译顺序。

**题目分析：**

若给定一个依赖关系是[[0,2],[1,2],[2,3],[2,4]]，如图所示

![图片](https://mmbiz.qpic.cn/mmbiz_png/oD5ruyVxxVHOSu5k160b070ZdrAMyjL3by5C0ju2jsLq9VlxOmDXArYaYSoP6LC0WqP9VUaAfONbICrlV8Y9vQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

可以看出，它们之间不存在循环依赖。

可行的编译序列是[0,1,2,3,4]，也可以是[1,0,2,4,3]等。

拓扑排序可以求这样的一个序列。可以看出，这个序列结果可能不唯一。

> > 拓扑排序算法过程：
> >
> > 1. 选择图中一个入度为0的点，记录下来
> > 2. 在图中删除该点和所有以它为起点的边
> > 3. 重复1和2，直到图为空或没有入度为0的点。

```java
vector<int> haveCircularDependency(int n, vector<vector<int>> &prerequisites) {
    vector<vector<int>> g(n); //邻接表存储图结构
    vector<int> indeg(n); //每个点的入度
    vector<int> res; //存储结果序列
    for(int i = 0; i < prerequisites.size(); i ++) {
        int a = prerequisites[i][0], b = prerequisites[i][1]; 
        g[a].push_back(b);
        indeg[b] ++;
    }
    queue<int> q;
    //一次性将入度为0的点全部入队
    for(int i = 0; i < n; i ++) {
        if(indeg[i] == 0) q.push(i);
    }
    while(q.size()) {
        int t = q.front();
        q.pop();
        res.push_back(t);
        //删除边时，将终点的入度-1。若入度为0，果断入队
        for(int i = 0; i < g[t].size(); i ++) {
            int j = g[t][i];
            indeg[j] --;
            if(indeg[j] == 0) {
                q.push(j);
            }
        }
    }
    if(res.size() == n) return res;
    else return {};
}
```



### 6.最小生成树-NC159最小生成树(Kruskal算法)

**描述**

一个有n户人家的村庄，有m条路连接着。村里现在要修路，每条路都有一个代价，现在请你帮忙计算下，最少需要花费多少的代价，就能让这n户人家连接起来。

**示例1**

输入：

```
3,3,[[1,3,3],[1,2,1],[2,3,1]]
```

复制

返回值：

```
2
```

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost int二维数组 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    public int miniSpanningTree (int n, int m, int[][] cost) {
        // write code here
        int[] parent = new int[n+1];
        for(int i=0;i<parent.length;i++){
            parent[i] = i;
        }
        //优先级队列
        PriorityQueue<Node> queue = new PriorityQueue<>((a,b)->(a.cost-b.cost));
        for(int[] c:cost){
            queue.offer(new Node(c[1],c[0],c[2]));
        }
        int res = 0;
        while(!queue.isEmpty()){
            Node cur = queue.poll();
            if(find(parent,cur.start)!=find(parent,cur.end)){
                res += cur.cost;
                union(parent,cur.start,cur.end);
            }
        }
        return res;
    }
    // 结点
    static class Node{
        int start;
        int end;
        int cost;
        public Node(int s,int e,int c){
            this.start = s;
            this.end = e;
            this.cost = c;
        }
    }
    
     public int find(int[] parent,int node){
           while(node!=parent[node]){
               parent[node] = parent[parent[node]];
               node = parent[node];
           }
           return node;
        }
        public void union(int[] parent,int node1,int node2){
            int p1 = find(parent,node1);
            int p2 = find(parent,node2);
            parent[p1] = p2;
        }
}
```

### 7.KMP算法

**描述**

给你一个非空模板串S，一个文本串T，问S在T中出现了多少次

**示例1**

输入：

```
"ababab","abababab"
```

复制

返回值：

```
2
```

复制

**示例2**

输入：

```
"abab","abacabab"
```

复制

返回值：

```
1
```

对原生kmp做个改造

主要两点：

1. next数组多算一格
2. kmp匹配时，如果完全匹配上，则ans计数+1， 并让模式串移动到next[ti]位置

```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 计算模板串S在文本串T中出现了多少次
     * @param S string字符串 模板串
     * @param T string字符串 文本串
     * @return int整型
     */
     public int kmp (String S, String T) {
        // write code here
        int[] next = getNext(S);
        char[] str =T.toCharArray();
        char[] t = S.toCharArray();
        int si =0;
        int ti =0;

        int ans =0;
        while(si < str.length){
            if(ti==-1 || str[si] == t[ti]){
                si++;
                ti++;
            }else{
                ti = next[ti];
            }
            if(ti == t.length){  //改造2
                ans++;
                ti=next[ti];
            }
        }
        return ans;
    }

    public int[] getNext(String S){
        char[] str= S.toCharArray();
        int[] next=  new int[str.length+1]; //改造1
        next[0]=-1;
        next[1] = 0;
        int cur=2;
        int x = next[cur-1];
        while(cur<=str.length){
            if(x==-1 || str[cur-1]==str[x]){
                next[cur++] = ++x;
            }else{
                x=next[x];
            }
        }
        return next;
    }
}
```



### [3.排列11223344的问题](https://leetcode-cn.com/circle/discuss/aHLvHV/)

有8个数，11223344
将其排列，要求结果满足：两个1之间有一个数，两个2之间有两个数，两个3之间有三个数，**两个4之间有四个数。**问这个结果是多少？

答案：41312432 或 23421314

可以想到，先填 4 比较好，因为填 4 可能的方案最少。

如图所示，在最终答案中，4 的位置一定是以下三种方案之一。

![image.png](imgs\470.png)

由于方案 1 和方案 3 只是顺序不同，因此我们可以只考虑方案1，如果最后以方案1为开始找到了答案，逆序一下便是方案3能找到的答案。

因此，我们只需考虑方案 1 和方案 2 。

同理，按照上面的思路，再填 3 ，再填 2 ，最后填 1 。

最终便可搜索到答案。

下图是以方案 1 开始搜索的所有可能方案，最终得到结果41312432；将其逆序得到的23421314，依然满足结果。

![image-20210715231532644](imgs\471.png)

大家可以在纸上写一下，看看和我图中的一不一致。

由方案 2 开始搜索无法得到满足条件的序列，因此不再画图分析。

### 5.灯泡开关

一个圆环上有 100 个灯泡，灯泡有亮和暗两种状态。按一个灯泡的开关可以改变它和与它相邻两个灯泡的状态。
设计一种算法，对于任意初始状态，使所有灯泡全亮。

将灯泡编号 1 ~ 100

**步骤一：将灯泡变为全亮或只剩一个为暗**

从 1 循环到 98 ，**遇到暗**的则按它下一个，使之变亮。循环完毕，1 ~ 98 必然全亮。**99 和 100可能为亮亮、暗亮、亮暗、暗暗四种状态。**

若为亮亮，皆大欢喜，满足题目要求
**暗亮、亮暗，达到只剩一个为暗的状态**；
若为**暗暗**。则按下编号 100 的灯泡，使编号 99 、100 变为亮，**编号 1 的灯泡变为暗，从而达到只剩一个为暗的状态。**

**步骤二：将灯泡变为全暗**

由于灯泡环形摆放，我们指定暗的灯泡编号为 1 ，将剩下 99 个亮着的灯泡每 3 个为一组。按下每组中间的灯泡后，使得所有灯泡变为暗。

**步骤三：将灯泡变为全亮**

将所有灯泡按一下，灯泡变为全亮。



对于 N 个灯泡的任意初始状态 ( N > 3 ) ，能否经过若干次操作使得所有灯泡全亮？

答案：N 个灯泡做分类讨论。

N = 3*k+1一定可以。方法与上述步骤相同，在步骤二中可以将3k个亮的灯泡分为k组。
N = 3*k+2一定可以。将上述步骤一目标状态的只剩一个为暗改成剩两个相邻为暗，其余 3 * k 个灯泡分组按即可。因为，对于任意只剩一个为暗的状态，按下该灯泡左右任意一个就可以变成剩两个相邻为暗的状态！
N = 3*k不一定。如果经过上述步骤一可以将灯泡变成全亮的状态则有解；否则，无解。（该结论有待证明）



### [12.圆环会原点问题](https://leetcode-cn.com/circle/discuss/TWO4Z5/)

圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

输入: 2
输出: 2
解释：有2种方案。分别是0->1->0和0->9->0

**题目分析：**

本题考察的是动态规划。
如果你之前做过[LC.70爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)，则会比较容易理解这题的解法：走n步到0的方案数=**走n-1步到1的方案数**+**走n-1步到9的方案数。**

![image-20210716094606060](imgs\477.png)

```java
class Solution:
    def backToOrigin(self,n):
        #点的个数为10
        length = 10
        dp = [[0 for i in range(length)] for j in range(n+1)]
        dp[0][0] = 1
        for i in range(1,n+1):
            for j in range(length):
                #dp[i][j]表示从0出发，走i步到j的方案数
                dp[i][j] = dp[i-1][(j-1+length)%length] + dp[i-1][(j+1)%length]
        return dp[n][0]

```

### 13.区间和*区间最小值的最大值是多少

挑选一个区间，区间值为区间和乘以区间内最小的数的值，求区间值最大的区间（2021.1 字节跳动-国际化-前端）
无序数组，求一个值最大的区间，区间计算方案为：区间和 * 区间最小值（2020.09 字节跳动-电商-后端）
[3,1,6,4,5,2]，对于任意子序列可以计算一个X值，X=sum(subArray) * min(subArray)，求最大X（2020.07 字节跳动-商业化-前端）

**题目分析：**

给定一个数组，要求选出一个区间, 使得该区间是所有区间中经过如下计算的值最大的一个：区间中的最小数 * 区间所有数的和。

数组中的元素都是非负数。

输入两行，第一行n表示数组长度，第二行为数组序列。输出最大值。

输入
3
6 2 1
输出
36
解释：满足条件区间是[6] = 6 * 6 = 36;

**题目分析**

**方法一：暴力。**题目是找max(区间和 * 区间最小值)，而满足的区间最小值一定是数组的某个元素。因此可以枚举数组，枚举时每个元素（设为x）作为区间最小值，在x左右两侧找到第一个比x小的元素，分别记录左右边界的下标为l,r，寻找边界时计算当前区间的和。那么以x为区间最小值的最大计算区间一定是[l+1,r-1]区间和*x。整个算法的时间复杂度是O(N²)。

**方法二：单调栈。**方法一中找每个元素左右边界的复杂度是O(N)，通过单调栈的数据结构可以将其优化为O(1),因此优化后整个算法的时间复杂度可以达到O(N)。

```java
//单调栈，时间复杂度O(N)
#include <iostream>
#include <vector>
#include <stack>
using namespace std;
const int N = 500000+10;
int a[N];
int dp[N];
stack<int> s;
int main()
{
    int n,res=0;
    cin >> n;
    for(int i = 0; i < n; i ++) cin >> a[i];
    //前缀和便于快速求区间和，例如求[l,r]区间和=dp[r+1]-dp[l]。l和r的取值范围是[0,n)
    for(int i = 1; i <= n; i ++) dp[i] = dp[i-1] + a[i-1]; 
    for(int i = 0; i < n; i ++) {
        while(!s.empty() && a[i] <= a[s.top()]) {
            int peak = a[s.top()];
            s.pop();
            int l = s.empty()? -1 : s.top();
            int r = i; 
            //l和r是边界，因此区间是[l+1,r-1]，其区间和dp[r+1]-dp[l]
            int dist = dp[r] - dp[l+1];
            res = max(res,peak*dist);
        }
        s.push(i);
    }
    while(!s.empty())
    {
        int peak = a[s.top()];
        s.pop();
        int l = s.empty()? -1 : s.top();
        int r = n; 
        
        int dist = dp[r] - dp[l+1];
        res = max(res,peak*dist);
    }
    cout << res << endl; 
}

```



### 14.磁盘剩余空间最小

- 某一个大文件被拆成了N个小文件，每个小文件编号从0至N-1，相应大小分别记为S(i)。给定磁盘空间为C，试实现一个函数从N个文件中**连续选出若干个文件**拷贝到磁盘中，使得磁盘剩余空间最小。

滑动窗口 ：每次记录窗口内的总和，和小于C，记录剩余空间，再窗口右端右移，和大于C，就窗口左端右移，小于C情况下比较剩余空间取最小值。

```java
public class Solution {
    public int[] findMin(int[] s,int c){
        int i = 0;
        int j = 0;
        int minValue = Integer.MAX_VALUE;
        int sum = 0;
        int left = 0;
        int right = 0;
        while(j <= s.length){
            if(sum <= c){
               j++;
               sum += s[j];
               minValue = Math.min(minValue,c - sum);
               if(minValue == c - sum){
                   left = i;
                   right = j;
               }
            }else{
                i++;
                sum -= s[i];
            }
        }
        int nums = new int[right - left];
        for(int k = left;k < right;k++){
            nums[k - left] = s[k];
        }
        return nums;
    }
}
```



### 25.给一个0-4随机数生成器，如何生成0-6随机数

这个题的难点在于如何保证 数字出现的概率都是相等 的 **。**

0-6通过对7取余可以得到，那么就想办法凑对7取余的场景。

```java
public class Frequency {
    public static int rand7(){
        while(true){
            int num=5*rand5()+rand5();//0-24
            if(num<21)
                return num % 7;
        }
    }
}
```

```java


//变形：如果用0-6随机生成器生成0-9随机数
public class Frequency {
    public static int rand10(){
        while(true){
            int num=7*rand7()+rand7();
            if(num<41)
            //排除41-48，因为他们不能生成9，会造成各个数字出现的概率不同
                return num % 10;
        }
    }
}
```

### 29.剑指Offer62 圆圈中最后剩下的数字

 

0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。

例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。

 

示例 1：

输入: n = 5, m = 3
输出: 3
示例 2：

输入: n = 10, m = 17
输出: 2

```java
class Solution {
    public int lastRemaining(int n, int m) {
        // 用List来做
        List<Integer> list = new ArrayList<>();
        for(int i=0;i<n;i++){
            list.add(i);
        }
        // 第一个的索引是
        int index = 0;
        while(list.size()>1){
            // 开始
            for(int i=1;i<m;i++){
                index = (index+1)%list.size();
            }
            list.remove(index);
        }
        return list.get(0);
    }
}
```

### 32.下面代码输出什么

```java
public static void main(String[] args) {
		Map<Short, String> map = new HashMap<>(); 
		for(short i = 0; i <100; i++) {
		     map.put(i, String.valueOf(i));
		     map.remove(i-1);
		}
		System.out.println(map.size());
	}
```



### 排列11223344 问题

有8个数，11223344
将其排列，要求结果满足：两个1之间有一个数，两个2之间有两个数，两个3之间有三个数，两个4之间有四个数。问这个结果是多少？

答案：41312432 或 23421314

我们可以想象成有 8 个空格子，依次往里填数字，填的时候满足题目的要求，最终得到的结果便是问题的答案。

可以想到，先填 4 比较好，因为填 4 可能的方案最少。

如图所示，在最终答案中，4 的位置一定是以下三种方案之一。

![image.png](https://pic.leetcode-cn.com/1623844218-hpiqVz-image.png)


由于方案 1 和方案 3 只是顺序不同，因此我们可以只考虑方案1，如果最后以方案1为开始找到了答案，逆序一下便是方案3能找到的答案。

因此，我们只需考虑方案 1 和方案 2 。

同理，按照上面的思路，再填 3 ，再填 2 ，最后填 1 。

最终便可搜索到答案。

下图是以方案 1 开始搜索的所有可能方案，最终得到结果41312432；将其逆序得到的23421314，依然满足结果。

![image.png](https://pic.leetcode-cn.com/1623844265-SzlxjL-image.png)

大家可以在纸上写一下，看看和我图中的一不一致。

由方案 2 开始搜索无法得到满足条件的序列，因此不再画图分析。





## 智力题

### 1.抛硬币，谁胜公平的问题？

**一硬币，一面向上概率0.7，一面0.3，如何公平？**

>  抛两次， **正反** A胜， **反正** B胜。



**两个人轮流抛硬币，先抛到正面的赢，问先抛的人赢的概率**

2/3

每一轮 抛硬币，A先抛赢得概率是1/2，B后抛赢得概率是（1/2）*（1/2）= 1/4。那么 每一轮A赢得概率都是B赢得概率的2倍 ，总概率为1,所以A赢的概率是2/3。

### 2.烧香判断时间的问题？

- 两根香，一根烧完1小时，如何测量15分钟

开始时一根香两头点着，一根香只点一头，两头点着的香烧完说明过去了半小时，这时将只点了一头的香另一头也点着，从这时开始到烧完就是15分钟。

### 3.博弈论：海盗分金币的问题

5个海盗抢得100枚金币，他们按抽签的顺序依次提方案：首先由1号提出分配方案，然后所有5人表决(包括自己)，超过半数同意方案才被通过，否则他将被扔入大海喂鲨鱼，依此类推。

**两个海盗--毫无悬念**

> 结果 (0, 100)

**三个海盗--无奈的选择**

当存在三个海盗的时候,原来的两个海盗时的一号变成了二号,此时二号知道了,如果一号被投死,那么毫无悬念的,他没有任何活路,根据==贪生怕死==的原则,他会无论如何保全自己,换句话说,他无论如何都会同意此时一号的题意,那么此时聪明的一号知道他们的想法之后就开心的不行了,因为无论自己提什么条件自己都会得到半数以上的投票.那根据==贪得无厌==的原则,结果显而易见.

> 结果 (100, 0, 0)

**四个海盗--稍稍讨好就可以**

四个海盗时,此时的一号明白了此时的二号是讨好不了的.因为自己死了二号就一定能得到全部100枚金币,所以干脆不讨好,给他0枚金币吧.而此时除了自己的票还差两票,那么只要讨好三号和四号获得这两票就好,三号和四号相当容易讨好的,因为一号死了,他们就只能得到空气(三个海盗的结果为(100, 0, 0)),那么给他一块金币就好啦.当然一号不能不给三号四号金币,因为海盗都是==心狠手辣==的,==[如果不管你死不死我都是0块金币,那我干脆要你死算了]==.

> > 结果 (98, 0, 1, 1)

**五个海盗--照本宣科**

相同的原理,现在的一号需要2票就能保证存活,首先二号是不考虑了给金币了,不管给多少都反对的,三号给一个金币就行,然后还差一票,只要给==四号或五号==其中一个两枚金币,另一个不给,就可以.但这里要注意一下,此时的分歧已经产生,后面的推广推理中会用到.

> 结果: (97, 0, 1, 2, 0)或(97, 0, 1, 0, 2)

**推广的思路**

同样的思路推广下去我们会发现这样的规律:

> 当 n为偶数时只要给二号到n号0,1,0,1...0,1,0,1,1
>  当 n 为奇数时给1,x,1,x....x,x.(任意一个x是二其余都是0)

上述情况的答案都是m-n/2

### 4.赛马问题

- **64匹马，8个跑道，选跑最快的4匹马需要比赛多少次。** 

​      (     锦标赛[排序]()[算法]()     )      sum = 11     

​      第一步：首先每8匹马跑一次，总共需要8次，假设结果中A1>A2>A3>......,B1>B2>B3>....等。 sum=8；     

​      第二步：这8组中的第一名拉出来跑一次，那么这次最快的是总的第一名，假设是A1，同时假设B1>C1>D1。这时还要角逐2,3,4名，     那这一轮中的第五到第八组都可以直接舍弃     ，因为他们所有的马一定进不了前4名。sum=9。     

​      第三步：从A组中选A2，A3，A4，B组中B1，B2，B3，C组中C1，C2，D组中D1，这些才有资格角逐2,3,4名。这时需要再比赛两次。 sum=11。（但是如果第10轮选择A4不上场，如果A3获得了第4名，那么A4就不需要比赛了，这样     sum=10     ）。

解答：

一般想法是将球镜像对称，但这道题是把洞镜像对称

将这个桌面在这个平面无限延展，可类比成无限张球桌紧密放置

那么每一个和球洞的连线都是合法路径

### 5.大小王在一份的概率

**54张扑克牌，平均分成3份，大小王在一份的概率**

首先大王一定会在某一份中，然后要计算这一份中还要包含小王的概率。去掉大王还剩53张牌，这一份还可以分17张牌，那么每次分到小王的概率是1/53,所以总概率是17/53。

![image-20210716160902821](imgs\478.png)

### 场景设计题

#### 1.红包分发

**让你设计一个微信发红包的api，你会怎么设计，不能有人领到的红包里面没钱，红包数值精确到分。**

**a.所有人抢到金额之和等于红包金额，不能超过，也不能少于。**

**b.每个人至少抢到一分钱。**

**c.要保证所有人抢到金额的几率相等。**

> 解题思路：线段切割法

何谓线段切割法？我们可以把红包总金额想象成一条很长的线段，而每个人抢到的金额，则是这条主线段所拆分出的若干子线段。

![image-20210716161506487](imgs\479.png)

如何确定每一条子线段的长度呢？由“切割点”来决定。当N个人一起抢红包的时候，就需要确定N-1个切割点。



因此，当N个人一起抢总金额为M的红包时，我们需要做N-1次随机运算，以此确定N-1个切割点。**随机的范围区间是（1， M）**。



当所有切割点确定以后，子线段的长度也随之确定。这样每个人来抢红包的时候，只需要顺次领取与子线段长度等价的红包金额即可。

```java
public class Hongbao {
 
    public static double getRandomMoney(Redpackage redpackage){
        if (redpackage.redpackage_size == 1){
            redpackage.redpackage_size--;
            return (double) Math.round(redpackage.redpackage_money*100)/100;
        }
 
        Random r = new Random();
//      设置每次发红包的最小值
        double min = 0.01;
//      控制当前发红包的最大值
        double max = redpackage.redpackage_money/redpackage.redpackage_size * 2;
//      用随机数与当前发红包的最大钱数相乘，算出当前要发的红包
        double money = r.nextDouble() * max;
//      如果当前发红包的钱小于0.01则，赋值为0.01（规范当前红包最小值）
        money = money <= min?0.01:money;
//      统计为小数点后两位
        money = Math.floor(money*100)/100;
        redpackage.redpackage_size--;
        redpackage.redpackage_money -= money;
//      发红包
        return money;
    }
    static class Redpackage{
        double redpackage_money ;
        double redpackage_s
```

#### 2.关注如何设计

**谁关注了我，我关注了谁，谁与我互相关注。表该如何设计，索引怎么建。查询语句怎么写**

粉丝关注表使用四列，主键id，userId，fansId，是否互相关注。用两行数据来保存互相的关注关系，这样查询起来更方便，用空间换时间。

主键有主键索引，剩下的字段不适合建索引，因为字段重复太多。

#### 3.扫码登录是如何设计的？

**(1) 网页端+服务器**

首先，大概说一下原理：用户打开网站的登录页面的时候，向浏览器的服务器发送获取登录二维码的请求。服务器收到请求后，随机生成一个uuid，将这个id作为key值存入redis服务器，同时设置一个过期时间，再过期后，用户登录二维码需要进行刷新重新获取。同时，将这个key值和本公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片（二维码生成，网上有很多现成的接口和源码，这里不再介绍。）然后，将二维码图片和uuid一起返回给用户浏览器。

浏览器拿到二维码和uuid后，会每隔一秒向浏览器发送一次，登录是否成功的请求。请求中携带有uuid作为当前页面的标识符。这里有的同学就会奇怪了，服务器只存了个uuid在redis中作为key值，怎么会有用户的id信息呢？ 

这里确实会有用户的id信息，这个id信息是由手机服务器存入redis中的。具体操作如下：

**（2）手机端+服务器**

话说，浏览器拿到二维码后，将二维码展示到网页上，