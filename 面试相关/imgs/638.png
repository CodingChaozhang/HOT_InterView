
**1.2 PermGen space**

此错误消息表明永久代已满，永久代是存储类和方法对象的堆的区域。如果应用程序加载了大量的类或者应用程序实例化了大量字符串，那么则可能需要使用-XX: MaxPermSize选项增加永久代的大小；

**1.3 Requested array size exceeds VM limit**

此错误表示应用程序尝试分配大于堆大小的数组。例如，如果应用程序尝试分配512MB的数组但最大堆大小 为256MB，则将抛出此错误信息的OOM。在大多数情况下，问题是配置问题或应用程序尝试分配海量数组时导致的错误；

**1.4 Request bytes for Out of swap space?**

此消息似乎是一个OOM。但是，当本机堆的分配失败并且本机堆可能将被耗进时，HotSpot VM会抛出此异常。消息中包括失败请求的大小(以字节为单位)以及内存请求的原因。

如果抛出此类型的OOM，则可能需要在操作系统上使用故障排除实用程序来进一步诊断问题。在某些情况下，问题甚至可能与应用程序无关。例如，您可能会在以下情况下看到此错误：

- 操作系统配置的交换空间不足。
- 系统上的另一个进程是消耗所有可用的内存资源。

由于本机泄漏，应用程序也可能失败（例如，如果某些应用程序或库代码不断分配内存但无法将其释放到操作系统）

**1.5 Native method**

如果您看到此错误消息并且堆栈跟踪的顶部框架是本机方法，则该本机方法遇到分配失败。此消息与上一个消息之间的区别在于，在JNI或本机方法中检测到Java内存分配失败，而不是在Java VM代码中检测到。

如果抛出此类型的OOM，您可能需要在操作系统上使用实用程序来进一步诊断问题。

**1.6 Application Crash Without OOM**

有时，应用程序可能会在从本机堆分配失败后很快崩溃。如果您运行的本机代码不检查内存分配函数返回的错误，则会发生这种情况。

例如，如果没有可用内存，malloc系统调用将返回NULL。如果未检查malloc的返回，则应用程序在尝试访问无效的内存位置时可能会崩溃。根据具体情况，可能很难定位此类问题。



**(2) 解决步骤**（jps   jinfo  jstat  jmap）

在许多情况下，Java进程最终抛出一个OOM运行时异常，这是一个明确的指示，表明你的内存资源已经耗尽。**在这种情况下，需要区分正常的内存耗尽和泄露；**

**第一步：查看Java应用进程**

**jps**命令查看运行的java应用程序名称；

或者通过ps -aux | grep java命令也可以；



**第二步：分析堆的分配情况**

有可能是因为堆的分配情况过小的原因导致的，查看一下java运行的时候设置的一些超参数的情况。

**jinfo**来查看java运行时的参数信息，check一下，是否符合预期；

![image-20210623223126067](imgs\356.png)

**第三步：查看堆使用情况以及GC使用情况**

**jstat来查看虚拟机各种运算状态**

```shell
jstat -gcutil pid
```

![image-20210507144330745](E:/笔记/面试高频/imgs/193.png)

这个命令可以**查看进程启动以来s0,s1,新生代和老年代的使用空间的百分比以及 Young GC / Full GC 的次数及时间，并且会间隔很短展示最新数据**，主要**用于判断系统 GC 频率是否有问题**，**GC 时间是否过长影响系统正常运行**等。

**第四步：jstack快照工具**

jstack命令来查看线程对应的快照信息，查看是否有死锁或者被阻塞住的情况。

jstack -l pid

**第五步：查看GC历史**

jmap -heap查看详细的堆信息；

**jmap -dump** 打印详细的堆文件并查看；





要查看GC历史，需要打印GC日志，应用启动命令类似如下：

```shell
nohup java -XX:+PrintGCDetails \  -Xloggc:log/gc.log \  -XX:+HeapDumpOnOutOfMemoryError \  -XX:HeapDumpPath=log/dump.log \      -jar ${linkname} > nohup.out 2>&1 &
```

查看服务运行两三天后的GC日志，过滤出其中 Full GC 的信息

![image-20210507144432065](E:/笔记/面试高频/imgs/194.png)

可以观察到，经过多次 Full GC，**箭头右边的反映 GC 后老年代堆内存大小的数值在增加。这说明有老年对象一直没有被释放**，**某个对象对这些对象的引用一直维持着。这种趋势下去，OutOfMemory 错误的出现不可避免，完全实锤了该服务的内存泄漏问题。**



**第六步：查看堆实例对象分别**

> jmap -histo：显示堆中对象的统计信息；

查看进程堆中当前实例数前 20 类排名：

```shell
jmap -histo:live your-java-service-pid | head -n 20
```

![image-20210507144533081](E:/笔记/面试高频/imgs/195.png)

查看进程堆中当前实例数前 20 且为该项目包路径下类排名：

```shell
jmap -histo:live your-java-service-pid | grep your-project-package-typical-word | head -n 20
```



> - jps
> - jinfo
> - jstat -gcutil
> - jmap -dump
> - jmap -hissto



### 7.服务器日常维护 统计tcp连接的状态的数量 TIME_WAITING 和CLOSE_WAITING

```shell
netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'  
```

它会显示例如下面的信息：

TIME_WAIT 814
CLOSE_WAIT 1
FIN_WAIT1 1
ESTABLISHED 634
SYN_RECV 2
LAST_ACK 1

常用的三个状态是：**ESTABLISHED 表示正在通信**，**TIME_WAIT 表示主动关闭**，**CLOSE_WAIT 表示被动关闭**。

如果服务器出现了异常，那么百分之八九十都是下面两种情况：

- 服务器保持了大量的TIME_WAITING状态；
- 服务器保持了大量的CLOSE_WAITING状态；

##### 7.1 服务器保持了大量的TIME_WAITING主动关闭

这种情况比较常见，就可能一些爬虫服务器或者WEB服务器(没有做内核参数优化)，出现这种问题，这个问题是怎么产生呢？

例如对于爬虫服务器来说它本身就是客户端，完成一个爬取任务之后，它就会主动发起关闭连接的状态，从而进入TIME_wAITING状态，而需要等待2MSL时间之后，才会彻底关闭回收资源。

解决思路：让服务器快速回收和重用那些TIME_WAIT的资源。

**TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控**的，要么就是**对方连接的异常**，要么就是**自己没有迅速回收资源**，总之不是由于**自己程序错误导致**的。

**对/etc/sysctl.conf文件的修改**

- net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。
- net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。
- net.ipv4.tcp_keepalive_一系列参数，是用来设置服务器检测连接存活的相关配置。

##### 7.2 服务器保持了大量 CLOSE_WAIT被动关闭

TIME_WAIT状态可以通过优化服务器参数得到解决，因为发生TIME_WAIT的情况是服务器自己可控的，要么就是对方连接的异常，要么就是自己没有迅速回收资源，总之不是由于自己程序错误导致的。



但是CLOSE_WAIT就不一样了，从上面的图可以看出来，如果一直保持在CLOSE_WAIT状态，那么**只有一种情况，就是在对方关闭连接之后服务器程序自己没有进一步发出ack信号。换句话说，就是在对方连接关闭之后，程序里没有检测到，或者程序压根就忘记了这个时候需要关闭连接，于是这个资源就一直被程序占着。**

本质上出现CLOSE_WAIT就是查代码，因为问题出在服务器程序里头啊。

##### 7.3 举例来理解TIME_WAIT和CLOSE_WAIT

> 在正常四次挥手流程中，主动关闭的一方会经过TIME_WAIT状态，被动关闭的一方会经过CLOSE_WAIT的状态；

`TIME_WAIT`和`CLOSE_WAIT`这两个状态都是四次挥手中的状态，`TIME_WAIT`是主动关闭的一方发出FIN包会经过的状态，而`CLOSE_WAIT`是被动关闭连接的一端会经过的状态。`TIME_WAIT`会经过2个MSL(最大报文段生存时间)才能到CLOSE状态，而`CLOSE_WAIT`如果不发送FIN报文会一直处在CLOSE_WAIT状态。所以一般在看机器连接状态的时候，几千个TIME_WAIT一般是正常的(过2MSL自动关闭)；

**处于close_wait状态的连接很多，通常有几种可能：**

- 代码问题：短连接模式，忘记close连接，就不会发出FIN包，导致连接处于CLOSE_WAIT状态；或者程序在close连接之前陷入死循环或者执行时间过长。



**服务器A是一台爬虫服务器**，它使用简单的**HttpClient**去请求资源服务器B上面的apache获取文件资源。正常情况下，如果请求成功，那么在抓取完资源之后，**服务器A会主动关闭连接的请求**，这时候就是主动关闭连接，服务器**A的连接状态可以看到是TIME_WAIT**。

那么如果一旦发生异常呢？假设请求的资源服务器B上并不存在，那么这个时候会由**服务器B发出关闭连接的请求**，服务器A就是被动的关闭了连接，如果服务器A被动关闭连接之后程序员就**忘了让HttpClient释放连接**，那么就会造成CLOSE_WAIT的状态；



### 7.syns queue与accept queue是什么，其区别是什么呢？

**accpet队列以及socket连接建立流程如下图所示：**

![image-20210512162718431](imgs\239.png)

上图所示，这里有两个队列：syns queue(半连接队列)；accept queue(全连接队列)。

**（1）如何判断是否需要调整accept queue(全连接队列)大小？**

例如我们机器并发量很高，accept queue（全连接队列） 可能会出现不够用的情况，会出现类似connection reset 和 connection timeout 异常，这个取决于机器上 **tcp_abort_on_overflow** 的设置，不同值服务端不同处理机制：

**tcp_abort_on_overflow**为0：连接建立过程中三次握手第三步时，发生全连接队列满了，server扔掉client 发过来的ack，那么client 会重新发送ack，直到超时，所以客户端会出现连接超时（connection timeout ）；

**tcp_abort_on_overflow**为1：遇到全连接队列满了，server会发一个reset包给client，表示废掉这个这个连接，这个握手过程无效，客户端会看到很多connection reset by peer的错误；



### 7.什么情况会导致CPU使用率飙升

**会的情况**

while的无限循环

频繁的young gc



**不会的情况**

具有大量线程的应用程序；

处于blocked状态的线程；

**具有大量线程的应用程序的CPU使用率是否较高**



### 7.linux下如何定位线上CPU过高的问题（高频 top  top-hp jstack ）

A. **top命令**找到CPU利用率最高的进程（原理：方法是由线程执行的，线程是在进程底下的，找到进程下cpu最高的线程就能定位到方法）-默认按cpu使用率排序 找到其pid号；

B.之后通过**top -Hp pid**号，找到该进程下哪个线程的cpu使用情况

C. 通过top命令定位到cpu占用率较高的线程之后，继续使用`jstack pid`命令查看当前java进程的堆栈状态 jstack pid > p.txt 用哪个jstack导出线程的dump；

D. 把刚刚的pid线程号转成16进制 printf “%x \n” 40437

E. 到刚刚导出的p.txt里面检索定位；



### 8.linux下如何定位线上OOM的问题（高频 jps, jinfo jstat jmap）

A.确定JVM的内存空间是否分配过小；

```shell
jmap -heap pid
```

可以看出新生代、老年代的空间大小和使用情况；

B.找到最耗费内存对象

```shell
jmap -histo:live pId | more
```

可以看出存活对象的大小信息，找到耗费内存最大的那个对象；

C.确定资源是否耗尽

```shell
ptree
netstat
```



## 智力逻辑题

### (1) 已知random6求random10

给定rand6()函数实现

```java
private static int rand6(){
        return (int)(Math.random()*6)+1;
}
```

rand6()可以得到1，2，3，4，5，6
rand6()-1可以得到0，1，2，3，4，5
（rand6()-1）*6可以得到 0，6，12，18，24，30
result=(rand6()-1)*6+rand6()-1可以得到0，1，2，3，4，5，6，7……35

10的整数倍为10，20，30，因此将result>=30的部分截掉。
result%10可以得到0，1，2……9，再+1，可以得到1，2，3……10

```java
private static int rand10(){
        int result;
        do{
            result=(rand6()-1)*6+rand6()-1;
        }while(result>=30);
        return result%10+1;
}
```

> 补充random01生成random3

```java
int rand03(){
    return rand01() * 2 + rand01();
}
```

```java
int rand03(){
    return (rand2 - 1) * 2 + rand2 - 1;
}
```

### (1)给定随机数生成别的随机数rand5生成rand7

给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？

思路

由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。记住下面这个式子：

```
RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数
可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，
RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙
```

比如`Rand25= 5( Rand5()-1 ) + Rand5()`可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写

```java
int rand7(){
  int x=INT_MAX;
  while(x>21){
    x=5*(rand5()-1)+rand5();
  }
  return x%7+1;
}
```

### (2)老虎吃羊

智力题：85只老虎1只羊，老虎可以吃草，也可以吃羊，优先吃羊，吃完羊的老虎会变成羊。每只老虎都尽可能让自己存活的情况下，这只羊是否会被吃？（老虎吃羊问题）

我们先从1只老虎开始分析，如果只有一只老虎，那它一定会吃羊。因为就算吃完变成羊它也不用担心自己被吃掉。

如果岛上有两只老虎的话，那羊不会被吃掉，因为如果其中一只老虎吃掉羊之后自己就会变成羊被另一只老虎吃掉。

如果岛上有三只老虎，羊会被吃掉。因为一旦有一只最聪明的老虎吃掉羊之后，那只老虎自己变成羊，就变成了刚才所分析的2虎1羊的局面，剩下的2只老虎不敢吃掉变成羊的那只老虎。

如果岛上有4只老虎，羊不会被吃掉，因为一旦有一只虎吃掉羊，就会变成刚刚3虎1羊的局面，那只老虎变成的羊就会被吃掉。

以此类推，**如果老虎的数量是偶数，羊不会被吃掉**，**如果老虎的数量是奇数，羊就会被吃掉。**

### (3)赛马问题

25匹马5条跑道找最快的3匹马，需要跑几次？参考回答：7

64匹马8条跑道找最快的4匹马，需要跑几次？参考回答：11

25匹马5条跑道找最快的5匹马，需要跑几次？参考回答：最少8次最多9次

**1、25匹马5条跑道找最快的3匹马，需要跑几次？**

将25匹马分成ABCDE5组，假设每组的排名就是A1>A2>A3>A4>A5,用边相连，这里比赛5次

第6次，每组的第一名进行比赛，可以找出最快的马，这里假设A1>B1>C1>D1>E1

D1，E1肯定进不了前3，直接排除掉

第7次，A2 A3 B1 B2  C1比赛，可以找出第二，第三名

所以最少比赛需要7次

**2、64匹马8条跑道找最快的4匹马，需要跑几次？**

第一步 全部马分为8组，每组8匹，每组各跑一次，然后淘汰掉每组的后四名，如下图（需要比赛8场）

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbXicH94EIGmNCr4Wp8INyEvibP8xDKqNBKgloM4VtcjsVL1tQv2U1pt5DiaUwjic65vWsksBYw8wG7WFkw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第二步 取每组第一名进行一次比赛，然后淘汰最后四名所在组的所有马，如下图（需要比赛1场）

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbXicH94EIGmNCr4Wp8INyEvibP8sSnAflaiaic6fEgDa04wiaiaA4Ecw1bQvN1cpCoQGhlIDDYHnLQtCjD2A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

这个时候总冠军已经诞生，它就是A1，蓝域（它不需要比赛了）。

而其他可能跑得最快的三匹马只可能是下图中的黄域了（A2,A3,A4,B1,B2,B3,C1,C2,D1，共9匹马）

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbXicH94EIGmNCr4Wp8INyEvibPo8XUZZC6ISAuRLrU0bU2ou2nKa8Vz5DmLia65Iq06b1kx8pRfCVAdsQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

第三步 只要从上面的9匹马中找出跑得最快的三匹马就可以了，但是现在只要8个跑道，怎么办？

那就随机选出8匹马进行一次比赛吧（需要比赛一场）

第四步 上面比赛完，选出了前三名，但是9匹马中还有一匹马没跑呢，它可能是一个潜力股啊，那就和前三名比一比吧，这四匹马比一场，选出前三名。最后加上总冠军，跑得最快的四匹马诞生了！！！（需要一场比赛）

最后，一共需要比赛的场次：8 + 1 + 1 + 1 = 11 场



### (4)烧绳子问题

**一根质量不均匀的绳子,烧一根要一小时,有若干根这样的绳子,怎样计算出15分钟**

**要3根绳子**
第一条**点一头**,第二条**两头一起点着,两条同时点.**
等第二条绳子烧完时,（已过半小时）马上将**第一条绳子的没点着的一端也点着**.
等第一条绳子烧完时,（又过了15分钟）马上将第**三条绳子的两端点着**.
等第三条绳子烧完时,（又过了半小时）
**总共1小时15分钟.**

**(5)三人三鬼过桥**

有三个人跟三个鬼要过河,河上没桥只有条小船,然后船一次只能渡一个人和一个鬼,或者两个鬼或者两个人,无论在哪边岸上,只有是人比鬼少的情况下(如两鬼一人,三鬼两人,三鬼一人)人会被鬼吃,然而船又一定需要人或鬼操作才能航行(要有人或鬼划船),问,如何安全的把三人三鬼渡过河对岸?

> - **先两鬼过去。**在一鬼回来。对面有一鬼。这边有三人两鬼。
> - **再两鬼过去。**在一鬼回来。对面有两鬼。这边有三人一鬼。
> - **再两人过去。一人一鬼回来**。对面一人一鬼。这边两人两鬼。
> - **最后两人过去。一鬼回来**。对面三人。这边三鬼。
> - **剩下的就三个鬼二个过去一个回来**在接另外个就OK了。

### (5)砝码称轻重，找出最轻的

1、有一个天平，九个砝码，其中一个砝码比另八个要轻一些，问至少要用天平称几次才能将轻的那个找出来？

参考回答：**至少2次**。第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；至少称2次．

2、十组砝码每组十个，每个砝码都是10g重，但是现在其中有一组砝码每个都只有9g重，现有一个能显示克数的秤，**最少称几次能找到轻的那组**？参考回答：1次

参考回答：**至少1次。**

将砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组

###  (6)利用空瓶换饮料，最多喝几瓶？

1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶？

参考回答

拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。

### (7)毒药毒白鼠，找出哪个瓶子是毒药？

有1000个一模一样的瓶子，其中有999瓶是普通的水，有1瓶是毒药。任何喝下毒药的生命都会在一星期之后死亡。现在你只有10只小白鼠和1个星期的时间，如何检验出哪个瓶子有毒药？

> 解题：

首先一共有1000瓶，2的10次方是1024，刚好大于1000，也就是说，1000瓶药品可以使用10位二进制数就可以表示。从第一个开始：

第一瓶 ：  00 0000 0001

第二瓶：  00 0000 0010

第三瓶：  00 0000 0011

……

第999瓶：  11 1111 0010

第1000瓶： 11 1111 0011

**需要十只老鼠，如果按顺序编号，ABCDEFGHIJ分别代表从低位到高位每一个位。每只老鼠对应一个二进制位，如果该位上的数字为1，则给老鼠喝瓶里的药。**

**观察，若死亡的老鼠编号为：ACFGJ，一共死去五只老鼠，则对应的编号为  10 0110 0101，则有毒的药品为该编号的药品，转为十进制数为：613号。（这才是正解，当然前提是老鼠还没被撑死）**

8瓶酒一瓶有毒，用小老鼠测试。每次测试结果8小时后才会得出，而你只有8个小时的时间。最少需要（  ）老鼠测试？A、2     B、3     C、4       D、6

解析：用3位2进制代表8瓶酒，如下表所示

瓶序号           二进制                   中毒情况

第一瓶            000                     全没中毒

第二瓶            001                  只有第一个老鼠中毒

第三瓶            010                  只有第二个老鼠中毒

第四瓶            011               第一个老鼠、第三个老鼠同时中毒

第五瓶            100                  只有第三个老鼠中毒

第六瓶            101               第一个老鼠、第三个老鼠同时中毒

第七瓶            110               第二个老鼠、第三个老鼠同时中毒

第八瓶             111                    三个老鼠同时中毒

其中，第一个老鼠喝下最低位为1对应的酒，第二个老鼠喝下中间位为1对应的酒，第三个老鼠喝下最高位为1对应的酒

**最后将所有中毒的老鼠，对应的位次进行与操作即可以知道那瓶毒药有毒了**

### (8)利用烧绳子计算时间

现有若干不均匀的绳