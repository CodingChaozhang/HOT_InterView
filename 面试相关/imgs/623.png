件系统是在硬盘上保持跟踪所有文件和目录的一组结构如果没有存储数据的文件系统，信息将会混乱。

**分区：**硬盘在使用之前需要进行分区，分区是将磁盘空间分成多个存储空间，每一个子空间成为一个分区，不同的分区可以格式化为不同的文件系统。

**格式化：**格式化就是创建文件系统，的mkfs的命令用于将分区格式化为特定的文件系统类型。

**挂载：**就是将某一空间（比如目录，格式化后的文件系统）挂载到挂载点中而挂载点就是进入文件系统的入口。



##### 2.1 文件类型

Linux下面的文件类型主要有：

**1) 普通文件：**C语言元代码、SHELL[脚本](https://www.linuxcool.com/)、二进制的可执行文件等。分为纯文本和二进制。

**2) 目录文件：**目录，存储文件的唯一地方。

**3) 链接文件：**指向同一个文件或目录的的文件。

**4) 设备文件：**与系统外设相关的，通常在/dev下面。分为块设备和字符设备。

**5）管道(FIFO)文件:** 提供进程之间通信的一种方式

**6）套接字(socket) 文件：** 该文件类型与网络通信有关

可以通过ls –l, file, stat几个命令来查看文件的类型等相关信息。

##### 2.2 Linux目录

文件结构是文件存放在磁盘等存贮设备上的组织方法。主要体现在对文件和目录的组织上；

目录提供了管理文件的一个方便而有效的途径。

Linux使用标准的目录结构，在安装的时候，安装程序就已经为用户创建了文件系统和完整而固定的目录组成形式，并指定了每个目录的作用和其中的文件类型。

完整的目录树可划分为小的部分，这些小部分又可以单独存放在自己的磁盘或分区上。这样，相对稳定的部分和经常变化的部分可单独存放在不同的分区中，从而方便备份或系统管理。目录树的主要部分有 root、/usr、/var、/home 等。这样的布局可方便在 Linux 计算机之间共享文件系统的某些部分。

![image-20210722211354966](imgs\531.png)



Linux采用的是树型结构。最上层是根目录，其他的所有目录都是从根目录出发而生成的。

微软的DOS和windows也是采用树型结构，但是在DOS和windows中这样的树型结构的根是磁盘分区的盘符，有几个分区就有几个树型结构，他们之间的关系是并列的。最顶部的是不同的磁盘（分区），如：C，D，E，F等。

但是在linux中，无论操作系统管理几个磁盘分区，这样的目录树只有一个。从结构上讲，各个磁盘分区上的树型目录不一定是并列的。

##### 2.3 Linux磁盘分区



**/**-------根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下  有2G的容量应该是够用了。当然了，很多东西都是多多益善的）

**swap**----交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量  只要约等于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。

**/home**---这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区

**/usr**----应用程序目录。大部分的软件都安装在这里，如果您计划安装许多软件，建议也给它分配一个分区

**/var**----如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区

**/boot**---如果您的硬盘不支持LBA模式（不太可能），您最好挂载它，如果挂载，将它挂载在硬盘的第一个  分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了

 ![image-20210722213334057](imgs\533.png)



分区类型:

  **主分区:** 最多只能有4个

   **扩展分区:**最多只能有1个. 主分区加扩展分区最多有4个. 不能写入数据,只能包含逻辑分区

   **逻辑分区:**



主分区为什么只能分4个?

​    由硬盘结构来决定,整个硬盘分成一个个等大小的扇区,每个扇区512字节,448字节用来记录启动信息,64个字节用来进行分区表式,每16个字表示   一个分区,所以最多4个分区.





**主分区，扩展分区和逻辑分区：**

linux分区不同于windows,**硬盘和硬盘分区在Linux都表示为设备.**

硬盘分区一共有三种：主分区，扩展分区和逻辑分区。

硬盘的分区主要分为主分区(Primary Partion)和扩展分区(Extension Partion)两种，主分区和扩展分区的数目之和不能大于四个。

**主分区(Primary Partion)：**可以马上被使用但不能再分区。

**扩展分区(Extension Partion)：**必须再进行分区后才能使用，也就是说它必须还要进行二次分区。

**逻辑分区((Logical Partion))：**由扩展分区建立起来的分区，逻辑分区没有数量上限制。

**Linux下磁盘分区和目录的关系如下：**

– 任何一个分区都必须挂载到某个目录上。

– **目录是逻辑上的区分**。分**区是物理上的区分。**

– 磁盘Linux分区都必须挂载到目录树中的某个具体的目录上才能进行读写操作。

– 根目录是所有Linux的文件和目录所在的地方，需要挂载上一个磁盘分区。

##### 2.4 Linux文件系统

文件系统指文件存在的物理空间，linux系统中每个分区都是一个文件系统，都有自己的目录层次结构。linux会将这些分属不同分区的、单独的文件系统按一定的方式形成一个系统的总的目录层次结构。一个操作系统的运行离不开对文件的操作，因此必然要拥有并维护自己的文件系统。

###### a.文件系统类型

```
ext2 ： 早期linux中常用的文件系统
ext3 ： ext2的升级版，带日志功能
RAMFS ： 内存文件系统，速度很快
NFS ： 网络文件系统，由SUN发明，主要用于远程文件共享
MS-DOS ： MS-DOS文件系统
VFAT ： Windows 95/98 操作系统采用的文件系统
FAT ： Windows XP 操作系统采用的文件系统
NTFS： Windows NT/XP 操作系统采用的文件系统
HPFS ： OS/2 操作系统采用的文件系统
PROC : 虚拟的进程文件系统
ISO9660 ： 大部分光盘所采用的文件系统
ufsSun : OS 所采用的文件系统
NCPFS ： Novell 服务器所采用的文件系统
SMBFS ： Samba 的共享文件系统
XFS ： 由SGI开发的先进的日志文件系统，支持超大容量文件
JFS ：IBM的AIX使用的日志文件系统
ReiserFS : 基于平衡树结构的文件系统
udf: 可擦写的数据光盘文件系统
```

###### b.文件系统特性

**磁盘分区完毕后还需要进行格式化(format)，之后操作系统才能够使用这个分区**。 格式化的目的是**能使操作系统可以使用的文件系统格式（即我们上面提到文件系统类型）**.

每种操作系统能够使用的文件系统并不相同. 如windows 98 以前的微软操作系统主要利用的文件系统是 FAT (或 FAT16)，windows 2000 以后的版本有所谓的 NTFS 文件系统，至于 **Linux 的正统文件系统则为 Ext2 (Linux second extended file system, ext2fs)这一个。**此外，在默认的情况下，windows 操作系统是不会认识 Linux 的 Ext2 的。

**传统的磁盘与文件系统之应用中，一个分区就是只能够被格式化成为一个文件系统**，所以我们可以说一个 filesystem 就是一个 partition。但是由于新技术的利用，例如我们常听到的**LVM与软件磁盘阵列(software raid)， 这些技术可以将一个分区格式化为多个文件系统(例如LVM)，也能够将多个分区合成一个文件系统(LVM, RAID)！** 所以说，目前我们在格式化时已经不再说成针对 partition 来格式化了， 通常我们可以称呼一个可被挂载的数据为一个文件系统而不是一个分区喔！





**那么文件系统是如何运行的呢？**这与操作系统的文件数据有关。较新的操作系统的文件数据除了文件实际内容外， 通常含有非常多的属性，例如 Linux 操作系统的文件权限(rwx)与文件属性(拥有者、群组、时间参数等)。 文件系统通常会将这两部份的数据分别存放在不同的区块，**权限与属性放置到 inode** 中，至于**实际数据则放置到 data block 区块**中。 另外，还有**一个超级区块 (superblock) 会记录整个文件系统的整体信息，包括 inode 与 block 的总量、使用量、剩余量等。**





对于一个磁盘分区来说，在被指定为相应的文件系统后，整个分区被分为 1024，2048 和 4096 字节大小的块。根据块使用的不同，可分为：

**超级块(Superblock)**: 这是整个文件系统的第一块空间。包括整个文件系统的基本信息，如块大小，inode/block的总量、使用量、剩余量，指向**空间 inode 和数据块的指针等相关信息。**

**inode块(文件索引节点)** : 文件系统索引,记录文件的属性。它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的桥梁。每个子目录和文件只有唯一的一个 inode 块。**它包含了文件系统中文件的基本属性(文件的长度、创建及修改时间、权限、所属关系)、存放数据的位置等相关信息.** 在 Linux 下可以通过 “ls -li” 命令查看文件的 inode 信息。硬连接和源文件具有相同的 inode 。

**数据块(Block)** :**实际记录文件的内容，若文件太大时，会占用多个block。**为了提高目录访问效率，Linux还提供了表达路径与inode对应关系的dentry结构。它描述了路径信息并连接到节点inode，它包括各种目录信息，还指向了inode和超级块。

就像一本书有封面、目录和正文一样。在文件系统中，超级块就相当于封面，从封面可以得知这本书的基本信息； inode 块相当于目录，从目录可以得知各章节内容的位置；而数据块则相当于书的正文，记录着具体内容。

**Linux正统的文件系统(如ext2、3等)将硬盘分区时会划分出超级块、inode Table区块和data block数据区域**。**一个文件由一个超级块、inode和数据区域块组成**。Inode包含文件的属性(如读写属性、owner等，以及指向数据块的指针)，数据区域块则是文件内容。当查看某个文件时，会先从inode table中查出文件属性及数据存放点，再从数据块中读取数据。

![image-20210722212911138](imgs\532.png)





#### 0.四层和七层负载均衡的区别

**简单理解四层和七层负载均衡：**

**所谓四层就是基于IP+端口的负载均衡**；**七层就是基于URL等应用层信息的负载均衡**；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。 换句换说，二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；**四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；七层通过虚拟的URL或主机名接收请求，然后再分配到真实的服务器。**

**所谓四层负载均衡**，也就是主要通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

　　以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。

![image-20210714214911018](imgs\467.png)

**所谓七层负载均衡**，也称为“内容交换”，也就是主要通过报文中的真正有意义的应用层内容，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。

　　以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。



> 负载均衡算法：
>
> (1) 利用http重定向；
>
> (2)利用dns域名解析的时候(确实会用)；
>
> (3)反向代理器nginx；（经过一个机器）
>
> (4)IP负载均衡；（经过一个机器）
>
> (5)数据链路层负载均衡；（三角模式）

#### 0.0 Linux虚拟文件系统

文件系统的种类众多，而操作系统希望**对用户提供一个统一的接口**，于是在用户层与文件系统层引入了中间层，这个中间层就称为**虚拟文件系统（\*Virtual File System，VFS\*）。**

VFS 定义了一组所有文件系统都支持的数据结构和标准接口，这样程序员不需要了解文件系统的工作原理，只需要了解 VFS 提供的统一接口即可。

在 Linux 文件系统中，用户空间、系统调用、虚拟机文件系统、缓存、文件系统以及存储之间的关系如下图：

![image-20210714222905481](imgs\469.png)

Linux 支持的文件系统也不少，根据存储位置的不同，可以把文件系统分为三类：

- *磁盘的文件系统*，它是直接把数据存储在磁盘中，比如 Ext 2/3/4、XFS 等都是这类文件系统。
- ***内存的文件系统***，这类文件系统的数据不是存储在硬盘的，而是占用内存空间，我们经常用到的 `/proc` 和 `/sys` 文件系统都属于这一类，读写这类文件，实际上是读写内核中相关的数据数据。
- *网络的文件系统*，用来访问其他计算机主机数据的文件系统，比如 NFS、SMB 等等。

文件系统首先要先挂载到某个目录才可以正常使用，比如 Linux 系统在启动时，会把文件系统挂载到根目录。



**Linux系统的/proc目录介绍**

在GUN/Linux操作系统中，/proc是一个位于内存中的伪文件系统(in-memory pseudo-file system)。**该目录下保存的不是真正的文件和目录，而是一些“运行时”信息，如系统内存、磁盘io、设备挂载信息和硬件配置信息等。**

proc目录是一个控制中心，用户可以通过更改其中某些文件来改变内核的运行状态。proc目录也是内核提供给我们的查询中心，我们可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。在Linux系统中，许多工具的数据来源正是proc目录中的内容。例如，lsmod命令就是cat /proc/modules命令的别名，lspci命令是cat /proc/pci命令的别名。

- `/proc` 文件系统是在 `GUN/Linux` 操作系统中一个位于**内存中**的**虚拟文件系统**`(in-memory pseudo-file system)`, 以文件系统目录和文件形式, 提供一个指向内核数据结构的接口，
  通过它能够查看和改变各种系统属性.
- `/proc` 目录通常情况下是由系统自动挂载在 `/proc` 目录下，但是我们也可以自行手动挂载．
- `/proc` 目录下的大部分文件都是只读的，部分文件是可写的，我们通过这些可写的文件来修改内核的一些配置;
- `proc` 目录是一个**控制中心**，用户可以通过更改其中某些文件来改变内核的运行状态。
- `proc` 目录也是内核提供给我们的**查询中心**，我们可以通过这些文件查看有关系统硬件及当前正在运行进程的信息。

#### 0.1 Linux文件系统简介

在Linux操作系统中，所有被操作系统管理的资源，比如网络接口、磁盘驱动器、输入输出设备、普通文件或者说是目录都被看作是一个文件。也就是在Linux系统中有一个重要的概念：**一切皆文件。**

#### 0.2 inode介绍

**inode是linux/unix文件系统的基础。**

磁盘的最小存储单位是扇区(Sector), 块(block)由多个扇区组成。  

**文件存储在块中**，**块的最常见的基本单位是4kb**，即约为8个连续的扇区组成(每个扇区存储512字节)。一个文件可能占用多个block，但是一个块只能存放一个文件。

> **inode就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者、创建时间、权限、大小等信息。**

#### 0.3 Linux文件类型

- **普通文件**(-)：存储信息和数据；
- **目录文件**(d,directory file)：目录也是文件的一种；
- **符合链接文件**(l,symbolic link)：保留了指向文件的地址而不是文件本身；
- **字符设备**(c, char)： 用来访问字符设备比如硬盘；
- **设备文件**(b,block):用来访问块设备比如硬盘、软盘
- **管道文件**(p,pipe)：一种特殊类型的文件，用来进程之间的通信；
- **套接字**(s,socket)：用于进程间的网络通信，也可以用于本机之间的非网络通信。

#### 0.4 目录的操作命令(增删改查)

- `mkdir 目录名称`:  增加目录
- `ls -l`：查看目录信息
- `find 目录 参数`: 寻找目录 `find /home -name "*/txt"`
- `mv 目录名称 新目录名称`：修改目录的名称/移动目录的位置
- `cp -r 目录名称 目录拷贝的目标位置`： 拷贝目录
- `rm [-rf] 目录`： 删除目录

#### 0.5 文件的操作命令(增删改查)

- `touch 文件名称`：文件的创建（增）
- `cat/more/less/tail`：文件查看（查）。命令`tail -f 文件`可以对某个文件进行动态监控，例如tomcat的日志文件，会随着程序的运行，日志会变化，可以使用`tail -f catalina-2020-04-19.log`监控文件的变化；
- `vim 文件`：修改文件的内容(改)。一般步骤就是`vim文件---->进入文件----->命令模式--->按i进入编辑模式---->编辑文件---->按Esc进入底行模式---->输入：wq/q!` 
- `rm -rf 文件`：删除文件(删除)

#### 0.6 文件的操作权限

![image-20210419133200163](imgs\87.png)

第一列是文件类型：

- d：代表**目录**
- -：代表**文件**
- l：代表**软链接**

权限类型分为以下几种：

- r： **可读**，r可用数字4表示
- w：**可写**，w可用数字2表示
- x：**可执行**，x可用数字1表示

权限分别是：

- **文件所有者；**
- **文件所在组；**
- **其它用户**

`chmod`命令来修改文件/目录的权限

#### 0.7 其它常用Linux命令

查看系统正在运行的进程`ps -ef `或者`ps -aux`. `top`

查看当前系统的网卡信息：`ifconfig`

查看与某台机器的连接情况：`ping`

查看当前系统的端口使用：`netstat -an`

#### 0.8 什么是shell

Shell是一个命令解释器，解释执行用户输入的命令和程序, 一旦输入命令，就立即回应的交互的对话方式。

Shell几乎是IT企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份以及处理、日志分析等环节里面。

### 1.Linux下查看系统日志教程

Linux系统在运行的程序通常会把一些系统消息和错误消息写入对应的系统日志中，若是一旦出现问题 ，用户就可以通过查看日志来迅速定位，及时解决故障。

#### 1.1 Linux系统日志的三种类型

**a.内核以及系统日志**

这种日志数据由系统 服务rsyslog统一管理，根据其主配置文件/etc/rsyslog.conf中的设置决定将内核消息以及各种系统程序消息记录到什么位置。系统中有相当一部分程序会把日志文件交由rsyslog管理，因而这些程序使用的日志记录也具相似的格式。

**b.用户日志**

这种日志数据用于记录Linux操作系统 用户登录以及退出系统的相关信息，包括用户名、登录的终端、登录时间、来源主机、正在使用的进程操作等。

**c.程序日志**

有些应用程序会选择由自己独立管理一份日志文件，用于记录本程序运行过程中的各种事件信息，而不是交给rsysylog服务管理。由于这些程序只负责管理自己的日志文件，因此不同程序所使用的日志记录格式可能会存在较大的差异。

#### 1.2 Linux系统常见的日志文件。

路径一：/var/log/messages：记录Linux内核消息以及各种应用程序的公共日志新；

路径二：/var/log/cron：记录crond计划任务产生的事件信息；

路径三：/var/log/dmesg：记录 Linux 操作系统在引导过程中的各种事件信息

路径四：/var/log/maillog：记录进入或发出系统的电子邮件活动

路径五：/var/log/lastlog：记录每个用户最近的登录事件

路径六：/var/log/secure：记录用户认证相关的安全事件信息

路径七：/var/log/wtmp：记录每个用户登录、注销及系统启动和停机事件

路径八：/var/log/btmp：记录失败的、错误的登录尝试及验证事件

####  1.3 Linux系统日志的优先级别

数字等级越小，优先级越高，消息越重要。

![image-20210730103624809](imgs\569.png)

#### 1.4 Linux系统用户日志相关命令

**1.users#**

users命令只是简单地输出当前登录的用户名称，每个显示的用户名对应一个登录会话。如果一个用户有不止一个登录会话，那他的用户名将显示与其相同的次数。

**2.who#**

who命令用于报告当前登录到系统中的每个用户的信息。使用该命令，系统管理员可以查看当前系统存在哪些不合法用户，从而对其进行审计和处理。who的默认输出包括用户名、终端类型、登录日期及远程主机。

**3.w#**

w命令用于显示当前系统中的每个用户及其所运行的进程信息，比users、who命令的输出内容要丰富一些。

**4.last#**

last命令用于查询成功登录到系统的用户记录，最近的登录情况将显示在最前面。通过last命令可以及时掌握Linux主机的登录情况，若发现未经授权的用户登录过，则表示当前主机可能已被入侵。

**5.lastb#**

lastb命令用于查询登录失败的用户记录，如登录的用户名错误、密码不正确等情况都将记录在案。登录失败的情况属于安全事件，因为这表示可能有人在尝试猜解你的密码。



### 1.Linux下的top命令详解

平常我们使用 `top` 命令来查看系统的性能情况，在 `top` 命令中可以看到很多不同类型的 CPU 使用率，如下图红框中标出部分：

![image-20210729200231029](imgs\556.png)

下面，就来介绍一下CPU使用率的含义：

- `us`：user time，**表示cpu执行用户进程的时间**，包括nice时间。通常都是希望用户空间CCPU越高越好；
- `sy`: system time,**表示cpu在内核运行的时间**，包括IRQ和softirq。系统CPU占用越高，表明系统某部分存在瓶颈。通常这个值越低越好。
- `ni`: nice time, **具有优先级的用户进程执行时占用的CPU利用率百分比。**
- `id:`idle time, 表示**系统处于空闲期，等待进程运行。**
- `wa:` waiting time, **表示CPU在等待IO操作完成所花费的时间。**系统不应该花费大量的时间来等待IO操作，否则就说明IO存在瓶颈。
- `hi:`hard IRQ time, 表示**系统处理硬中断所花费的时间**。
- `si:` soft IRQ time. 表示**系统处理软中断所花费的时间。**
- `st`: steal time，**被强制等待(involuntary wait)虚拟CPU的时间，此时Hypervisor在为另一个虚拟处理器服务**。



 



### 1.Linux下的free命令详解

free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。

![image-20210729100417448](imgs\543.png)

**total** 列显示系统总的**可用物理内存和交换空间大小**。

**used** 列显示已经**被使用的物理内存和交换空间**。

**free** 列显示还有多少**物理内存和交换空间**可用使用。

**shared** 列显示**被共享使用的物理内存大小**。

**buff/cache** 列显示**被 buffer 和 cache 使用的物理内存大小**。

**available** 列显示还可以**被应用程序使用的物理内存大小**。

#### 1.1 buff/cache

 buffer 和 cache 应该是两种类型的内存，但是 free 命令为什么会把它们放在一起呢？要回答这个问题需要我们做些准备工作。让我们先来搞清楚 buffer 与 cache 的含义。



**buffer** 在操作系统中指 buffer cache， 中文一般翻译为 **"缓冲区"**。要理解缓冲区，必须明确另外两个概念："扇区" 和 "块"。**扇区是设备的最小寻址单元，也叫 "硬扇区" 或 "设备块**"。**块是操作系统中文件系统的最小寻址单元，也叫 "文件块" 或 "I/O 块**"。每个块包含一个或多个扇区，但大小不能超过一个页面，所以**一个页可以容纳一个或多个内存中的块。**  当一个块被调入内存时，它要存储在一个缓冲区中。每个缓冲区与一个块对应，它相当于是磁盘块在内存中的表示(下图来自互联网)：

![image-20210729101002892](imgs\544.png)

注意，**buffer cache 只有块的概念而没有文件的概念，它只是把磁盘上的块直接搬到内存中而不关心块中究竟存放的是什么格式的文件**。

**cache** 在操作系统中指 page cache，中文一般翻译为 "页高速缓存"。页高速缓存是内核实现的磁盘缓存。它主要用来减少对磁盘的 I/O 操作。具体地讲，是通过把磁盘中的数据缓存到物理内存中，把对磁盘的访问变为对物理内存的访问。页高速缓存缓存的是内存页面。**缓存中的页来自对普通文件、块设备文件(这个指的就是 buffer cache 呀)和内存映射文件的读写**。

> 具体区别：

1、**Buffer**（缓冲区）是系统两端处理**速度平衡**（从长时间尺度上看）时使用的。它的引入是为了减小短期内突发I/O的影响，起到**流量整形**的作用。比如生产者——消费者问题，他们产生和消耗资源的速度大体接近，加一个buffer可以抵消掉资源刚产生/消耗时的突然变化。
2、**Cache**（缓存）则是系统两端处理**速度不匹配**时的一种**折衷策略**。因为CPU和memory之间的速度差异越来越大，所以人们充分利用数据的局部性（locality）特征，通过使用存储系统分级（memory hierarchy）的策略来减小这种差异带来的影响。

**Linux下**

buffer和cache是两个在计算机技术中被用滥的名词，放在不通语境下会有不同的意义。

在Linux的内存管理中，**这里的buffer指Linux内存的：Buffer cache。**这里的**cache指Linux内存中的：Page cache。**

在历史上，**它们一个（ buffer ）被用来当成对 io 设备写的缓存，而另一个（ cache ）被用来当作对 io 设备的读缓存**，这里的 io 设备，主要指的是块设备文件和文件系统上的普通文件。

但是现在，它们的意义已经不一样了。
在当前的内核中， **page cache 顾名思义就是针对内存页的缓存**，说白了就是，如果有内存是以 page 进行分配管理的，都可以使用 page cache 作为其缓存来管理使用。

**page cache是对文件数据的缓存**；**buffer cache是对设备数据的缓存。**





#### 1.2 free与available

在 free 命令的输出中，有一个 free 列，同时还有一个 available 列。这二者到底有何区别？

free 是真正尚未被使用的物理内存数量。至于 available 就比较有意思了，它是从应用程序的角度看到的可用内存数量。

Linux 内核为了提升磁盘操作的性能，会消耗一部分内存去缓存磁盘数据，就是我们介绍的 buffer 和 cache。所以**对于内核来说，buffer 和 cache 都属于已经被使用的内存。**

当应用程序需要内存时，如果没有足够的 free 内存可以用，内核就会从 buffer 和 cache 中回收内存来满足应用程序的请求。所以从应用程序的角度来说，**available = free + buffer + cache**。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。

#### 1.3 交换空间(swap space)

swap space 是磁盘上的一块区域，可以是一个分区，也可以是一个文件。所以具体的实现可以是 swap 分区也可以是 swap 文件。当系统物理内存吃紧时，Linux 会将内存中不常访问的数据保存到 swap 上，这样系统就有更多的物理内存为各个进程服务，而当系统需要访问 swap 上存储的内容时，再将 swap 上的数据加载到内存中，这就是常说的换出和换入。交换空间可以在一定程度上缓解内存不足的情况，但是它需要读写磁盘数据，所以性能不是很高。

现在的机器一般都不太缺内存，如果系统默认还是使用了 swap 是不是会拖累系统的性能？理论上是的，但实际上可能性并不是很大。并且内核提供了一个叫做 swappiness 的参数，用于配置需要将内存中不常用的数据移到 swap 中去的紧迫程度。这个参数的取值范围是 0～100，0 告诉内核尽可能的不要将内存数据移到 swap 中，也即只有在迫不得已的情况下才这么做，而 100 告诉内核只要有可能，尽量的将内存中不常访问的数据移到 swap 中。在 ubuntu 系统中，swappiness 的默认值是 60。如果我们觉着内存充足，可以在 /etc/sysctl.conf 文件中设置 swappiness：

```
vm.swappiness=10
```

如果系统的内存不足，则需要根据物理内存的大小来设置交换空间的大小。具体的策略网上有很丰富的资料，这里笔者不再赘述。

### 2.Linux的netstat的参数

-a或all ：显示所有连线上的socket。

-nhuonumeric：直接使用IP地址，而不通过域名服务器；

-t或tcp：显示TCP传输协议的连接状况；

-u或udp：显示UDP传输协议的连接状态；

-p或programs 显示正在使用socket的程序识别码和程序名称



-c或continuous 持续列出网络状态；

-C或cache  显示路由器配置的快取信息；

-e或-extend  显示网络其它相关信息

### 2.Linux系统下如何优雅地关闭Java进程？

**前言**

Linux系统 下如何kill掉一个后台Java进程。首先使用ps命令查找该Java进程的进程ID，然后使用kill命令进行杀掉。命令如下：

（1）ps查进程ID

[user@data2 ~]$ ps -ef | grep Test

user 2095020809 0 21:30 pts/1 00:00:00 java -jar Test.jar

user 21030 20996 0 21:30 pts/2 00:00:00 grep Test

（2）kill杀进程

[user@data2 ~]$ kill -9 20950

　　

再使用ps命令查该进程，发现进程Test.jar已经被杀掉。使用“kill -9 $pid”杀Java进程，干净利落。但该方法是不是结束Java后台进程的较好方法呢？



**思考下面的场景**

开发一个Java后台程序，其功能是不停地扫描Linux系统下的某个ftp目录。如果有文件，就经过数据转换写入到数据库中；如果没有文件，就sleep一秒钟。ftp目录下的文件不断地上传，Java程序处理完一个文件，就将该文件移到备份目录下面。”

该场景涉及Java程序进行文件打开、文件读取、文件备份、数据库连接、数据库写入等操作。因为文件句柄和数据库连接在Linux系统中是有限的资源，所以文件和数据库操作完成，需要进行关闭。

**如果用户直接使用“kill -9”杀掉一个后台正在读取文件并写入数据库的Java进程。那么有可能文件和数据库连接没有正确关闭，而且数据文件也没有标识是否处理完成，或处理到哪个位置**。



**知识点介绍**

**（1）Java System.exit() 退出程序**

　在java 中退出程序，经常会使用System.exit(1) 或 System.exit(0)，其中返回的status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等。

　　exit(int)方法终止当前正在运行的 Java 虚拟机，参数解释为状态码。根据惯例，非 0 的状态码表示异常终止。 而且，该方法永远不会正常返回。 这是唯一一个能够退出程序并不执行finally的情况。



**（2）Linux kill -9 和 kill -15 的区别**

　kill -9 PID 是操作系统从内核级别强制杀死一个进程.

　kill -15 PID 可以理解为操作系统发送一个通知告诉应用主动关闭.

　SIGNTERM（15） 的效果是正常退出进程，退出前可以被阻塞或回调处理。并且它是Linux缺省的程序中断信号。



**（3）kill -15 pid（默认）**

- 执行完该指令后，操作系统会发送一个 SIGTERM 信号给对应的程序。当程序接收到该信号后，可能会发生以下几种情况的一种：
  - 当前程序立刻停止；
  - 程序释放相应资源，然后再停止；
  - 程序可能仍然继续运行。

大部分程序会先释放自己的资源，然后再停止。但是也有程序可以在接受到信号量后，继续做其他一些事情，并且这些事情是可以配置的。如果程序正在等待IO，可能就不会立马做出响应。也就是说，`15) SIGTERM` 是可能被阻塞、被忽略的。



**（4）kill -9 pid**

如果 `15) SIGTERM` 可以不进行响应？那 `9) SIGKILL`就是必杀信号，多半 ROOT 会直接使用这个命令，但并不推荐这么做。



小结：**在使用 `kill -9` 前，应该先使用 `kill -15`，给目标进程一个清理善后工作的机会。如果没有，可能会留下一些不完整的文件或状态，从而影响服务的再次启动。**



**理解停止Java进程的本质**

我们知道，Java程序的运行需要一个运行时环境，即：JVM，启动Java进程即启动了一个JVM。
因此，所谓停止Java进程，本质上就是关闭JVM。
那么，哪些情况会导致JVM关闭呢？

![image-20210802102458134](imgs\575.png)



**那么应该如何正确地停止Java进程呢？**

通常来讲，停止一个进程只需要杀死进程即可。
但是，在某些情况下可能需要在JVM关闭之前执行一些数据保存或者资源释放的工作，此时就不能直接强制杀死Java进程。

1. 对于正常关闭或异常关闭的几种情况，JVM关闭前，都会调用已注册的关闭钩子，基于这种机制，我们可以将扫尾的工作放在关闭钩子中，进而使我们的应用程序安全的退出。而且，基于平台通用性的考虑，更推荐应用**程序使用System.exit(0)**这种方式退出JVM。
2. 对于强制关闭的几种情况：`系统关机`，操作系统会通知JVM进程等待关闭，一旦等待超时，系统会强制中止JVM进程；而`kill -9`、`Runtime.halt()`、`断电`、`系统crash`这些方式会直接无商量中止JVM进程，JVM完全没有执行扫尾工作的机会。

综上所述：

1. 除非非常确定不需要在Java进程退出之前执行收尾的工作，否则强烈不建议使用`kill -9`这种简单暴力的方式强制停止Java进程（除了`系统关机`，`系统Crash`，`断电`，和`Runtime.halt()`我们无能为力之外）。
2. 不论如何，都应该在Java进程中注册关闭钩子，尽最大可能地保证在Java进程退出之前做一些善后的事情（实际上，大多数时候都需要这样做）。





### 1.Linux中常用的锁？

- **自旋锁spinlock**

自旋锁的主要特征是使用者在想要获得临界区执行权限时，如果临界区已经被加锁，那么自旋锁并不会阻塞睡眠，等待系统来主动唤醒，而是原地忙轮询资源是否被释放加锁，自旋就是自我旋转，这个名字还是很形象的。自旋锁有它的优点就是避免了系统的唤醒，自己来执行轮询，如果在临界区的资源代码非常短且是原子的，那么使用起来是非常方便的，避免了各种上下文切换，开销非常小，因此在内核的一些数据结构中自旋锁被广泛的使用。

- **互斥锁mutex**

使用者使用互斥锁时在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作，谁加锁谁释放，其他使用者没有释放权限。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。 区别于自旋锁，互斥锁无法获取锁时将阻塞睡眠，需要系统来唤醒，可以看出来自旋转自己原地旋转来确定锁被释放了，互斥锁由系统来唤醒，但是现实并不是那么美好的，因为很多业务逻辑系统是不知道的，仍然需要业务线程执行while来轮询是否可以重新加锁。考虑这种情况：解锁时有多个线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待，对其他线程而言就是虚假唤醒。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源。

- **读写锁rwlock**

读写锁也叫共享互斥锁：读模式共享和写模式互斥，本质上这种非常合理，因为在数据没有被写的前提下，多个使用者读取时完全不需要加锁的。读写锁有读加锁状态、写加锁状态和不加锁状态三种状态，当读写锁在写加锁模式下，任何试图对这个锁进行加锁的线程都会被阻塞，直到写进程对其解锁。

**读优先的读写锁**：读写锁rwlock默认的也是读优先，也就是:当读写锁在读加锁模式先，任何线程都可以对其进行读加锁操作，但是所有试图进行写加锁操作的线程都会被阻塞，直到所有的读线程都解锁，因此读写锁很适合读次数远远大于写的情况。这种情况需要考虑写饥饿问题，也就是大量的读一直轮不到写，因此需要设置公平的读写策略。在一次面试中曾经问到实现一个写优先级的读写锁，感兴趣的可以想想如何实现。

- **RCU锁**

RCU锁是读写锁的扩展版本，简单来说就是支持多读多写同时加锁，多读没什么好说的，但是对于多写同时加锁，还是存在一些技术挑战的。RCU锁翻译为Read Copy Update Lock，读-拷贝-更新 锁。Copy拷贝：写者在访问临界区时，写者将先拷贝一个临界区副本，然后对副本进行修改；Update更新：RCU机制将在在适当时机使用一个回调函数把指向原来临界区的指针重新指向新的被修改的临界区，锁机制中的垃圾收集器负责回调函数的调用。更新时机：没有CPU再去操作这段被RCU保护的临界区后，这段临界区即可回收了，此时回调函数即被调用。从实现逻辑来看，RCU锁在多个写者之间的同步开销还是比较大的，涉及到多份数据拷贝，回调函数等，因此这种锁机制的使用范围比较窄，适用于读多写少的情况，如网络路由表的查询更新、设备状态表更新等，在业务开发中使用不是很多。

- **可重入锁和不可重入锁**
- 递归锁recursive mutex 可重入锁(reentrant mutex)
- 非递归锁non-recursive mutex 不可重入锁(non-reentrant mutex)

### 1.你常用的Linux命令有哪些？

**追踪一个命令是如何实现的，比如linux的动不了动不了tail -n是如何快速读取到文件的最后n行数据的呢？**

`strace tail -1000 test.log 2>&1  grep lseek`



**求助命令：** `--help` 和`man`

**文件目录的基本操作：** `ls` 、`cd`、`rmdir`、`mkdir`、`cp`、`mv`  、`chmod`

其中chmod分别是r4 w2 x1 chmod754 .bashrc

**获取文件内容**：`cat` 、`head`、`find`

其中find [basedir] [options] `find . -name 'shadow*'`

**压缩打包命令：** 压缩命令`gzip`  打包`tar`

**查看进程：** `ps`查看自己的**进程**     `top` 实时**显示进程**的信息 `netstat`查看**占用端口**的进程

**正则表达式：** 

- `grep`使用正则表达式进行全局查询并打印；-n 表示输出行号

  - 示例：把含有the字符串的行提取出来`grep -n 'the' regular_express.txt`。
  - 此外正则表达式a{m,n}用来匹配字符a出现m~n次。`grep -n 'a\{2,5\}' regular_express.txt`

- `awk`: awk每次处理一行，处理的最小单位是字段。每个字段的命名方式为：$n. n为字段号，从1开始。`$ awk '条件类型 1 {动作 1} 条件类型 2 {动作 2} ...' filename`

  - 示例：取出最近五个登录用户的用户名和IP。首先用last -n 5 去除最近五个登录用户的所有信息，用户名和IP分别在第一列和第三列。`last -n 5 | awk '{print $1 "\t" $3}' `
  - 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。

  ```shell
  $ cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'
  ```

  awk 变量：

  | 变量名称 | 代表意义                     |
  | -------- | ---------------------------- |
  | NF       | 每一行拥有的字段总数         |
  | NR       | 目前所处理的是第几行数据     |
  | FS       | 目前的分隔字符，默认是空格键 |

  - 示例：显示正在处理的行号以及每一行有多少字段

  ```shell
  $ last -n 5 | awk '{print $1 "\t lines: " NR "\t columns: " NF}'
  ```

### 1.linux中查看磁盘使用情况的命令

**a.统计磁盘整体情况，包括磁盘大小，已使用，可使用。命令的话df**

命令"df -lh"使用这个命令会更清楚磁盘使用情况

![image-20210507154259561](imgs/197.png)



**b.具体查看文件夹的占用情况**

du -sh directory

查看当前目录下的directory的目录的容量




### 2.用过vim编辑器？

vim编辑器一般是三个模式：

- **一般指令模式**：VIM的默认模式，可以用于移动游标来查看内容；
- **编辑模式**：按下“i”等按键之后进入，可以对文本进行编辑；
- **指令模式**：按下":"之后，用于保存退出等操作；

### 2.Linux 百G级别文件，命令行快速删除文件末尾几行

采用dd指令
格式为dd of=<filename> seek=1 bs=$(($(stat -c%s <filename>)-$(tail <deleterows> <filename>|wc -c))) 处填入要操作的文件名 处填入要删除的行数

仅对于最后一行的删除可以在一秒内完成采用dd指令
格式为
`dd of=<filename> seek=1 bs=$(($(stat -c%s <filename>)-$(tail <deleterows> <filename>|wc -c)))`
处填入要操作的文件名
处填入要删除的行数

仅对于最后一行的删除可以在一秒内完成。

head 和管道， sed等都可以完成这个任务。但是效率非常低，因为他们都需要遍历整个文件。

Oracle Linux带了Truncate命令。

truncate --size=

计算出删除的行的字节数，并得到新的文件大小。新文件的大小作为第一个参数传入。

在笔者的机器上，1.9 GB的文件截取最后一行只需几秒钟。非常高效。

```java
/**
 * 读取文件的倒数第3行，并打印其内容
 */
 
import java.io.File;
import java.io.IOException;
 
import org.apache.commons.io.input.ReversedLinesFileReader;
 
public class ReversedLinesFileReaderExample {
 
	public static void main(String[] args) throws IOException {
		File file = new File("D:\\file1.txt");
		int n_lines = 3;
		int counter = 1;
 
		//构造方法 ReversedLinesFileReader(final File file, final int blockSize, final String encoding) 
		ReversedLinesFileReader object = new ReversedLinesFileReader(file, 4096, "UTF-8");
		while (counter <= n_lines) {
			if (counter == n_lines) {
				System.out.println(object.readLine());
			}
			object.readLine();//读取下一行
			counter++;
		}
	}
 
}
```





只是查看：**more filename**

编辑可以用emacs



这时，我们可以利用下面的方法分割文件，然后再打开。

- 查看文件的前多少行

**head -10000 /var/lib/mysql/slowquery.log > temp.log**

上面命令的意思是：把slowquery.log文件前10000行的数据写入到temp.log文件中。

- 查看文件的后多少行

**tail -10000 /var/lib/mysql/slowquery.log > temp.log**

上面命令的意思是：把slowquery.log文件后10000行的数据写入到temp.log文件中。

- 查看文件的几行到几行

**sed -n '10,10000p' /var/lib/mysql/slowquery.log > temp.log**

上面命令的意思是：把slowquery.log文件**第10到10000行的数据写入到temp.log文件中。**

### 2.select和epoll的区别

多路复用模型。

select模型：

![image-20210624143816245](imgs\358.png)

select缺陷：1024个数组的限制；遍历轮询触发找到真正有信号的socket连接；

epoll模型：

![image-20210624144116074](imgs\359.png)

epoll改进：没有1024数组个数的限制；异步回调的方式去执行handler操作；

### 1.父进程与子进程(fork函数)

在linux系统内，创建子进程的方法是使用系统调用fork()函数。fork()函数是Linux系统内一个非常重要的函数，它与我们之前学过的函数有一个显著的区别：fork()函数调用一次却会得到两个返回值。

fork()函数的用法：

    函数fork()
    
    所需头文件：#include<sys/types.h>
    
              #include<unistd.h>
    
    函数原型：pid_t fork()
    
    函数参数：无
    
    函数返回值：
    
         0    子进程
    
        >0    父进程，返回值为创建出的子进程的PID
    
        -1    出错
fork()函数用于从一个已经存在的进程内创建一个新的进程，新的进程称为“子进程”，相应地创建子进程的进程为“父进程”。使用fork()函数得到的子进程是父进程的复制品。**子进程完全了复制了父进程的资源，包括进程上下文、数据区、代码区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息**， 而**子进程与父进程有区别有进程号、资源使用情况和计时器等。**

![img](imgs\394.png)

   由于复制父进程的资源需要大量的操作，十分浪费时间与系统资源，因此**Linux内核采取了写时拷贝技术（copy on write）来提高效率**。

由于子进程几乎对父进程完全复制，因此父子进程会同时运行同一个程序。因此我们需要某种方式来区分父子进程。区分父子进程常见的方法为查看fork()函数的返回值或区分父子进程的PID。

### 2,两台linux服务器之间相互拷贝文件的两个方法

scp是secure copy的简写，用于在linux下进行远程拷贝文件的命令，和它类型的命令有cp，不过cp只是在本机进行拷贝不能跨服务器。







### 2.linux的零拷贝技术是怎么样的？

**（1）术语**

**零拷贝**

“零拷贝”中的“拷贝”是操作系统在I/O操作中，将数据从一个内存区域复制到另外一个内存区域。而“零”并不是0次复制，**更多是指在用户态和内核态之间的复制是0次。**

**CPU COPY**

通过计算机的组成原理我们知道, 内存的读写操作是需要CPU的协调数据总线,地址总线和控制总线来完成的

因此在"拷贝"发生的时候,往往需要CPU暂停现有的处理逻辑,来协助内存的读写.这种我们称为CPU COPY

cpu copy不但占用了CPU资源,还占用了总线的带宽.

**DMA COPY**

DMA(DIRECT MEMORY ACCESS)是现代计算机的重要功能. 它的一个重要 的特点就是, 当需要与外设进行数据交换时, CPU只需要初始化这个动作便可以继续执行其他指令,剩下的数据传输的动作完全由DMA来完成

可以看到DMA COPY是可以避免大量的CPU中断的

**上下文切换**

本文中的上下文切换时指由用户态切换到内核态, 以及由内核态切换到用户态

**（2）存在多次拷贝的原因**

- 操作系统为了保护系统不被应用程序有意或无意地破坏,为操作系统设置了用户态和内核态两种状态.用户态想要获取系统资源(例如访问硬盘), 必须通过系统调用进入到内核态, 由内核态获取到系统资源,再切换回用户态返回应用程序.
- 出于"readahead cache"和异步写入等等性能优化的需要, 操作系统在内核态中也增加了一个"内核缓冲区"(kernel buffer). 读取数据时并不是直接把数据读取到应用程序的buffer, 而先读取到kernel buffer, 再由kernel buffer复制到应用程序的buffer. 因此,数据在被应用程序使用之前,可能需要被多次拷贝

**（3）都有哪些不必要的拷贝**

再回答这个问题之前, 我们先来看一个应用场景

回想现实世界的所有系统中, 不管是web应用服务器, ftp服务器,数据库服务器, 静态文件服务器等等, 所有涉及到数据传输的场景, 无非就一种:

```
从硬盘上读取文件数据, 发送到网络上去.
```

这个场景我们简化为一个模型:

```
 File.read(fileDesc, buf, len);
 Socket.send(socket, buf, len);
```

为了方便描述,上面这两行代码, 我们给它起个名字: read-send模型

操作系统在实现这个read-send模型时,需要有以下步骤:

```
1. 应用程序开始读文件的操作
2. 应用程序发起系统调用, 从用户态切换到内核态(第一次上下文切换)
3. 内核态中把数据从硬盘文件读取到内核中间缓冲区(kernel buf)
4. 数据从内核中间缓冲区(kernel buf)复制到(用户态)应用程序缓冲区(app buf),从内核态切换回到用户态(第二次上下文切换)
5. 应用程序开始发送数据到网络上
6. 应用程序发起系统调用,从用户态切换到内核态(第三次上下文切换)
7. 内核中把数据从应用程序(app buf)的缓冲区复制到socket的缓冲区(socket)
8. 内核中再把数据从socket的缓冲区(socket buf)发送的网卡的缓冲区(NIC buf)上
9. 从内核态切换回到用户态(第四次上下文切换)
```

如下图表示:

![image](imgs\351.jpeg)

由上图可以很清晰地看到, 一次read-send涉及到了四次拷贝:

```
1. 硬盘拷贝到内核缓冲区(DMA COPY)
2. 内核缓冲区拷贝到应用程序缓冲区(CPU COPY)
3. 应用程序缓冲区拷贝到socket缓冲区(CPU COPY)
4. socket buf拷贝到网卡的buf(DMA COPY)
```

其中涉及到2次cpu中断, 还有4次的上下文切换

很明显,第2次和第3次的的copy只是把数据复制到app buffer又原封不动的复制回来, 为此带来了两次的cpu copy和两次上下文切换, 是完全没有必要的

**linux的零拷贝技术就是为了优化掉这两次不必要的拷贝**

**（4）sendFile**

linux内核2.1开始引入一个叫sendFile系统调用,这个系统调用可以在**内核态内把数据从内核缓冲区直接复制到套接字(SOCKET)缓冲区内**, 从而可以减少上下文的切换和不必要数据的复制。

这个系统调用其实就是一个高级I/O函数, 函数签名如下:

```
#include<sys/sendfile.h>
ssize_t senfile(int out_fd,int in_fd,off_t* offset,size_t count);
```

1. out_fd是写出的文件描述符,而且必须是一个socket
2. in_fd是读取内容的文件描述符,必须是一个真实的文件, 不能是管道或socket
3. offset是开始读的位置
4. count是将要读取的字节数

有了sendFile这个系统调用后, 我们read-send模型就可以简化为:

```
1. 应用程序开始读文件的操作
2. 应用程序发起系统调用, 从用户态切换到内核态(第一次上下文切换)
3. 内核态中把数据从硬盘文件读取到内核中间缓冲区
4. 通过sendFile,在内核态中把数据从内核缓冲区复制到socket的缓冲区
5. 内核中再把数据从socket的缓冲区发送的网卡的buf上
6. 从内核态切换到用户态(第二次上下文切换)
```

如下图所示: 

![img](imgs\352.png)

涉及到数据拷贝变成:

```
1. 硬盘拷贝到内核缓冲区(DMA COPY)
2. 内核缓冲区拷贝到socket缓冲区(CPU COPY)
3. socket缓冲区拷贝到网卡的buf(DMA COPY)
```

可以看到,一次read-send模型中, 利用sendFile系统调用后, 可以将4次数据拷贝减少到3次, 4次上下文切换减少到2次, 2次CPU中断减少到1次。

相对传统I/O, 这种零拷贝技术通过减少两次上下文切换, 1次cpu copy, 可以将I/O性能提高50%以上(网络数据, 未亲测)

开始的术语中说到, 所谓的零拷贝的"零", 是指用户态和内核态之间的拷贝次数为0, 从这个定义上来说, 现在的这个零拷贝技术已经是真正的"零"了。

然而, 对性能追求极致的伟大的科学家和工程师们并不满足于此. 精益求精的他们对中间第2次的cpu copy依旧耿耿于怀, 想尽千方百计要去掉这一次没有必要的数据拷贝和CPU中断。

**（5）支持scatter-gather特性的sendFile**



在内核2.4以后的版本中, linux内核对socket缓冲区描述符做了优化. 通过这次优化, sendFile系统调用可以在只复制kernel buffer的少量元信息的基础上, 把数据直接从kernel buffer 复制到网卡的buffer中去.从而避免了从"内核缓冲区"拷贝到"socket缓冲区"的这一次拷贝.

这个优化后的sendFile, 我们称之为支持scatter-gather特性的sendFile

在支持scatter-gather特性的sendFile的支撑下, 我们的read-send模型可以优化为:

```
1. 应用程序开始读文件的操作
2. 应用程序发起系统调用, 从用户态进入到内核态(第一次上下文切换)
3. 内核态中把数据从硬盘文件读取到内核中间缓冲区
4. 内核态中把数据在内核缓冲区的位置(offset)和数据大小(size)两个信息追加(append)到socket的缓冲区中去
5. 网卡的buf上根据socekt缓冲区的offset和size从内核缓冲区中直接拷贝数据
6. 从内核态返回到用户态(第二次上下文切换)
```

这个过程如下图所示:

![img](imgs\353.png)

最后数据拷贝变成只有两次DMA COPY:

```
1. 硬盘拷贝到内核缓冲区(DMA COPY)
2. 内核缓冲区拷贝到网卡的buf(DMA COPY)
```

**mmap的方式**

### 2.（最终解释篇- 同步、异步、阻塞、非阻塞IO）- 面试高频

>  个人理解：同步和异步：一个是**等待IO事件准备好**；另外一个是数据直接准备好了；阻塞和非阻塞的区别是：**阻塞是两步并成一步**了，非阻塞还是**两步单独处理**。

#### 2.1 IO操作概念

在Unix系统中，一切都是文件。文件就是流的概念，在进行信息的交流过程中，对这些流进行数据的收发操作就是IO操作

> 我们都知道unix(like)世界里，**一切皆文件，而文件是什么呢**？**文件就是一串二进制流而已**，不管socket, 还是FIFO、管道、终端，对我们来说，一切都是文件，一切都是流。**在信息 交换的过程中，我们都是对这些流进行数据的收发操作，简称为I/O操作**(input and output)，往流中读出数据，系统调用read，写入数据，系统调用write。不过话说回来了 ，**计算机里有这么多的流，我怎么知道要操作哪个流呢**？对，**就是文件描述符，即通常所说的fd，一个fd就是一个整数，所以，对这个整数的操作**，就是对这个**文件（流）的操作**。我们**创建一个socket,通过系统调用会返回一个文件描述符，那么剩下对socket的操作就会转化为对这个描述符的操作**。不能不说这又是一种分层和抽象的思想。
>

#### 2.2 同步、异步、阻塞、非阻塞

在比较这两个模式之前，我们首先的搞明白几个概念，什么是**阻塞和非阻塞，什么是同步和异步。**



同步和异步是针对**应用程序和内核的交互**而言的，**同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪**。**异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知。**

而阻塞和非阻塞是针对于**进程在访问数据**的时候，**阻塞方式下读取或者写入函数将一直等待**。而**非阻塞方式下，读取或者写入函数会立即返回一个状态值。**

一般来说I/O模型可以分为：**同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO。**

#### 2.3 同步IO模型

[链接](https://www.pianshen.com/article/41501819743/)

##### 2.3.1 阻塞IO模型

> 缺省情况下，所有文件操作都是阻塞的。我们以套接字接口为例讲解此模型：在进程空间中调用 recvfrom，其系统调用知道数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回，在此期间一直会等待，**进程在从调用 recvfrom 开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞 I/O 模型**。

**所有套接字默认的都是阻塞的**，以recvfrom系统调用为例子，**它要等到有数据报到达且被复制到应用进程的缓冲区中或者发生了错误才返回。若没有数据到达那么将一直会阻塞。**

![image-20210710164227211](imgs\437.png)

##### 2.3.2 非阻塞模型

> 非阻塞 I/O 模型：recvfrom 从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个 EWOULDBLOCK 错误，一般都对非阻塞 I/O 模型进行轮询检查这个状态，看内核是不是有数据到来。

进程将一个**套接字设置为非阻塞就是通知内核**：**当前所请求的IO操作在请求的过程不需要把进程投入睡眠，而是返回一个错误**。（注意这里是指请求IO操作，不是进行IO操作）

![image-20210710164400881](imgs\438.png)

**当一个应用进程循环调用recvfrom的时候，这种操作叫做轮询**。应用进程轮询内核，检查某个操作是否准备就绪，**当IO操作准备就绪可以操作的时候就会进行真正的IO操作**，就是**将数据从内核写入用户空间的过程**。但是这样做会导致CPU的大量耗费。

##### 2.3.3 IO复用模型（多路复用模型-一个线程内同时处理多个socket的IO请求）

> Linux 提供 select/poll 进程通过将一个或多个 fd 传递给 select 或 poll 系统调用，阻塞在 select 操作上，**这样 select/poll 可以帮我们侦测多个 fd 是否处于就绪状态。**select/poll 是顺序扫描 fd 是否就绪，而且支持的 fd 数量有限，因此它的使用收到了一下制约。Linux 还提供了**一个 epoll 系统调用，epoll 使用基于事件驱动方式代替顺序扫描，因此性能更高。当有 fd 就绪时，立刻回调函数 rollback。**

**系统调用select、poll、epoll、kqueue实现IO复用模型**。此时进程就会组赛在这些系统调用上，而不是阻塞在真正的IO操作上，直到**有就绪事件了，这些系统调用就会返回哪些套接字可读写，然后就可以进行把数据包复制到应用进程缓冲区了**。IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，**使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。**

>  从流程上来看，**使用select函数进行IO请求和同步阻塞模型没有太大的区别，甚至还多了添加监视socket**，以及调用select函数的额外操作，效率更差。但是，使用select以后最大的优势是用户可以在**一个线程内同时处理多个socket的IO请求**。**用户可以注册多个socket，然后不断地调用select读取被激活的socket**，即可达到在同一个线程内同时处理多个IO请求的目的。而**在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。**

其中**select是通过不断的轮询，查看是否有就绪事件。**如果有的话，再把所有的流遍历一遍看是哪个流准备就绪。而poll也是采用这样的轮询，只不过poll采用的是链表存储，所以没有最大连接数的限制，**epoll是even poll**，和忙轮询、无差别轮询不一样，它会把哪个流发生了怎样的I/O事件通知我们，不用全都遍历一遍才知道是哪个流发生了。所以我们说**epoll实际上是事件驱动（每个事件关联上fd）**的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)），而select和poll查找复杂度都是O(n)。


![image-20210710165333889](imgs\439.png)

##### 2.3.4 信号驱动式IO模型

> 首先开启套接口信号驱动 I/O 功能，并通过系统调用 sigaction 执行一个信号处理函数（此系统调用立刻返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个 SIGIO 信号，通过信号回调通知应用程序调用 recvfrom 来读取数据，并通知主循环函数处理数据。

我们也可以用**信号让内核在文件描述符准备就绪的时候通知用户进程，即是告知我们什么时候可以启动IO操作**。就如数据准备好了，内核就会以一种形式通知用户进程。

![image-20210710165605172](imgs\440.png)

这种模型的优势就在于数据到达之前不被阻塞，**主循环可以继续执行，用户进程只需要等到着来自信号的处理函数的通知即可**，其中既可以是数据已准备好被处理，也可以是数据报已准备好被读取。



#### 2.4 异步IO模型

> 告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：**信号驱动 I/O 由内核通知我们何时可以开始一个 I/O 操作**；而**异步 I/O 模型由内核通知我们 I/O 操作何时已经完成。**

异步IO由POSIX规范定义的。一般地说，这些函数的工作机制就是：由用户进程告知内核启动一个操作，并且由内核去操作，操作完后给用户进程发一个通知，通知用户进程操作完了（包括数据从内核缓冲区拷贝到用户缓冲区的过程）。该模型与信号驱动式IO模型不同的就是，**异步IO模型中，是由内核通知IO操作什么时候完成**，而**信号驱动式IO是由内核告知何时启动IO操作。**

![image-20210710165819519](imgs\441.png)

#### 2.5 各种IO模型异同对比

![image-20210710165943749](imgs\442.png)

#### 2.6 Java的NIO编程

在 NIOServer 中，会创建并打开两个 Selector ，**Selecotr 是 Java NIO 中的核心组件，底层利用的是 I/O 多路复用模型。**

- 一个 Selector 负责监听 ServerSocketChannel 中的客户端连接请求，如果有新的客户端请求连接，那么就会创建对应的 SocketChannel，然后往另外一个 Selector 中注册；如果没有，则直接返回，不会在这里阻塞着，进程可以继续做别的事情，所以 NIO 是同步非阻塞。
- 第二个 Selecotr，就是负责监听哪些 SocketChannel 有读写事件，如果有的话则进行对应的 I/O 操作；而如果没有，也是直接返回，不会在这里一直阻塞着，进程可以继续做别的事情，所以 NIO 是同步非阻塞。

在 Java NIO 中，不管是服务端还是客户端，都会将自己注册到 Selector 中，如果哪个 Channel 有请求连接事件（ ServerSocketChannel）或者是读写事件（SocketChannel），那么这个 Channel
就会处于就绪状态；接着会被 Selector 轮询出来，进行后续的 I/O 操作。这就不会出现 IO 编程中的阻塞状态，所以 NIO 是同步非阻塞的。

### 2.多路复用io的种类

多路复用是把**多个io的阻塞转变为同一个select上的阻塞**.从而使得系统可以**在单线程的情况下处理多个客户端请求.**

#### 2.1 select函数

 Select在Socket编程中还是比较重要的，可是对于初学Socket的人来说都不太爱用Select写程序，他们只是习惯写诸如connect、 accept、recv或recvfrom这样的阻塞程序（所谓阻塞方式block，顾名思义，就是进程或是线程执行到这些函数时必须等待某个事件的发 生，如果事件没有发生，进程或线程就被阻塞，函数不能立即返回）。

![image-20210710183135023](imgs\446.png) 

  **可是使用Select就可以完成非阻塞（所谓非阻塞方式non-block，就是进程或线程执行此函数时不必非要等待事件的发生，一旦执行肯定返回，以返 回值的不同来反映函数的执行情况**，如果事件发生则与阻塞方式相同，若事件没有发生则返回一个代码来告知事件未发生，而进程或线程继续执行，所以效率较高） 方式工作的程序，**它能够监视我们需要监视的文件描述符的变化情况--读写或是异常。** 

```c
int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); 
```

**select函数是用来监视一个或多个文件句柄的状态变化的，可阻塞也可不阻塞**。

**fd_max： **传入的监视文件描述符集合中最大的文件描述符数值 + 1，因为select是从0开始一直遍历到数值最大的标识符。
**readfds ：**文件描述符集合，检查该组文件描述符的可读性。
**writefds： **文件描述符集合，检查该组文件描述符的可写性。
**exceptfds：** 文件描述符集合，检查该组文件描述符的异常条件。**timeout：** 时间结构体

```C
struct timeval {
	time_t tv_sec;     /* 秒 */
	time_t tv_usec;    /* 微秒 */
};
```

- timeout的值为NULL，则将select()函数置为**阻塞状态，当监视的文件描述符集合中的某一个描述符发生变化才会返回结果并向下执行。**
- timeout的值等于0，则将**select()函数置为非阻塞状态，执行select()后立即返回，无论文件描述符是否发生变化**。
- timeout的值大于0，则将**select()函数的超时时间设为这个值，在超时时间内阻塞，超时后返回结果**。

**返回值：**

- -1：发生错误，并将所有描述符集合清0，可通过errno输出错误详情。
- 0：超时。
- 正数：发生变化的文件描述符数量。

**缺点：**

**文件描述符大小限制，在 Linux 上一般为 1024/ 每次都要遍历文件描述符set**；

#### 2.2 poll函数

```c
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

**作用：**

监视并等待多个文件描述符的属性变化
**参数：**

- fds:指向一个结构体数组的第0个元素的指针，每个数组元素都是一个struct pollfd结构，用于指定测试某个给定的fd的条件

```java
struct pollfd{
	int fd;			//文件描述符
	short events;	//等待的事件
	short revents;	//实际发生的事件
};
```

- fd：每一个 pollfd 结构体指定了一个被监视的文件描述符，可以传递多个结构体，指示 poll() 监视多个文件描述符。 

- events：指定监测fd的事件（输入、输出、错误），每一个事件有多个取值，如下：
- ![image-20210710185034306](imgs\447.png)

- revents：revents 域是文件描述符的操作结果事件，内核在调用返回时设置这个域。events 域中请求的任何事件都可能在 revents 域中返回.

- nfds:用来指定第一个参数数组元素个数 

- timeout: 指定等待的毫秒数，无论 I/O 是否准备好，poll() 都会返回.

![img](imgs\448.png)

#### 2.3 epoll函数

epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。**epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中**，这样**在用户空间和内核空间的copy只需一次。**


**epoll操作过程**

epoll操作过程需要三个接口，分别如下：

```java
int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

**(1) int epoll_create(int size);**

​    创建一个epoll的句柄，**size用来告诉内核这个监听的数目一共有多大**，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，**参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。**

当创建好epoll句柄后，它就会占用一个**fd值**，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。


**(2)epoll_ctl**

```c
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

epoll的**事件注册函数**，它不同于select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。

第一个参数是epoll_create()的返回值。

第二个参数表示动作，用三个宏来表示：

EPOLL_CTL_ADD：注册新的fd到epfd中；

EPOLL_CTL_MOD：修改已经注册的fd的监听事件；

EPOLL_CTL_DEL：从epfd中删除一个fd；

第三个参数是需要监听的fd。

第四个参数是告诉内核需要监听什么事，struct epoll_event结构如下：

//保存触发事件的某个文件描述符相关的数据（与具体使用方式有关）

```cpp
typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
} epoll_data_t;
 //感兴趣的事件和被触发的事件
struct epoll_event {
    __uint32_t events; /* Epoll events */
    epoll_data_t data; /* User data variable */
};
```

events可以是以下几个宏的集合：

EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；

EPOLLOUT：表示对应的文件描述符可以写；

EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；

EPOLLERR：表示对应的文件描述符发生错误；

EPOLLHUP：表示对应的文件描述符被挂断；

EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。

EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里.

**(3)epoll_wait**

```c
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```

等待epfd上的io事件，最多返回maxevents个事件。

参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。

### 2.IO多路复用之触发方式

IO多路复用应用场景很广，在将待监控的FD加入EPOLL（select、pool）时，可以设置两种事件触发模式：

**使用水平触发和边缘触发通知模型支持情况**

I/o 模型                                    水平触发                            边缘触发

select，poll                             支持                                   不支持

信号驱动I/o                              不支持                                支持

epoll                                          支持                                   支持

边缘触发、水平触发都是针对单个文件描述符（套接字FD）的事件监控方式来说的、设置的。在通过IO多路复用机制进行轮询对应fd待监控的事件时，通过在添加FD时设置事件就绪的触发方式：水平方式或边缘触发。不设置的话，默认是水平触发方式。

- **水平触发 (level-trggered)**
  只要文件描述符关联的读内核缓冲区**非空**，**有数据可以读取**，**就一直发出可读信号进行通知，**
  当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知
  LT 模式支持阻塞和非阻塞两种方式。epoll 默认的模式是 LT。

- **边缘触发 (edge-triggered)**
  当文件描述符关联的读内核缓冲区**由空转化为非空的时候**，则**发出可读信号进行通知**，
  当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知

#### 2.1 两者的区别在哪里呢？
**水平触发是只要读缓冲区有数据，就会一直触发可读信号，而边缘触发仅仅在空变为非空的时候通知一次**，LT (level triggered) 是缺省的工作方式，并且同时支持 block 和 no-block socket. 在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的 select/poll 都是这种模型的代表．



**水平触发**

**如果文件描述符上可以非阻塞地执行I/O系统调用，此时认为它已经就绪，触发通知**.
在网络服务器的开发中，假如我们以水平触发模式的io多路复用来同时监控多个已连接描述符，当某一描述符上有数据可读的时候，就会触发通知(一般来说，就是相应调用返回)。应用程序在**收到通知后可以选择读取所有可读的数据，读取部分数据，甚至是不读取任何数据**。对于读取部分数据和不读取任何数据这种处理方式中，当**下一次检查的时候，该文件描述符还是被返回(尽管在这一段时间内，该文件描述符上没有任何新的时间发生)**，被返回的原因则是该文件描述符上仍然有数据可读，即仍然可以在其上非阻塞的执行`read()`。也就是说，在**水平触发模式中，当前事件的消息不一定必须要当前读取完毕，留到之后读取也没有关系。**

 

**边缘触发**

**如果文件描述符自上次状态检查以来有了新的I/O活动(比如新的输入，用于写入的缓冲区腾出了空间等)，此时需要触发通知。**

仍然以网络服务器开发为例，这次我们使用边缘触发，当某一文件描述符上有数据可读，假如我们仍然是部分读取数据，那么在下一次检查的时候，我们将得不到该文件描述符已经ready的通知(除非在这一段时间内，该描述符上面有新的数据到来)。边缘触发只有在有新的i/o活动的时候才会触发通知，及时当前套接字上有数据，可以非阻塞的执行I/O系统调用，应用程序也得不到通知。也就是说，在**边缘触发模式中，在一次通知中，我们应该尽可能的多的读取数据，直到不能再读为止**。具体的做法是这样的:文件描述符应该提前设置问非阻塞(`O_NONBLOCK`),在已就绪文件描述符上循环的读取数据，知道`read()`返回`-1`，并且`erron`为`EAGAIN`或`EWOULDBLOCK`.



在上面我们对水平触发和边缘触发的分析中，我们可以知道**边缘触发相比于水平触发来讲，降低了同一个事件被重复触发的概率，减少了多路复用系统调用的次数，因此边缘触发的性能由于水平触发。**

在我们常用的io多路复用系统调用中，`select`和`poll`只支持水平触发，`epoll`则既支持水平触发也支持边缘触发。



#### 2.2 例子

第一个栗子：一个管道收到了 1kb 的数据，这时如果是水平触发的，epoll 会立即返回，因为有数据准备好了。如果是边缘触发的不会立即返回，因为此时虽然有数据可读但是已经触发了一次通知，在这次通知到现在还没有新的数据到来，直到有新的数据到来 epoll 才会返回，此时老的数据和新的数据都可以读取到 (当然是需要这次你尽可能的多读取).


#### 2.3 应用

select和poll使用水平触发模式。

epoll使用水平和边缘触发模式。

**redis使用LT水平触发模式**。

**nginx使用ET边沿触发模式。**



1.对于监听的 sockfd，最好使用水平触发模式，边缘触发模式会导致高并发情况下，有的客户端会连接不上。如果非要使用边缘触发，可以用 while 来循环 accept()。

2.对于读写的 connfd，水平触发模式下，阻塞和非阻塞效果都一样，建议设置非阻塞。

3. 对于读写的 connfd，边缘触发模式下，必须使用非阻塞 IO，并要求一次性地完整读写全部数据。

### 2.Redis为什么这么快？单线程下这么快的原因是多路复用？

> Redis实际上并不是单线程的，只是处理用户请求是单线程来处理，保证了处理的顺序性（每个连接内的命令顺序执行），所以一般称为单线程的。

操作系统都有kernel，每个client连接都会先连接到kernel，Redis进程与内核之间使用的是`epoll`，非阻塞多路复用，`epoll`是系统内核提供的一种系统调用，来遍历多个client连接，谁有请求就处理谁。

***4\***|***1\*****插曲（内核演变过程）**

1. **BIO**：早期的BIO模型，客户端连接系统内核后，线程从内核中读取文件，只能是`read`读取(`socket blocking`)，如果没有数据，则会一直阻塞，所以只能开辟多个线程/进程处理。如果只有一个`cpu`的话，某一时间片上的某一时间点的`cpu`是空闲的，并不是一直在处理，导致资源浪费，线程过多的话，切换上下文需要成本，硬件没有被充分利用。**问题：上下文切换成本高，资源浪费**。

   > Linux系统中一切皆文件，都由文件描述符`fd`(file descriptor)来表示，0是标准输入，1是标准输出，2是错误输出，再开启新的IO会产生更多的描述符

   [![BIO](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102730BIO.png)](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102730BIO.png)

2. **NIO**：于是内核发生变化，内核中的socket可以是non-block的，此时只需要一个线程/进程处理，轮询文件描述符，轮询发生在用户空间。此时是同步非阻塞`NIO`。**此时出现了一个成本问题，如果有1000个`fd`，用户进程需要调用1000次kernel。**

   [![NIO](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102757NIO.png)](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102757NIO.png)

3. **多路复用NIO**：于是内核继续升级，内核增加了一个系统调用`select`，（用`man`指令看`select`），支持一次性传多个`fds`，把1000个`fd`传给kernel之后，由kernel来确定哪些连接建立，然后再返回给线程/进程，此时再循环去读返回的`fds`。此时为多路复用`NIO`。**此时的问题是，用户态和内核态之间 `fd`拷来拷去。 **

   [![多路复用NIO](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102808%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8NIO.png)](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102808多路复用NIO.png)

4. **共享空间**：进程有进程的内存空间，内核有内核的内存空间，进程是无法访问内核空间的，所以内核提供了系统调用方法。为了解决这个问题，于是内核与用户之间有了共享空间，系统调用为`mmap`内存映射，共享空间数据结构为红黑树+链表，线程/进程就可以把之前的1000个`fds`放到共享空间（红黑树）中，然后kernel从中读取`fd`通过所有的IO处理，把准备好的数据放到链表里，上层用户空间就可以直接从链表中读取。

   [![共享空间](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102814%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4.png)](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_200316102814共享空间.png)

**插曲中的插曲：零拷贝**

网卡、文件都有IO，传统的用户去读写的时候，是先从kernel中read数据，再write到kernel，这个过程会有数据拷贝。内核提供了一个`sendfile`的系统调用，直接把out、in一块传入，由kernel直接读写，实现零拷贝。

[![0拷贝](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_2003161028210%E6%8B%B7%E8%B4%9D.png)](https://images.cnblogs.com/cnblogs_com/tobyhomels/1671916/o_2003161028210拷贝.png)

***4\***|***2\*****epoll的两种触发方式**

epoll监控多个文件描述符的I/O事件。epoll支持边缘触发(edge trigger，ET)或水平触发（level trigger，LT)，通过epoll_wait等待I/O事件，如果当前没有可用的事件则阻塞调用线程。

**select和poll只支持LT工作模式，epoll的默认的工作模式是LT模式。**

1. 水平触发的时机

   对于读操作，只要缓冲内容不为空，LT模式返回读就绪。
   对于写操作，只要缓冲区还不满，LT模式会返回写就绪。
   当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据一次性全部读写完(如读写缓冲区太小)，那么下次调用 epoll_wait()时，它还会通知你在上没读写完的文件描述符上继续读写，当然如果你一直不去读写，它会一直通知你。如果系统中有大量你不需要读写的就绪文件描述符，而它们每次都会返回，这样会大大降低处理程序检索自己关心的就绪文件描述符的效率。

2. 边缘触发的时机

   - 对于读操作
     - 当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。
     - 当有新数据到达时，即缓冲区中的待读数据变多的时候。
     - 当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时。
   - 对于写操作
     - 当缓冲区由不可写变为可写时。
     - 当有旧数据被发送走，即缓冲区中的内容变少的时候。
     - 当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时。
     - 当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。

在ET模式下， 缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。

> 举例1：

> 读缓冲区刚开始是空的
> 读缓冲区写入2KB数据
> 水平触发和边缘触发模式此时都会发出可读信号
> 收到信号通知后，读取了1KB的数据，读缓冲区还剩余1KB数据
> 水平触发会再次进行通知，而边缘触发不会再进行通知
> 举例2：（以脉冲的高低电平为例）
>
> 水平触发：0为无数据，1为有数据。缓冲区有数据则一直为1，则一直触发。
> 边缘触发发：0为无数据，1为有数据，只要在0变到1的上升沿才触发。
> JDK并没有实现边缘触发，Netty重新实现了epoll机制，采用边缘触发方式；另外像Nginx也采用边缘触发。

> JDK在Linux已经默认使用epoll方式，但是JDK的epoll采用的是水平触发，而Netty重新实现了epoll机制，采用边缘触发方式，netty epoll transport 暴露了更多的nio没有的配置参数，如 TCP_CORK, SO_REUSEADDR等等；另外像Nginx也采用边缘触发。

***4\***|***3\*****epoll与select、poll的对比**

1. **用户态将文件描述符传入内核的方式**

   select：**创建3个文件描述符集并拷贝到内核中，分别监听读、写、异常动作。**这里受到单个进程可以打开的fd数量限制，默认是1024。
   poll：将**传入的struct pollfd结构体数组拷贝到内核中进行监听**。
   epoll：执行**epoll_create会在内核的高速cache区中建立一颗红黑树以及就绪链表**(该链表存储已经就绪的文件描述符)。接着**用户执行的epoll_ctl函数添加文件描述符会在红黑树上**增加相应的结点。

2. **内核态检测文件描述符读写状态的方式**

   select：**采用轮询方式**，遍历所有fd，最后返回一个描述符读写操作是否就绪的mask掩码，根据这个掩码给fd_set赋值。
   poll：同样**采用轮询方式**，查询每个fd的状态，如果就绪则在等待队列中加入一项并继续遍历。
   epoll：采用**回调机制**。在执行epoll_ctl的add操作时，不仅将文件描述符放到红黑树上，而且也注册了回调函数，内核在检测到某文件描述符可读/可写时会调用回调函数，该回调函数将文件描述符放在就绪链表中。

3. **找到就绪的文件描述符并传递给用户态的方式**

   select：**将之前传入的fd_set拷贝传出到用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。**
   poll：**将之前传入的fd数组拷贝传出用户态并返回就绪的文件描述符总数。用户态并不知道是哪些文件描述符处于就绪态，需要遍历来判断。**
   epoll：**epoll_wait只用观察就绪链表中有无数据即可，最后将链表的数据返回给数组并返回就绪的数量**。内核将就绪的文件描述符放在传入的数组中，所以只用遍历依次处理即可。这里返回的文件描述符是通过mmap让内核和用户空间共享同一块内存实现传递的，减少了不必要的拷贝。

4. 重复监听的处理方式

   select：将**新的监听文件描述符集合拷贝传入内核中**，继续以上步骤。
   poll：将**新的struct pollfd结构体数组拷贝传入内核中**，继续以上步骤。
   epoll：**无需重新构建红黑树，直接沿用已存在的即可**。

***4\***|***4\*****epoll更高效的原因**

- select和poll的动作基本一致，只是**poll采用链表来进行文件描述符的存储，而select采用fd标注位来存放，所以select会受到最大连接数的限制，而poll不会。**

- select、poll、epoll虽然都会返回就绪的文件描述符数量。但是**select和poll并不会明确指出是哪些文件描述符就绪，而epoll会。造成的区别就是，系统调用返回后，调用select和poll的程序需要遍历监听的整个文件描述符找到是谁处于就绪，而epoll则直接处理即可。**

- select、poll都需要**将有关文件描述符的数据结构拷贝进内核，最后再拷贝出来**。而**epoll创建的有关文件描述符的数据结构本身就存于内核态中，系统调用返回时利用mmap()文件映射内存加速与内核空间的消息传递：即epoll使用mmap减少复制开销。**

- select、poll采用**轮询的方式来检查文件描述符是否处于就绪态**，而epoll采用回调机制。造成的结果就是，随着fd的增加，select和poll的效率会线性降低，而epoll不会受到太大影响，除非活跃的socket很多。

  epoll的边缘触发模式效率高，系统不会充斥大量不关心的就绪文件描述符

> 虽然epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。

### 2.高性能IO设计Reactor和Proactor模式

[链接](https://blog.csdn.net/zpznba/article/details/89084482)

在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，**其中Reactor模式用于同步I/O**，而**Proactor运用于异步I/O操作。**



**典型的多线程服务器得到线程模型**

  最开始的网络编程服务器是用一个while循环来监听新的套接字连接，然后用一个函数处理。这种方法无法并发，效率太低。如果当前请求没有处理完，那后面的只能被阻塞，服务器的吞吐量太低。于是后来采用多线程：

1. 每个请求创建一个线程，使用阻塞式 I/O 操作

   这是最简单的线程模型，1个线程处理1个连接的全部生命周期。该模型的优点在于：这个模型足够简单，它可以实现复杂的业务场景，同时，线程个数是可以远大于CPU个数的。然而，线程个数又不是可以无限增大的，为什么呢？因为线程什么时候执行是由操作系统内核调度算法决定的，调度算法并不会考虑某个线程可能只是为了一个连接服务的，时间片到了就执行一下，哪怕这个线程刚执行一会就又不得不继续睡眠。这样来回的唤醒、睡眠线程在次数不多的情况下，是廉价的，但如果操作系统的线程总数很多时，它就是昂贵的（被放大了），因为这种技术性的调度损耗会影响到线程上执行的业务代码的时间。举个例子，当我们所追求的是并发处理数十万连接，当几千个线程出现时，系统的执行效率就已经无法满足高并发了。换言之，该模型的扩展性及其糟糕，根本无法有效满足高并发，海量连接的业务场景。

2. 使用线程池，同样使用阻塞式 I/O 操作

   这是针对模型1的改进，但仍未从根本上解决问题

3. 使用非阻塞I/O + I/O复用



**两种高效的事件处理模式**

　　对高并发编程，目前只有一种模型，也是本质上唯一有效的玩法。**网络连接上的消息处理，可以分为两个阶段：等待消息准备好、消息处理。**当使用**默认的阻塞套接字时（例如上面提到的1个线程捆绑处理1个连接），往往是把这两个阶段合而为一**，这样操作套接字的代码所在的线程就得睡眠来等待消息准备好，这导致了**高并发下线程会频繁的睡眠、唤醒，从而影响了CPU的使用效率。**

 **高并发编程方法当然就是把两个阶段分开处理。即，等待消息准备好的代码段，与处理消息的代码段是分离的。**当然，这也要求套接字必须是非阻塞的，否则，处理消息的代码段很容易导致条件不满足时，所在线程又进入了睡眠等待阶段。那么问题来了，等待消息准备好这个阶段怎么实现？它毕竟还是等待，这意味着线程还是要睡眠的！**解决办法就是，线程主动查询，或者让1个线程为所有连接而等待**！这就是IO多路复用了。多路复用就是处理等待消息准备好这件事的，但它可以同时处理多个连接！它也可能“等待”，所以它也会导致线程睡眠，然而这不要紧，因为它一对多、它可以监控所有连接。这样，当我们的线程被唤醒执行时，就一定是有一些连接已经准备好被我们的代码执行了。



   作为一个高性能服务器程序通常需要考虑处理三类事件： I/O事件，定时事件及信号。本文将首先首先从整体上介绍两种高效的事件处理模型：Reactor和Proactor。

#### 2.1 Reactor模型

Reactor模式是处理并发I/O比较常见的一种模式，中心思想就是，将所有要处理的I/O事件注册到一个中心I/O多路复用器上，同时主线程阻塞在多路复用器上；一旦有I/O事件到来或是准备就绪(区别在于多路复用器是边沿触发还是水平触发)，多路复用器返回并将相应I/O事件分发到对应的处理器中。

![image-20210710172440509](imgs\443.png)

   Reactor模型有三个重要的组件：

1. **多路复用器**：由操作系统提供，在linux上一般是select, poll, epoll等系统调用。
2. **事件分发器**：将多路复用器中返回的就绪事件分到对应的处理函数中。
3. 事件处理器：负责处理特定事件的处理函数。

**Reactor事件处理机制**

![image-20210710172707947](imgs\444.png)

**读取操作**：

1. 应用程序注册读**就绪事件**和相关联的**事件处理器**

2. **事件分离器**等待事件的发生

3. 当发生**读就需事件**的时候，**事件分离器调用第一步注册的事件处理器**

4. **事件处理器首先执行实际的读取操作**，然后**根据读取到的内容进行进一步的处理**

#### 2.2 Proactror

**Proactor模型执行流程**

![image-20210710173015602](imgs\445.png)

1. 应用程序初始化**一个异步读取操**作，然后**注册相应的事件处理器**，此时**事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。**
2. **事件分离器等待**读取操作完成**事件**；
3. 在事件分离器等待读取操作完成的时候，**操作系统调用内核线程完成读取操作，并将读取的内容放入用户传递过来的缓存区中**。这也是区别于Reactor的一点**，Proactor中，应用程序需要传递缓存区。**
4. **事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据**，而不需要进行实际的读取操作。



从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，**Reactor中需要应用程序自己读取或者写入数据**，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，**操作系统会读取缓存区或者写入缓存区到真正的IO设备.**









###  2.Nginx网络IO模型(同步异步 阻塞和非阻塞)

同步和异步描述的是**用户线程**与**内核**的交互方式。

同步：当一个同步调用发出去后，调用者要一直等待调用的结果通知后(反馈)，才能进行后续的执行。

异步：当一个**异步调用**发出去后，调用者**不必一直等待**调用结果的返回(**干其它事**)，当**有结果返回**，**再接受结果**！

阻塞：调用在发出去后(***\*发出调用请求\****)，在消息返回之前，当前进/线程***\*会被挂起\****，**直到有消息返回**，当前进/线程***\*才会被激活，处理返回的值\****

**非阻塞**：**调用**在发出去后，**并不会停下来**等待请求的***\*回执\****，不会阻塞当前进/线程，而会立即返回(**干别的事情**)，当调用的结果返回才激活其它线程或**当前****线程来处理**！



总之：

同步与异步的重点在于**消息通知的方式**；阻塞与非阻塞 重点在于**等消息时候的行为**；

例子：

同步阻塞：小明收到信息后，啥都不干，**在楼下**等快递；

同步非阻塞：小明收到信息后，边刷微博，**在楼下(等快递的地方)站着**着取快递；

异步阻塞：小明收到信息后，**在楼上**啥都不干，一直**等着快递员通知**他取快递；

异步非阻塞：小明收到信息后，在**楼上**边刷着微博，边**等快递员通知**他取快递。

##########################################################

生产环境中大部分数据处理模式：同步阻塞(Apache)和异步非阻塞(Nginx);

大部分程序的IO模型都是**同步阻塞**的，**单个进程每次只在一个文件描述符上执行I/O操作**，每次**I/O系统调用都会阻塞**，直到完成数据传输，才会进行下一个任务的执行。而传统的服务器采用的就是**同步阻塞的多进程模型**：**一个server采用 一个进程负责一个request的方式**，直到会话结束。进程数就是并发数，而操作系统支持的进程数是有限的，且进程数越多，调度的系统资源也越大，因此**同步阻塞(Apachhe)无法面对高并发。**

先来了解下**IO多路复用中的epoll模型**。

epoll模型：当连接有I/O事件产生的时候(当有用户请求时)，epoll就会去告诉进程哪个连接有I/O事件产生，然后进程(工作进程)就去处理这个事件。

例子：小明家楼下有一个收发室，每次有快递到了，门卫就**先代收**并**做了标记小明的**，**并且通知**小明去取送给小明的快递。

通俗理解：一个用户的请求到达服务器上，首先epoll(**门卫**)会把请求(**快递**)接收出来，这个时候不一定会有人处理，如果有空闲的工作进程(**小明在家**)，epolll就会调用工作进程(门卫就会通知小明来取快递，小明**立刻**来取)来处理！

**可能的场景**：门卫接受的快递(进程)有点多，**发现取快递的不一定在家**，有些在家(**立马来取**)，有些不在家(处理不过来的情况)；当进程数量太多，处理不过来，消息就存储在这个位置，直到有**相应的进程**来处理为止！

###############

那Nginx的IO模型有哪些呢？

nginx 支持多种并发模型，并发模型的具体实现根据系统平台而有所不同。
在支持多种并发模型的平台上，nginx 自动选择最高效的模型。但也可使用 use 指令在配置文件中显式地定义某个并发模型。

- **select： IO多路复用、标准并发模型。**在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，select 模块将被自动编译。configure 脚本的选项：–with-select_module 和 --without-select_module 可被用来强制性地开启或禁止 select 模块的编译。
- poll： IO多路复用、标准并发模型。与 select 类似，在编译 nginx 时，如果所使用的系统平台没有更高效的并发模型，poll 模块将被自动编译。configure 脚本的选项：–with-poll_module 和 --without-poll_module 可用于强制性地开启或禁止 poll 模块的编译
- **epoll： IO多路复用、高效并发模型**，可在 Linux 2.6+ 及以上内核可以使用
- **kqueue： IO多路复用、高效并发模型**，可在 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0, and Mac OS X 平台中使用
- **/dev/poll： 高效并发模型**，可在 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+, and Tru64 UNIX 5.1A+ 平台使用
- **eventport： 高效并发模型**，可用于 Solaris 10 平台，PS：由于一些已知的问题，建议 使用/dev/poll替代。


**比较一下Apache常用的select，和Nginx常用的epoll**

**select：**

最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值为1024/2048，因此Select 模型的最大并发数就被相应限制了。

效率问题，select 每次调用都会线性扫描全部的 FD 集合，这样效率就会呈现线性下降，把 FD_SETSIZE改大的后果就是，大家都慢慢来，什么？都超时了。

内核 / 用户空间 内存拷贝问题，如何让内核把 FD 消息通知给用户空间呢？在这个问题上 select 采取了内存拷贝方法，在FD非常多的时候，非常的耗费时间。
**总结为：1、连接数受限 2、查找配对速度慢 3、数据由内核拷贝到用户态消耗时间**



**Nginx的IO模型是 基于事件驱动 的**，使得应用程序在多个IO句柄间快速切换**，实现所谓的异步IO。**事件驱动服务器，最适合做的就是IO密集型工作，如反向代理，它在客户端与WEB服务器之间起一个数据中转作用，纯粹是IO操作，自身并不涉及到复杂计算。反向代理用事件驱动来做，显然更好，一个工作进程就可以run了，没有进程、线程管理的开销，CPU、内存消耗都小。

**Apache这类应用服务器，一般要跑具体的业务应用，如科学计算、图形图像等**。它们很可能是CPU密集型的服务，事件驱动并不合适。 例如一个计算耗时2秒，那么这2秒就是完全阻塞的，什么event都没用。想想MySQL如果改成事件驱动会怎么样，一个大型的join或sort就会阻塞住所有客户端。这个时候多进程或线程就体现出优势，每个进程各干各的事，互不阻塞和干扰。当然，现代CPU越来越快，单个计算阻塞的时间可能很小，但只要有阻塞，事件编程就毫无优势。所以进程、线程这类技术，并不会消失，而是与事件机制相辅相成，长期存在。

总的说来，**事件驱动适合于IO密集型服务**，**多进程或线程适合于CPU密集型服**务，其实也就是说**nginx比较适合做前端代理**，或者**处理静态文件(尤其高并发情况下)**，而apache适合做后端的应用服务器，功能强大[php,rewrite…]，稳定性高。



### 2.epoll的两种模式LT水平 触发和ET边缘触发

**差异**

二者的差异在于level-trigger模式下只要某个socket处于readable/writeable状态，无论什么时候进行epoll_wait都会返回该socket；而edge-trigger模式下只要有某个socket从unreadable变为reable或从unwriteable变为writeable时，epoll_wait才会返回该socke。

所以，在epoll的ET模式下，正确的读写方式为:
读：只要可读，就一直读，直到返回0，或者 errno = EAGAIN
写:只要可写，就一直写，直到数据发送完，或者 errno = EAGAIN

**题目：使用Linuxepoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理？**

第一种最普遍的方式： 需要向socket写数据的时候才把socket加入epoll，等待可写事件。 接受到可写事件后，调用write或者send发送数据。 当所有数据都写完后，把socket移出epoll。这种方式的缺点是，即使发送很少的数据，也要把socket加入epoll，写完后在移出epoll，有一定操作代价。

一种改进的方式： 开始不把socket加入epoll，需要向socket写数据的时候，直接调用write或者send发送数据。如果返回EAGAIN，把socket加入epoll，在epoll的驱动下写数据，全部数据发送完毕后，再移出epoll。(目前淘米服务器框架的方法，避免不停的收到可写通知)这种方式的优点是：数据不多的时候可以避免epoll的事件处理，提高效率。



**ET模式下的accept注意事项**

  考虑这种情况：多个连接同时到达，服务器的 TCP 就绪队列瞬间积累多个就绪连接，**由于是边缘触发模式，epoll 只会通知一次，accept 只处理一个连接，导致 TCP 就绪队列中剩下的连接都得不到处理**。

  解决办法是**用 while 循环抱住 accept 调用，处理完 TCP 就绪队列中的所有连接后再退出循环**。如何知道是否处理完就绪队列中的所有连接呢？**accept 返回 -1 并且 errno 设置为 EAGAIN 就表示所有连接都处理完**。

```c
while ((conn_sock = accept(listenfd,(struct sockaddr *) &remote, 
		(size_t *)&addrlen)) > 0)
{
	handle_client(conn_sock);
}
if (conn_sock == -1)
{
	if (errno != EAGAIN && errno != ECONNABORTED && 
		errno != EPROTO && errno != EINTR)
		perror("accept");
}

```

**多路复用accept为什么应该工作在非阻塞模式**

如果accept工作在阻塞模式，考虑这种情况： TCP 连接被客户端夭折，即在服务器调用 accept 之前（此时select等已经返回连接到达读就绪），**客户端主动发送 RST 终止连接，导致刚刚建立的连接从就绪队列中移出，如果套接口被设置成阻塞模式，服务器就会一直阻塞在 accept 调用上，直到其他某个客户建立一个新的连接为止**。但是在此期间，服务器单纯地阻塞在accept 调用上（实际应该阻塞在select上），就绪队列中的其他描述符都得不到处理。

  **解决办法是把监听套接口设置为非阻塞， 当客户在服务器调用 accept 之前中止某个连接时，accept 调用可以立即返回 -1**。这是源自 Berkeley 的实现会在内核中处理该事件，并不会将该事件通知给 epoll，而其他实现把 errno 设置为 ECONNABORTED 或者 EPROTO 错误，我们应该忽略这两个错误。



**LT模式下会不停触发socket可写实践，如何处理？**

- **需要向socket写数据的时候才把socket加入epoll，等待可写事件**。接受到可写事件后，调用write或者send发送数据。**当所有数据都写完后，把socket移出epoll**。
- **使用ET模式（边沿触发）**，这样socket有可写事件，只会触发一次。
- 在epoll_ctl()使用**EPOLLONESHOT**标志，当事件触发以后，**socket会被禁止再次触发**。



**使用ET和LT的区别是什么**

- LT：水平触发，**效率会低于ET触发**，尤其在大并发，大流量的情况下。但是**LT对代码编写要求比较低，不容易出现问题**。LT模式服务编写上的表现是：**只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况**。
- ET：边缘触发，**效率非常高**，在并发，大流量的情况下，会**比LT少很多epoll的系统调用，因此效率高**。但是**对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况**。

1）//如果收发数据包有固定格式【后续会讲】，那么老师建议采取LT：编程简单，清晰，写好了效率不见得低；
//老师准备本项目中采用LT这种方法【固定格式的数据收发方式来写我们的项目】
2）如果收发数据包没有固定格式，可以考虑采用ET模式（官方采用ET模式）；

1）方法：如何解决拆包问题：给收发的数据包定义一个统一的格式[规则]；c/s都按照这个格式来，就能够解决粘包问题；
2）具体：
①包格式： 包头+包体 的格式；其中 包头 是固定长度【10字节】,在包头中，有一个成员变量会记录整个包【包头+包体】的长度；
②这样的话，先收包头，从包头中，我知道了整个包的长度，然后 用整个包的长度 - 10个字节 = 包体的长度。
③我再收 “包体的长度”这么多的字节； 收满了包体的长度字节数，我就认为，一个完整的数据包【包头+包体】收完；
3）收包总结：
//（1）先收固定长度包头 10字节；
//（2）收满后，根据包头中的内容，计算出包体的长度：整个长度-10
//（3）我再收包体长度这么多的数据，收完了，一个包就完整了；
//我们就认为受到了一个完整的数据包；从而解决了粘包的问题；



**epoll的ET和LT模式的**

假设现在对方一口气发送了大量数据过来，以至于这边没法通过一次read就全部读取完毕。

由于ET模式只会通知一次，所以这边对应的数据读取函数中不得不循环read多次，以保证把对方本次发送的数据全部读取完毕。比如说这样：

```c
while ((n = read(...)) > 0) {
    ....
}
```

否则如果你只read一次，那么剩下的那些数据可能就永远也没有通知了。由于上面那个循环的存在，文件描述符必须是非阻塞的。





### 2.linux在多个文件查找字符串(find | xargs grep)



```shell
find <directory> -type f -name "*.c" | xargs grep "<strings>"
```

- <directory> 是你要查找的文件夹；如果是当前文件夹可以忽略；
- -type f 是只找文件；
- -name "*.c" 表示只找后缀名为.c的文件；也可以不写，表示找所有文件；
- xargs是一个强有力的命令，能够捕获一个命令的输出，然后传递给另外一个命令，之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数
- <strings>是你要找的某个字符串

**从根目录开始查找所有扩展名为.log的文本文件，并找出包含”ERROR”的行**
find / -type f -name "\*.log" | xargs grep "ERROR"

**例子：从当前目录开始查找所有扩展名为.in的文本文件，并找出包含”thermcontact”的行**
find . -name "\*.in" | xargs grep "thermcontact"



### 3.对文本进行分组并统计每个值出现的次数？(grep | wc -l   awk -F print | sort | uniq | sort -nr)

**(1) grep+wc统计某个字符出现的次数**

```shell
grep -o '404' nginx.conf | wc -l
输出4
grep -o '404\|8081' nginx.conf | wc -l
输出5
```

**(2) 统计文件中某个字符出现的次数**

![image-20210405165723344](imgs/22.png)

`从某行取出分割的串`

```shell
cat check_info.log.2017-09-20 | awk -F '(txt=|&client)' '{print $2}'
```

  cat读取当前文件；awk -F 进行分割字符，并打印第二列的字符；在这里 ‘(txt=|&client)’是分隔符，它是一个正则表达式。

```
sdate=2017-09-20 23:59:32&
com.ford.fordmobile
_id=x
```

`之后排序`

```shell
cat check_info.log.2017-09-20 | awk -F '(txt=|&client)' '{print $2}'|sort
```

![image-20210405165904667](imgs\23.png)

`之后统计数量与去重`

```shell
cat check_info.log.2017-09-20 | awk -F '(txt=|&client)' '{print $2}'| sort | uniq -c
```

 uniq -c 中的-c 代表在每列旁边显示该行重复出现的次数 

![image-20210405170035556](imgs\24.png)

`之后再按重复次数排序`

```shell
cat check_info.log.2017-09-20 | awk -F '(txt=|&client)' '{print $2}'| sort | uniq -c | sort -nr
```

**sort -n 按照数值的大小排序；-r按照相反顺序**

`最后将结果输出到文件中`

```java
cat check_info.log.2017-09-20 | awk -F '(txt=|&client)' '{print $2}'| sort | uniq -c | sort -nr > testfile
```

![image-20210405170209237](imgs\25.png)

面试真题：

对第二列进行group，得到每个值出现次数。

123|weixin|314

45|zfb|321

12|weixin|14

先将这些写到一个test.log文件当中。

```shell
cat test.log | awk -F '|' '{print $2}' | sort | uniq -c | sort -nr > res.log
```

### 【Shell命令】- Leetcode192 统计词频（tr -s ' '  '\n'）

写一个 bash 脚本以统计一个文本文件 words.txt 中每个单词出现的频率。

为了简单起见，你可以假设：

words.txt只包括小写字母和 ' ' 。
每个单词只由小写字母组成。
单词间由一个或多个空格字符分隔。
示例:

假设 words.txt 内容如下：

the day is sunny the the
the sunny is is
你的脚本应当输出（以词频降序排列）：

the 4
is 3
sunny 2
day 1

```shell
cat words.txt | tr -s ' ' '\n' | sort | uniq -c | sort -nr | awk '{print $2 " " $1}'
```

> 解释
>
> cat    --游览文件
>
> tr -s   -- 替换字符串(将空格换为换行符)，保证了一行一个单词
>
> sort   --默认ASCII值排序，排序后还有会重复
>
> uniq  --去重，-c输出重复次数
>
> sort -nr -n按照数值的大小排序 -r反向排序就是从大到小
>
> awk 格式输出

### 【Shell命令】- Leetcode195 第十行（awk 'NR==10'）

给定一个文本文件 file.txt，请只打印这个文件中的第十行。

示例:

假设 file.txt 有如下内容：

Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
你的脚本应当显示第十行：

Line 10

```bash
awk 'NR == 10' file.txt # NR在awk中表示行号
sed -n 10p file.txt     # -n表示只输出匹配行，p表示Print
```

### 【Shell命令】-Leetcode194 转置文件

给定一个文件 file.txt，转置它的内容。

你可以假设每行列数相同，并且每个字段由 ' ' 分隔。

 

示例：

假设 file.txt 文件内容如下：

name age
alice 21
ryan 30
应当输出：

name alice ryan
age 21 30

```bash
# Read from the file file.txt and print its transposed content to stdout.
COUNT=`head -1 file.txt | wc -w`
for (( i = 1; i <= $COUNT; i++ )); do
awk -v arg=$i '{print $arg}' file.txt | xargs
done
```

### 【Shell命令】- Leetcode193 有效电话号码

给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

 

示例：

假设 file.txt 内容如下：

987-123-4567
123 456 7890
(123) 456-7890
你的脚本应当输出下列有效的电话号码：

987-123-4567
(123) 456-7890

```bash
# Read from the file file.txt and output all valid phone numbers to stdout.
grep "^\(([0-9]\{3\}) \|[0-9]\{3\}-\)[0-9]\{3\}-[0-9]\{4\}$" file.txt
```

> ```
> 注意""不要丢了，其中的空格，()是普通字符，" "不要丢了
> ^：表示行首，以...开始，这里表示以(xxx) 或者xxx-开始，注意空格
> ()：选择操作符，要么是([0-9]\{3\}) ，要么是[0-9]\{3\}-
> |：或者连接操作符，表示或者
> []：单字符占位，[0-9]表示一位数字
> {n}：匹配n位，[0-9]\{3\}匹配三位连续数字
> $：表示行尾，结束
> ```

#### 4.Linux设置定时任务

1：查看现在已经有的定时任务的命令是  crontab -l，执行命令如下图：

2：新建定时任务的命令是：crontab -e，想添加新的定时任务的话输入i进行添加，类似于vi的编辑;

3:定时任务中的时间的说明，时间的格式大概是这样的* * * * * 五个*号代表的意思分别是分，时，日，月，周的顺序来排列的

### 4.grep的常见参数

-c  **只输出匹配行的计数**；

-n  **显示匹配以及行号；**

-l   **不区分大小写(只适用于单字符)**

-v  **反转查找**

### 4.Linux的awk的命令参数以及内置变量

-F 指定输入文件拆分隔符；

-v 赋值一个用户自定义的变量；



**内置变量**

NR 已经读出的记录数，就是行号，从1开始；

$0 完整的输入记录





### 4.nohup命令

nohup命令用于不挂断地运行命令（关闭当前session不会中断改程序，只能通过kill等命令删除）。

nohup command > myout.file 2>&1 &

> &用于后台执行程序，但是关闭当前session程序也会结束

> ```
> 
> 2>&1就是用来将标准错误2重定向到标准输出1中的。此处1前面的&就是为了让bash将1解释成标准输出而不是文件1。至于最后一个&，则是让bash在后台执行。
> ```

###  4.Linux命令下查看进程占据的端口(ps  -aux | greap pid  netstat -an | grea pid )

`ps命令详解`

`ps命令`是用来显示所有进程的状态的

- ef是用标准的格式显示进程的

![image-20210412220538080](imgs\29.png)

- aux是用BSD的格式来显示进程的

![image-20210412220609857](imgs\30.png)

`grep命令详解`

结合grep 命令，grep就是使用正则表达式搜索文本，并把匹配的行打印出来。

`例子：搜索一个进程比如httpd`

第一步，使用ps命令结合管道符 | 查询到进程的PID。查询进程关键字为httpd，找到进程的PID号。

```shell
ps -aux | grep [name]
```

![image-20210412222149833](imgs\31.png)

第二步：根据PID号，使用netstat命令查询端口占用

`netstat命令详解`

netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于校验本机各端口的网络连接情况。

![image-20210412223526099](imgs\33.png)

常见参数为：

- -a 显示所有连接和监听端口；
- -t 仅显示tcp相关选项；
- -u仅显示udp相关选项；
- -n 以数字形式显示地址和端口号；
- -l仅列出有在Listen(监听)的服务状态；
- -p显示建立相关链接的程序名 pid号；
- -c每隔一个固定时间，执行该netst命令

`netstat -nap | grep 'PID号'`

![image-20210412223051206](imgs\32.png)

### 4.Linux命令查看端口所占据的进程是哪个

lsof -i:端口号

查询所得的进程名 

### 5.Linux命令查看某个进程下的线程数量(ps -aux |grep name  top -Hp pid)

`top查看实时的进程数` 

显示CPU占用状态；显示内存使用率

![image-20210412225005640](imgs\37.png)



可以查看某个进程下的所有线程数量。

`top -Hp pid `

![image-20210412224154553](imgs\34.png)

### 6.linux下命令查看TCP连接数即参数为（ps -aux  netstat -aux wc -l）

**(1) 统计httpd协议连接数**

```shell
ps -aux | grep httpd | wc -l
```

![image-20210412224351062](imgs\35.png)

**(2) 统计80端口连接数**

```shell
netstat -nat | grep -i '80' | wc-l
```

其中t是tcp连接

![image-20210412224600502](imgs\36.png)

**(3) 统计已连接上的 状态为'established' **

```shell
netstat -na | grep ESTABLISHED | wc -l
```

**(4) 查看哪个IP地址连接最多，将其封了 **

```shell
netstat -na | grep ESTABLISHED | awk 'print $5' | awk -F ':' 'print $1' | sort | uniq -c | sort -nr 
```

### 7. Linux常考察的命令问题

#### 7.1 **linux如何查看连接数**

（1） 查看网络状态

`netstat -an`

（2）查看8080端口连接情况

`netstat -an | grep 80`

（3）统计80端口连接数

`netstat -nat | grep -i '80' | wc -l`

（4）统计httpd协议连接数

`ps -ef | grep httpd | wc-l`

（5）统计已连接上的，状态为established

`netstat -na | grep established | wc -l`

（6）查出每个IP地址连接数

`netstat -na | grep established  | awk '{print $5}' | awk -F : '{print $1}' | sort | uniq -c | sort -r` 

#### 7.2  **linux如何查看cpu和内存的使用情况**(top free du)

（1） **top命令查看Linux资源的占用情况**

![image-20210521214302738](E:/笔记/面试高频/imgs/264.png)

（2）**free命令查看内存使用情况**

free命令查看总内存、使用、空闲等情况，如下图：

![image-20210521214350221](E:/笔记/面试高频/imgs/265.png)

（3）**ps命令查看cpu状态**

ps（process status）命令用来汇报处理器状态信息，示例用法：

```
ps ux
ps -H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu
```

#### 7.3 Linux查看进程连接数和句柄

比如查看nginx下运行进程数

`ps -ef | grep nginx | wc -l`

查看进程下线程的数量

 top -Hp 进程号



**(1) 进程和句柄概念**

一个程序可能会打开多个实体，即进程；

一个进程在运行中会打开很多资源，包含文件file、通讯连接socket、正在监听的端口等，我们把这些统称为句柄(handle), Linux中任何东西都是文件，所以**当一个进程打开的句柄数超过系统限制时**，会收到警告：too many open files。

**(2) lsof**

在了解lsof之前，先来回顾用一下netstat和ps。

- ps是查看进程，主要是针对本机的进程活动，更多的是关注性能，关注对机器资源的使用情况；
- netstat是查看网络状态，主要是针对网络，查看网络的活动情况；



lsof是系统管理/安全的优良工具，因为它是指"列出打开文件(list openfiles)".要知道，在Linux中一切(包括网络套接口)都是文件。

**(3) linux高并发socket最大连接数所受的各种限制**

在Linux平台上，无论编写客户端程序还是服务端程序，在进行高并发TCP连接处理时，最高的并发数量都要受到系统对用户单一进程同时可打开文件数量的限制(这是因为系统为每个TCP连接都要创建一个socket句柄，每个socket句柄同时也是一个文件句柄)。可使用ulimit命令查看系统允许用户进程打开的文件数限制：

![image-20210521220247784](E:/笔记/面试高频/imgs/266.png)

这表示当前用户的每个进程最多允许同时打开1024个文件，这1024个文件中还得除去每个进程必然打开的标准输入，标准输出，标准错误，服务器监听socket，进程间通讯的unix域socket等文件，那么剩下的可用于客户端socket连接的文件数就只有大约1024-10=1014个。即基于Linux的通讯程序最多同时允许1014个TCP并发连接。



**（4）经典案例**

- 统计各进程打开句柄数

`lsof -n | awk '{print $2}' | sort | uniq -c | sort -nr`

- 统计各用户打开句柄数

`lsof -n | awk '{print $3} | sort | uniq -c | sort -nr'`

- 统计各命令打开句柄数

`lsof -n | awk '{print $1} | sort | uniq -c | sort -nr'`

- 根据打开文件句柄的数量降序排列，其中第二列为进程ID：

```
lsof|awk '{print $2}'|sort|uniq -c|sort -nr|more
```



#### 7.4 **linux中线程的状态以及符号**

- R(Runnable) 正在运行，或在队列中的进程；
- S(Sleeping) 处于休眠;
- I(Idle)处于空闲；
- Z(Zombie)处于僵尸状态，进程已终止，但是进程描述符仍然存在
- D 不可中断，收到信号不唤醒和不可运行，进程必须等待直到有中断发生；

#### 7.5 Linux中如何查看线程状态

方法：top命令

> top
>
> 按H，会显示线程
>
> -p 可用指定PID号

#### 7.6 Linux关闭一个进程的命令

先找到该进程

ps -aux | grep java

在关闭

**kill -9 pid号**



| Signal Name | Single Value | Effect         |
| :---------- | :----------- | :------------- |
| SIGHUP      | 1            | 挂起           |
| SIGINT      | 2            | 键盘的中断信号 |
| SIGKILL     | 9            | 发出杀死信号   |
| SIGTERM     | 15           | 发出终止信号   |
| SIGSTOP     | 17, 19, 23   | 停止进程       |



**kill的底层原理：**

Java是如何处理SIGTERM(15)的。

我们都知道，在Linux中，Java应用是作为一个独立进程运行的，Java程序的终止运行是基于JVM的关闭实现的，JVM关闭方式分为3种：

- 正常关闭：当最后一个非守护线程结束或者调用了System.exit或者通过其他特定平台的方法关闭(接收到SIGINT(2)、SIGTERM(15)信号等)

- 强制关闭：通过调用Runtime.halt方法或者是在操作系统中强制kill(接收到SIGKILL(9)信号)

- 异常关闭：运行中遇到RuntimeException异常等。
  





#### 7.7 Linux的top命令的参数

按F键可以将进程变为线程来排序。

top [-] [d] [p] [q] [c] [C] [S] [s] [n]

- d 指定每两次屏幕信息刷新之间的时间间隔。
- p 通过指定监控进程ID来仅仅监控某个进程下线程的状态；
- q 使top没有任何延迟的进行刷新；
- S 指定累计模式
- s 使top命令在安全模式中运行，这将去除交互命令所带来的的潜在危险；
- i 使top不显示任何闲置或者僵死进程；
- c 显示整个命令行而不只是显示命令名；

### 8.Linux中Java的一些问题排查（高频）

#### 8.1 **Java内存满怎么办，怎么排查**(内存top)

**(1) 查看**

> 涉及到的命令为dstat和top

先使用`dstat`,查询到内存占用最高的 Java应用，但是这台服务器跑了好几个java，具体哪个进程使用top看下资源情况；

![image-20210523083746641](E:/笔记/面试高频/imgs/274.png)

之后用top命令，-H 显示线程信息 -p指定pid 即top -Hp pid可以查看某个进程下的线程信息。

![image-20210523083931991](E:/笔记/面试高频/imgs/275.png)



**（2）定位线程问题（jstack）**

使用ps查看16494的线程情况

> ps p 16494 -L -o pcpu,pmem,pid,tid,time,tname,cmd

![image-20210523084126027](E:/笔记/面试高频/imgs/276.png)

可以看到16494这个pid的应用产生了很多线程。

**（3）查看内存使用的堆栈情况**

使用jstack来查看，挑选了TID=17417这个线程进程分析，在分析前需要将17417这个id转换为16进程，方便查找新；

```bash
[root@localhost ~]# printf "%x\n" 17417
4409
```

16进制为4409

将pid为16494的应用打印到日志中

```
[root``@localhost` `~]# jstack -l ``16494` `> jstack.log
```

**（4）查看内存堆栈信息**

```bash
[root@localhost ~]# vim jstack.log
```

在日志信息中查找刚刚转换的4409

![image-20210523084524399](E:/笔记/面试高频/imgs/277.png)

可以看到这个线程状态为waiting。

通过查看日志发现有大量的 waiting on condition

```
parking to wait ``for` `<``0x0000000085dce510``>
```

存在大量线程等待被唤醒，占用大量内存

**(5) 代码优化**

将相应日志发送给相应开发，优化线程。



#### 8.2 Java cpu占用高怎么排查(top Hp)

java线程占用cpu高 于 占用内存高的类似的解决措施

- a. 通过top命令来查看占用cpu或者内存高的进程【备注：输入大写P表示以cpu从大到小排序，大写M表示以内存大小排序】

![image-20210523085238294](E:/笔记/面试高频/imgs/278.png)

- b.通过对应的cpu找到PID也就是进程对应的pid，然后找到java进程106854这个进程的id

![image-20210523085340673](E:/笔记/面试高频/imgs/279.png)

- c.通过命令top -Hp PID 例如top-Hp 106854。就可以列出该进程下 的所有线程id

![image-20210523085839621](E:/笔记/面试高频/imgs/280.png)

- 4.通过输出大写的P查看线程占用cpu最高的或者通过大写M来查看内存占用最高的，就可以找到109391这个线程id；
- 5.使用命令printf "%x\n" 109391 输出对应的十六进制码，1ab4f这个码是为了过滤线程id查到对应的代码

![image-20210523090012775](E:/笔记/面试高频/imgs/281.png)

- 6.使用命令jstack PID|grep 1ab4f 【备注PID是进程的id，1ab4f是这个进程下的一个线程占用最高的cpu十六进制码】

![image-20210523090046097](E:/笔记/面试高频/imgs/282.png)



> 总结：(从进程出发去找线程的问题，java排查用到jstack)
>
> **cpu满了和内存满了都差不多的解决方案：**
>
> - 1**.top实时查看内存和cpu使用情况，记录pid**；
> - 2.**用top -Hp pid查看线程**
> - 3**.jstack PID > mem.log**
> - 4.**print “%x\n” 线程号**
> - 5.**日志中搜索线程号**
> - 6**.定位问题 解决问题**





#### 8.3 java内存泄露如何排查呢？（高频 超高频）

没有经验的程序员通常认为Java的自动垃圾回收完全使他们免于担心内存管理，但是一个常见的误解：虽然垃圾收集器做的很好，但即使是最好的程序也完全有可能成为严重破坏内存泄露的牺牲品。

当不必要地维护不再需要的对象引用时，会发生内存泄露。

实际上有四类内存问题具有相似和重叠的特征，但原因和解决方案各不相同：

- Performance(性能)：通常与**过多的对象创建和删除，垃圾收集的长时间延迟**，过多的操作系统系统页面交换等相关联；
- Resource constrains(资源约束)：当**可用内存很少或内存过于分散而无法分配大对象**时，这通常与Java堆相关；
- Java heap leaks：经典的内存泄露**，Java对象在不释放的情况下不断创建。**这通常是由潜在对象引用引起的；
- Native memory leaks(本机内存泄露)：与Java堆之外的任何不断增长的内存利用率相关联，例如由JNI代码，驱动程序甚至JVM分配。

**（1）解密OutMemoryError**

OOM是内存泄露的常见指示。实质上，当没有足够的空间来分配新对象时，会抛出错误。当垃圾收集器找不到必要的空间，并且堆不能进一步开展，会多次尝试。因此，会出现错误以及堆栈跟踪；

诊断OOM的第一步是确定错误的实际含义，下面分析一些可能的错误类型：

- java.lang.OutOfMemoryError: Java heap space
- java.lang.OutOfMemoryError: PermGen space
- java.lang.OutOfMemoryError: Requested array size exceeds VM limit
- java.lang.OutOfMemoryError: request bytes for . Out of swap space?
- java.lang.OutOfMemoryError: (Native method)

**1.1 Java heap space**

此错误消息不一定意味着内存泄露。实际上，问题可能与配置问题一样简单。

可能并不是应用程序的错误，而是应用程序服务器依赖于默认的堆太小了，可以通过调整JVM的内存参数解决了这个问题。
]VΠ#ZyjZ{(R_J[i>^i%!G&d4q8ˎ±쑳AEwьƕ&ǎ{uor#	фb%14n4T5VRg6omik@3IIIhDJG$)z4Z=u;5 FX	%t4Դ
=    IDATn@U`PA͡.e
z+W
F8s/W45%RܸSRq<j"߿*z7	(k@DGE,6Tv&H[
hBwW7JZZ)).''CqXJK4B!
Vu))N0?&[ъvؙ=5Lwyy[_+i*FJn@..9zwQ7R2*~ݻ2=H.)i\yBG&z=Rúm咞ˈ%B	]hZp0AaSʜ)ZiBQO?Whl'[IWqSppyrX+]L @AIٌ5SJTzef%i!JӡIsş\F$CqVrfگzZê++nw`7hyV/쌘<+n|u>fǨYMRPT)~'>*MYY>_yx.Ρ F,z7AJ.{~C
ӒFtK&$sLͱnsHBN'9:W%<z=QBt-Nm?⍹rE\4kvxgٰ0hL|;1sYWF#~}1?~n{ӏ)X-&"~XzF9_7M#;.ww6BB!RLT3N{	ҳQo;\\uӿ3 JvGgw[ʧƷJ5sܡɡ:Ju;xW	)W	8
oe"T-AwGGhy>w~\1k(Gvi,].TJfQLͶP+LzD+e3ur	Oqp;#+ZVd^b){E\0c
_ǟe=Dfq+Sq`duJMu3Tę`:ZAS[~̍Mb6wzsdL^|Y8e$O_;7I+	q24g%'W\h/TTLf3֣3enKp,zXOkD|M62lHgcqM5עr׍Wbg'@"!ppM_bPQZ,HK:lvBW0-!GxnVuvxK6 3ǱuDBQS=̙4w`Ob)8x dԐ]"!6^0gl}o^^Lkl[DQiToJ,<g +xן6{4X&{	CqUpQl޺fB!PLt.%&rܛ6ջfst#{:,f&WP+EX&oG<MnjFk]7^Ż[h02mWUͨZ7^0HBWX~X_//0|>4Mcǎz/bHqvW'e$d3k[idzF-8E4d/e[齗=CTm5m/)VdcozP++c4^}SEub!?_~f?!x4N`]uNwCMIU1X=u[`0>/Ol-+C//>mB#lEj4aX1ň]dFqb0c*Ą!٤M:Y#km#В_Ouy{-\v_kAU]3*pؙ5q$bX1v1[\dcpQ:T/̻WDXʓL=FuC+ÆQHp Hg0v'&>қ[vX(/ʨLJ۾k4&?q]KQu+<y`0;(xߔBq
TZ=[JIO|d+XP(Dg[/l%Xן`FჭL`Թ8NT=L-<f=]ރҸ~oauܮkVmgOC+Ft0k}GI0aE[)dqS<AyD4d)V0W7$ke+O$?+8[jP Dkc7
&J5hV[[&_KP^(䥗_v؇Zi~as%[b4:N-I&hdo4S\6/_5m<?r9)asIO'wUw_#$9'{Hd *zwjmޝvj[iZ"!BB {'$gDRA<}x9u"zw\.Jʧ0k^78Gn!M
 z±Ȱ1|^ZIXӆjo	#H}~W-Λ)n'X)-.fd^D7R6k.y9nR])AeW=مePkn%NƒWIIqFH#f ՝+51S8twz<l;7upƜ5GmBgtQ
9Neu!h1lZú;x陣`Bƍ8'*Ax|0+YJn]\LRGn!Ud%c1M$46T{T'}V2-f6ei:L9|lgaelI	Ey$	HsvΧtt!1хHfm1"^i6'`WV>\.7.TKpeCp'AZAwGTJZqQ|&tFYI*G!#l'kwR4I,oxlxEW\I5Ib`5+.ϔq%d1x#t:Z̓K$Qx^G~Q<c4hxDuxM]pg1n|QyI3$sJHpLe3"7D,aDIT b$geqK4,.7i.ҰM'0y%ccQ[-&)źo'nk
:n#-s*!BKWxIWY:i`VVSyL)+!+݅;=R`Vz#s0$A-G^%6	'#qvk/bTF.e3)wXĝ痑j&q(cHsp8d/onp%dg6lccuh<JPVJogvvJKrXV:-#8bj"54+};J#[TJBMGaGup9h6GUGQ1a6ꎻH"ސ  ;|"ZMCSI#av65X0%s/I.13Fb%Gع%dΝ_\pN|e~U%Rk|p-=$qI1g?baZCɠ#flytF0`'U<O!GRN$&9Y9b"pl\)J&L'*BJkhjE9}_I?|'=F`qޢ"*6|Nvy?z$Y^X៛6òRXnגn33+%zBJz6IeDBES%+	q,R4Iw[&456X{.Q[Wy7;}ON솥(( IjG7x[ڨTAXuFfN_Ƙ0ަ]lM6nx.ũ\D]*iY_[w_C݂^/M47EKS=gyߺ㵡hh8*wWn`媭tE[ٴ='BSIOw|a.`V
i~'+vRW̻Qn,>thL"	.ry[ZTI̜=#Ixvv_[X|9r2r"Gaŝw.ۿ7
}`LaYij-ih0lV҆dYz'-])YIc'Aos>cz$)&l~%~ĳxǈC8/>ZlJ&UZ}D+mV;nP`sf`281u͕4ukeܔrr	ڸH<AK&sNiyt2(=M<p(LkvPH=KeS>/hh4BԔCBZOf^?Z:̳XKIDvށA!ޞkܼp".xV.O<G{op,J$ƑQ<ĖIʁ妐bZ.Y1:3H1핛mKseS)udN$g߆DI7q3JpNSJAEno`VyҶWOóR.c/V߻1NR4}mum<ۀ`VGt-q,R4$Xv͘DnhiO9lh&5qY'W2H&7ecLfɛ;pdLv\1t8uT4Q?\Jf`_'%H̾DMbK7 T]C&P.~ßjE5`tȞ&R>|L5N`9|[9בIą<>+O38=!dXmv͜Ds0+5T;lLyY)Ok{5WHd"env1&^4,yآ	idLt2R{Yr0+5Q]DXlY)XCcJ'R%Q#]Gb?ЬTX>QV:P94+eem>+MZ\EO]V^x)JB6
fpZ-"q؝`fƨsNLmͦ}83Q#p,u
:#QsJHw?͕$av0(4B cguDH_MuxC	z#eX{Bw9lf&=h*jGm8B8NR =Nw6]q',2IYGuUpr.(݉V#'r4.Οb=օBq:2S~_7АUoF#s]yY){r| Ȳ0Yi)&W5Ylq[I<]X=fhenQعdT7`0RR6Jw{6%tXQ(fb҃F	'J;󯼉yGYԴf%wFzTV}_4.Z_ϢʱY,'g!~R4$DqjIP2v&_1lՊf#3[2~n1vNPg׽[
x6F?>Eƒ3͌Yn~?)Fzz-m$*`cp:f.]#3`H>	El6l6;))\7Q:"t՗OPF[H,bHg2J
H۱N=(YJ*΄BD4JǝmOvmhV|ޛCfh4̺_bK]hz|vc)7OG|98.y!YIEuQ]~(+U5sdVbmُPV*k-lT՟
qNkcr^H4@1p͟ӊJc&/ŵ&Yi7j9M8#Ixٷl)۾zSRGpquwR؎9%QEda<7+=aW³/̡ҭ{?;6⊅|RJ й,Š#\6Qt@33G>FٿsM-Co{nd+P00p=?bwrʨ2]iXMhIy#qmǿ,TH#|NRg#77TVx'y7
s-BLþW_fW>\;Vwc.ȠxHGd%3Yn\n=}^-p5	~_eѤ?/5	&pe呕Y79weK%i:~U[f}haaYz֣Қlc/1ʻihn'1t* M8rYpݽ̼f[PvrsIKsJ?o;(YIc&#4UC\"O Gi;/`ifz|黏3aGm{pٽcOx_>Ae]3̤[>	cpڈ:شj}>yVS	|v WoOo/2lM{{ٱӲ^XA8b9(,)/`YbټoG-NN^6#˶yDOv>]./zwV>&Ma2r3uxX#|_@	YFO!8.PV$IͭɃK
t~Gi;0idYy?00j|9#;ci+|GX~h4F1yDFe$"l]*w_:tS*~uhI^Ow[oz=-l{DV9@O般Լ?QVlK$b;Q2sϿnVz<R1 ;70MǊKD<p}<zZћRL.?
F^8i">0mxcճ^v3CXPX%1UM	h_Cڼ֠ҍfax8
غ2$Ǌ(	zZjyO?Sysg3~(L#
	:ٺy[3ki6=]M{J`ë<mxYtP: :ʪ;Lr|k!BfNOÆJ4 jqVdooI>V=G 6>WYle2y"cGb3)D~Zٱ}3kXMM{XB!;ן~l;z"lZ)B1@%`ՋKϴqqJٳw6-dǦtZi%f@3ټ"__{<FWÞU\v"OaASgV	;ł Mm}Gm'0+<ںɈW*}N7+W
TJ}TVTl~@ke6@%y{ys*4{)q[ђazQ5H"`ǸYi[YsBL)gLЬPώXr5x^~^Z	6?Pm)98!>,ldݸRhF4짧Xtz6Y&(A?= Ef+E8mVtF,`8@<z    IDAT#,lV:b }}}tyO8l))3Yt:?qMbIU׷ @=|VU#54+Dz:+Yh2?وQM0|J#
p,ЈEBx;;of%g*9Yح&YnJ?sSg`&|i")ڟ&	4"Aj>}&?H!g:+cQZj?Ynd:d%!2B!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!0ʍʧu*7+BULfJǠ(>s3ylFCB!Xvܼ}).Xl6ι`>hTnV!8t:&ТO>l^x,vE!8c˻(M:VH,`p`w8Nű	!g=EQ0}(@Qz&x<hh4B!>4z=&iM,&rrhCSqLB!GAgDv|>Jaf=hvI!P[,d&E;wo㨪!0t:,ixU&B!	S{N6hHˉBq2E3$BaMB!B!&B!B!L&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!BC&B!B!ÐB!B!0h"B!B1)!B!Bp@|0T5TQ5MEQut:tr#KӴ/<EM,7wyBj*ɤihuu޽L.08:;-ous=(>R48;%lG~^6+4X$DRф~%X(
VD4B"d2c04(xEQ0pi$q`1>uI:ل^'BJ$uF/D"lu[Ȣ<,FYZ x45 i`20N-MCM	Gh`ln{7N!`0XLwpZ%	8Nb:TdPI30>CGE$.}g[®a$:ٌÙϼ/皫1cҘ/S؂_3t)xy[XG@IeҕwoĨp`ˏ߽@_!h&O?u~|m&t._{ۜ_uRR_I=1yN3y?OZ
i.߸jR6)f=Mͺ(;WΟxETvR=6Lz8vś	(^sB%MSneu<H4!y1[8rKOrEv~&Tۛ!"{/+2_垛?5?#Awg[>o2,^	"oR]߂+w75y6^+bo}d%baU`dIl忧b-Pp[&f-F<pi_UgC>$MeLDLg~ng)tc~˟.`8b4aZ0uA8:}=uU߸?EnY8~'xΖj^Y^Ĝ>ˊ& F
ǦѰn#-*I]%Qcgy{NlF-QjL>?JKFÒf02+*BhYq`x(@[c;wDs%ck-rf^3liƨL+ I;te=}B!{سyWٰe7=L&3N$``8j֯O)L)n>"%#l]y/?sFN]ox4BWލTeށ3y:rK4짲E0,c"gغ^fFe3U{+h
ɛ{RU«ohܩϸIxC[M5ъ#LI;h ,<#gNlb%z3\453:73vGB}_>lY3QŔaDCCtvwu2&ఞX7^zI|LOz
.6LoW5v3fx$1j捊|8#Gps0ҳ2ɉ%paZ"Ēǟ"*G;s$5whĞN^^2Μgjk
L\	mqLF^!l>{:?x𻬮!,fNF`ŨFڛ?7̉ŜYNT6x{GSOjƉO=>ՙJNn.NSs<U&43icҕ|qu1LG#W`IIgtEL+fT2ID'uj6Gֽ-4D"/[C?LVyyDWj
fәa+V_?FuKsnvXYL΍!EPGfuufso߽qV5yoqx;TqZC"4J,W7(9I9yT׵ʵz~)&H_?SƂsH-맳ߏ3}o41;\^|;_ őÔ3%B:zQo
&GrR!>d}oǲm}W/bǳ$cax??<C_-acwɴ\=%yE(/hSj4tf}QPt(^s#/mm϶ej
3hdŊA2GOc,m5St|>o#))vRC<^z=>g=#ʸ v.ǙKGlgrngG[khqR2SAwÕ[5ݍ˕§;HEEL,ΐ6EV˺:X5:FYpY!%LwfPL|lCVep΢˙pM?~ꌡpe䖻N^ѻ~BxyYEёS4'\ql&Ð&cɯ=L-YBKw`[qgNkdy0WWYP?'EQ~BJ͞^ǜrƊhKї ә=ys9q6
:yގK1S8[N?4gșCJ&g{	|,f8̗gEa:(sNUx't 6G*1jJOGXՎÙF!xNZ[i#0d_P@NMhnn\&iC9''cZinjCSf+%(#a=LŢ}M6RSIDU}P9E.I݂rtuPWSGׇAF, +}*
3./HvomyRZ4maɎv$rܩ]]Dc1;)4J8M-%ʁ46ZRA^x/4dΞv"tR)X]$T3Ӊ.*H.(88LGT45I$V| b0t1l7Vk"%g ŀ"%F2ߋ?G=FzT'N?p.ZZZxŒpOqwWI&=z# Q;[hJJKᰣtuv6G:#iDAz:Z_S@ $G/%%y,Vsaښhni;3ʥxH2\?B_gyaz	1A.f׈NǖO|'_BO }jS4vHK[(dRR<L0K%CR1tc3{8P_K{W/"??QFb7J{"hkoјc>lK[kx|$:WF.ye钉8/*zRRIKu`4 ÝP_Ok[^ъ;3ѸRkCi ē@F^!cGNOx(M%
݇ xn4MGnqWQH)iر@+Wśb9f̝4T5Ia &*)dd̃Zo?l%;7OcMt")3x8wH4&	q:q-:iNR1zd#=98QQϋ0顡^p$ #s0Ǥ:l~Dz{3Ӆ3%I!;8f-4pq8RLʬ%<tF8\d%#3#L1kI0}{Dc	IƦ&3.W:0#Uq|}ﯡX"	:=9y=\w>Lߏ 9Rq9:iljx\l3x9ʪg$)ut\F--m?=#g|~'&9FGӱo~gbIGݟcڄƉZ׿E] /~1f=ݭuxXF?t:t7FekOOش)HXѶy	?
#2oFho\mlQ̴cјʡUO'ę3+/OUq:H&5ԬfL;;,y WŞ#14Eͤ[!sl2fLkYl)WMWCc|>eCqTλl.e#@S!1^2>ffm~gzBL_x2{<hz#"
Go쯿˦t]BK?k$L6:,hI|=uྯӥ(w+U6\-kxשo@KxEc4)]Lyv]/pѬC~^oxm>B	]{(>y2@CKD޹^^ʶ=ol!
D`]Hzm,EN8g~ҷ?Y02ܛӗc{ϻ/|Js-#~ls}{ZI$U4M`4)d9XZ@v5`-\9|ҟYiۈD。`td]y#^|y:WBqi on+ES/ye
&O]C)ے(~o7_{e+7r? :oMq0n4^v-p.EԒwV=Hur,yy);+jh&33.|nl#.GXu/ݽ kx{_!f`q-PRxx{,YzZ:Ut:T
GP>qq
1Dmt]z&j'=~-lVEC[xEp1|.'~}g<ݬ{9^^{3|Lc\~b.3!o>AǶ
aQrcL9)9/lۼMK<6yYKFl`=I
NbrRzUo.w/'jdܿ+7f{m	.NJFOG}>;6`vr͟69sb32ˊ?g6Ar>JђQw╗X}/M$Iz\FNŋ?lWqQs?(L߲sc>~/~9Nhd/ښ-7ًhhV[:%J>nRs8m_9MUx$
U=[QRsni*Kɍ~d7u
&VƘ̿:\r\C
~}voFCHce70f{E5^M=#F3qBn]|3'sF hrQ4vU4uQ%~T?9bZbOu1[8OAAGQmDVE7VJfbʘ#!궽sW岌P_9{mN28&wVYÁ~rr>_U<$I4-rDc	4 R_/K^]7bO%33YO_O;6f=l^_̓.j6<ݼb92wnJZZ
ICMջwѯYO@CÉQH}M-U]ׯctÙYL1ώou)vs&4ގ&^ZMH/fr2ӭ@({׮fgȡ=]Tl;zQ8!TQ4?Ќt!*25a?6{H(>Xhmn*M˗hO/,h񰇍+u1Nw^I2iflڰoｔ5QA-l4$v4 H=	1(ĢB ϳfѵ>`pEdj8nҜ-:z;[ǆ5kˏ#LJe>|bcԡy`Æe˩fO0΅GGػu~y}Cp]m[m/pd\΃*-Aݼl9IgdV,%1R0 @e>9@C|S5͠Blk3fc(
Ƽeε`;H[Ӓqz_?>OSNM3HKֲ46=̴$/0ɞf7d<5l۲(?dGiiiHdi˨#eXBן[y-(ftS*O]mTWM
w#+́^x$L=
οth1j6omH+jĿo;_ޚjCJ$={*[Վ||wiIۛX<du<"A͵Uώ-Ut}~nR*%`ݲe4 CꝻhld6,"'0?Y̝5MDXfsӱq`JIb|U/C	5~s%M!ޝfT\7-'jφHH,DQ4P7>@G8=EgV_x$L׾=59e,aU,}N/W߈F䱇so$՝Ӟ#H4Ejn̮]3nlXqе+A    IDATؽgX|ؗ*C!}1z:8-?iE1ZIO =ՁH]-nOnD<HeU%]CU!AEE%5&TˍF^OǞxV4L)V"~:;WUM;ii,^|#e@o;֯cc{΁g'F65;l
Z[_d\o^MBSpk"OeVL9s墋.fQ8SLFf3fЎ:l)Y\s%l<<]lZaګ ʒW	DXR<\TWy[)dho9@WgO?nX4wy!^ķibMu$L{mܸ`
!wESm?Xh&'Wt;ΟE][}a8c܇&zݲ:-kd,Dx㙧Ya+A>E"SLw=\}iصz)zMZz{i9[f`J9	#3X0=i5]UAZ*SYAلL,-Ĥw>֔!(:"{ֿINzVFڛw|/Yf&njEa_<yXJMn316Var1,`TW䩧xs^~}).4{cK>NfyDcG/jIZkygcfr1pO8?k'(-OɌqHsjbx7hm:VRR,6.vrFN~;WcKqr=09NaT2S,=;鞚Lm~6U,dϳ`d̄ٳ'|Vox~Gb`ϧïǀǟin7\veQ:h>UfS02Bq<Dʸ'+3{>־wu8RәcpUg2]+Wax:qMSSg&Xv#p˧4Md/ȪM;zYǸKv͟ɓ'Ggw%L&լPk;<jWZ,[^ec;N%@BI PB Ѝcmpqý[.]6CBȖ66	g13wܙ{s~gkcSg٠Rth_}Xx+nI3fQ?4*N!lŏ3&9LѾͼZܻwb$#Y.V.~>,ubl~1^8^鉸U,/F<CL:7^4^{]A5KWb1ӗ})/NBi5p_aOb$qƛ6,h~IFkY#HOcNt75KWđ;l &'f_ΠLŻpFIooɒĀ}9SzhZdg[sGIHʟs 1ΈWkPjp.}& ұgFY=wC$zE6	Bv|jbplb
᠇#ɍ-)q3ryL"wQs.;Kin(ek`x.i#{<x_h	(5gdd;LX=/o)qcM`踉\w\RY|l+y釈DwI1tok3.@k0ܫ!?;>`]غy!6LJwEtCUbϺU2E'$IF("F>vwWP׊8W@dH A^ Vp<[+,D,P(<c?z{'F퟈pOtQ[%IJQFx쮹"no^\$"DBBaͧDUHH=Tz	:~#]kN-DT5xB4UnX:ο.PDD"mݗLG,I'_MDD4!S<EEf[W&i]^|b쏟J]k9(b!laܞ=D狅[*;=~tp_!hE׊6@Px<nqH"Z%~{V[xaipD4j4 [h^@\xP0 W t F\{!pH/D8*gHT6D(tB(N"F0䈛|Wthx7DqIkD/,QW<~D!I ~M"nDC黮v$d"2sǋ@DѐGTXdZ-Bؙ❵{WcL,zBh οqq%Ѩ5cjVoޖD4
5Gv,A( 
zR(jBy[Dd%ENbB4C(޻^L+zv1Ec0~.usE<P$\T5; $) /X.|/{n**-SG@#^/go!BB'nHetzZL$Ib
B~Q3Bb%w-%߶qmI\h[h8 Ā *t͝*z_~#$ 1ߊGD$=.r,x NoYԷBjū?L>~>Fԋ,bANWn_v5<$ҒxWv㑭$!4VۢS?F""nw׍"-*C{hrCmA Ņ7^l+PPj
§|mnL#d!%V.6qT*A~_Tm">{'do{I:vunR$ш}D9ZDMu墲UCan~Bg!-FUU~m&*^h	YvX<{,*[?[DDF_MH?\<`qvLT$ms~,v}eY7_\0 G	WkM}b_YswImH$(>1}`r/{WֵUP[!~yj6,	,<N^TDqh*1oid۫s"O|T,T1O	 ѷ'հ_Vlc3S^[\}˳pGEDc}xwI I"gt1o>+\گ Vo.p{C"ל?FX:It[^/~H#?⏷@~ĘDQ";7[ogδ)\~,ۼV8VOB޹J#ΠϷ=fjײM00zf @h<Oȇ?A[zoVk\1?6IjSJ$	FFӮH*e4x@L'4f0F74i#KO$bkl<A8g4n\ZM'!'#'V%'b5heZƒxSG186D.gHZ#1mh&6B_6KĠa2Qe	'DG_ʲ!JHDIPMk`03}y, eƇ_1Y&obߟo$d1z@6:X^ѣ:|8_<s/Ǵ9>!]HIB4HI$KhR d]+"|4$e[`Ƙl::yING[)ݻ8^`Pp\3y0IPZ?p8Bs㹛n濁!)m+ZE&#%͙VS}ܸ]%&
ο]7d+N%o)_0:3oM.Lܫ/e@67f0I d-@BedMUpIBnW$¡ O+#ǎa!NOl]dهcFO[AiI=D_~1qL&.C1,^p	}4{,e
&g_5NѠ3۹g?<4F[`.3jucfGEeAB>Bmsmz6CQNǸg?	LWi#H[&oF(_^akm3T
dL<9gbb7k6CzɃ>-$93XD-|_]?83E(:ÇI;{Vӽ'Qt'`(GCw
Yt
N5veӢ)	#Ν~{-qfJGiK3,vUlNFNF":}L2_68;P
Q$S,1}qAiU3M4imqpPWWKGp0H>`u;kydb4,OD`Ja<l&4~?doe[/.gQՓzᗿCo`4OyGEc}VFFd4$5˶I=k`yq4hcd=fbҚ,$$b@٤'&++i0Z:T5HC]4%1)i#Rb9Ȍշxٵv3euF&w!ɱhO7mBCȄ=T% 	?85:f!F^JH($eWOD#?-.*9TY?F(*z\Mu{Zon	f礼$k>r5VĴ$Z*jp0J=p QQϨj$0[QdAĘ9dtF3yM\z2eX1Zg02ldlV1cY$L$MX{n'F6Ux|as&LaO˫iZve$'u#
Ii3v
ﭥp\%=X!fa;fiZѨzNk13EAh4B(Ռe|.	i:MDj)k,	&iS	BD@jaJ./ژDFwK+f+S7xض(b7 3t(NŖĈ?)ظ|#G65ؿy~UݚiÈ'C70`ؘ;I|%
hƕ4Z'Ҋ)6{vm%n,ه#"
DUA>G{J8w%ɒ?.jj-dff~Hϋ)r6UU5zb>$DvFK$i-$fMͧ+8ZH֭4#Qijh8wpfؔ YCzfDh4HH"!=#jQOEymc۞CTS\ZA}}{nG 'èe7^8\ul/5c{0j%GtAdI&'y20ieTa߸Y[{)+;ŬYFZF&#F%?{`Bt-z|@kh޿c9YPA
N͆8jI֠l,Le*m:M bl	̚{-'v1L *6݇̜c6}Q")Z4LS;HS-g8pp59(+aϮ=@Zٵb)qߋWNfd0SoOԈE8hniqQSUơ9xUX8S	U5WD#;Ԅn+tƏ2*j)@YOb^VcnաѴlE*f/jVWQ!L@VaȈ\')g1ĐCZV\-}NKR<1KH
:dS1XHL3cOLA}a8p67⥵Iyi째]TKN@BR	V%ИHIP	t ,t]e%"lYD[DsI9`8V+ΚtvPg4zqC8wl?&9m"M]\d%oLgb8hR23P#T"1&mutw&ityਫp?{SuDJm+P~7֑_09CrҎ[1OjȏAMq!{ihjPGص
"Qa{A{jjK쾙NRFѐ7`Du!}Q:9M$E.18}X,̦$+NHP(H("kĘ^47`(f_>V,x_GiSw3j z&ރӏu[7xd<:5(*Az	i	HFgkWɗ8p
GuaJdeLv3{3 n36'}7HTo_Ff.[EEQpvFSPN*7ǐ5<İrC;wL/8rΌ-s3d<[Xe3v"?uUE|2XOeM5*FAգUۄN/ܔn{ҁ]JeRR]SُFQju
gu}@k;A`ПC$@9ΎbQ"k YH[Nrϴv7t?ŞlE텧8P?$uzLfS{Y6dYj1|MʏhkV"j!I&&X1jO&={σoM)(рAj
P蛋|zb8dd.% p[KؾZ>yj*1Mh%&?Xc3g"(Y[q]t.fK>"6/ΞIF{$$'&Xzvo\oih!;VC(N"hR5Zz#s(F	Û/{SYSMU]iԈ[,Z~Bu
8KmQT&r\F#hE{;OHHݢ[&? Piqy;1k=`?t<Y-\س=lm*S"p'k>k#5k&~.%!E`|8j:VOq:5QUfo.mX5SG`?΀QIJdјoHJrbL<6DjbiuU$9gfGVe-\3m Z|=/" w	<EkB99͒)5陓G~@zgEqߋRCT{~g5 ̾J~uuGKk=un+I?z6zYG_QU=C,g/ntM7gSB
i8@'f^l_o,!j`Р\8BLM
LpTu,fg"/VOɂc7yCÑ=oibͦuxtA`@KvO+oXRzLŠbџtzcL
2}{ryv
7A9̜<
ݷhdcMWgws>ۄπ9㕇ራkԙtxyxTKI׏eF=x
<Z1o;$IBo!70@yg!.}{$>    IDATMKQU̮*
XGt4!QJ/珏
}g0q`cȜ_,'1`8&\TYAa=JjQ]@n݉Ҙ42FOMQWŞ/6KYxJ4g_dHG77NK@#I5D)k㾑Ƀ:ɳgbZ/2r2^]YD}K3:uYe=H'yjJ$O?Ćb:=sꛘ1e$)ztZ=Dl{?sDJo'Wr/Π)'^ͻhgYJb2)}_l Ktb$%rw:" IVs馛n5<%TzYj%M^j9QvoXȂ)oB&9,CXP ܮ3rn޶Rl@3vCY! /)HI׷Eh,~Çg46hLO'N¤z$IF=UҨ$'Y}ZࡪbeLsXf5Վ&LI>x7F6H'O?"kkp<s>b2>_z1{`i%%gi5籿~@ST$n.|9DG|"Jޠsk?r qV:=:܁F>z[.6+trq=!V'p K:B
|7N=J8YOE6Vn9ĕ:1lMǾhť0j+c=$^Km%)sfa6;"8|JST'b)7^ )idclݰ?=7Phib#hdW4Ze3h 5߹J Ξ8L dEKJ1LIoGkZ8rzeXviB9Ѡ֚Se4ydpsb]M]`Lkt}!-=zR&}0$b隭4{H$)~Y*lHq}&ȊeV:㳺!dJZb62RzVߓ1M7t!~4>@2oKqϥg=nj4BSn^pe5N82$(cVm+p26k,}W-h~@ftf*Jml+Ysc`V@V:m9Mɔ3Fci2@$ľc(ܿʰ'$+?=3Qp`IF:R|^Basˌ\V>f9/?p+KacBpY~=ΖT\6r31h4?T ΞJD4ʏϯOE]+Ƙ.!~<k	6KphKSvVɛZP4hZ2ws>E!)%\LKc⋌tl4pZ\Ơ7oR#J~@tfdAJIfg58PLpR5Q[Ţ)D4R5.xroF<B<f?XlY̜0+G/?>S>%$	EǖDNAsYIqȒD4%z^D6dނ:[9>k!qd<xykAkI`Vtj/^;{
ɖeD%W?ZoU%eT;/X_g>[5g L(*Hݛ	ApD~\5|~FBxyp8aR3q]0cx.6AjPF˨CNb4|$T|N$,+:L}+AKUV>^/t=-=lcdl)ۃzM7tf 9b]44w  "E허Oa)h6IL0gGjh">)/fݲ4xT$IOq#YϢwC:}>$Y՗)AjED)?|M_lȞ6.H[yܬZ!.'Xo:ʼW=;;DYn,?|"}3[:	W/cՑ|=F`D9qlmJao+Ņl?Z%7RYSE8E0h(Iو0ok+>^LLB~;/G_
DΝ~
mVg$DSuM~axn_c*_9LBVjJx)FH26^VqP2}˃Gt	Ao4!I2~\~8[k<b'e;p:8o'^/bOeH<N]Ғޫ? jv.`N|FdvOڞH#߷EPZYCK0"蠪5eͨBkgVR$HONH[JFNBՀA>׋,^z'`0Hk#|0-mCYi95X]䍙ɠ)ͬ蟼t#_!c0*;q%IF Q5J}MZBYkn5"kdYju'V5Ul^1ơk/YTSGAK(&
imE}e[pBmK_k+_Ͼ>5uNLs~|3LOӊ|/h4f$IBDWpD"aκj^Db- 
R_SᠥKxc'1W CSm^[hlp5:(9gf:}F20'λ馛n&g2q꓁J<:J+p48ijjɉOolO9PEAҘ6q99DvZoV`0J]U)Ew*zl<1'wȟR{YRE#ݹ@ǏVPPRmqQ[Q5sgrj'cy335ƏypW@ 硡Z'm;y5?G 1FQţ?E?ΖdYDAFdhzGMx~dEnEd|
]-x΂g_boKjIې%	RqGPp8LQǑ}xxۓũ-pG]>+y~ZOh{5ZXiEU{QԈ'
imn8h#D۸>o5D#!Nj8'-Fcf&9>b<VzZ,ӗugO.9?4$]yGT>%d7ٸl!G0d@.q]_lPia$dYfU70k(i̹|_d$ffp1yl/km̢7NmyW_~"gloAeN}22 H2=b|,xvk@jc&2w<.K7`%q%3d`ߎmه'`ĕ8#R`H(:B"#w~Yg Cn>vkG;x2]~dF_^9/>HKn.u26,+>i5:O();ܷƤa7gXxIjwTDQ=mdTNuQ?%ɧuױxsAsq<`f7
^{|V~rtzY,\_  N`&Co$3]cgl_qU8)ٷ&fMEfKyl-A'qWb~馛n*B<OѵQUٻe=y0s
FG#T-fۆl;$dYèIӹa*zπQ9iN^{Nw_5WehnUyoٺ8<>l\{=NcJg|^Fo#TãƸ}9#M`5ކz#1etrCyw<VmC6	AՏzJc9;xwC7 {KPllKcw217AݧF7~K|EG0G0~x.xf'Ek`M7A2S{0m%\8#|l_1Zҋ+m6%lwY\SVˀhle׸v)&-ìx?\:'і}2p$ɖ1_ӈzEؤf^x!II}Ȏ)nTٵc><r-1&6-Ynޯ;!Yz(ޞLV!w-{?~;dqi\u5?qdsa:>>JS][oz'P_O>w-+Ihc}L[Y7O&?@L\wF76stvnA4%AdIf7=7#-Ud\JxyyLu[C={(qŪOػy5:!T?~̤~νGfR[Nc^] N5,|-d^)v)ك^"7\'UE#|U9y1wL/	;XL,el+3b@'ߕԞ3=IϴsE}E1>$琛]Гoٺ(Mu,zUV|j4B0GƠ)?"~+v:1ZK:w7T(~Zc;zJ8"Qʹv\տ`h	BvCTv7ʾ1tgJdy滙b?\ן_}-,aK末$lkw:ޢb&N@Rb6"ϭ׹<*Q8~u$Y%y|Y<UhqsK:$I
y} olL}T{n濍Ǡsk<}1.[)-܃F&DHŖ?°OgNd%?/~x*ZٴCvoXNѠFx=0	=0Gwqgd$]"&f&vop*y:.&ETm_ky\mayȾɔl^*|Bk,٩kϟLy<}l[|N (~?HLbMg?d=p4c̚G	#EǹsЯw)[^@Z>ҽGPQ}Ǝ.&S{2|u	U7ݛPp(?*:p$sϼQi`0voMo>fD~$1BF
Vn01m:j)^_vC X@l_)6*_oyc'?x <Կwc|㢶"TB~?Qzyzˋ	9Rk{gvTYp>Ow>CYa-P<:ZÞugrE	2TfrEt򰝚nYއyS.cm,_& hNg jcqL0#$!3%;j07&gX+J)ArQ,[	w 
tS2L4VOưY<p+|F!m3vz#ə=e-,ZFYU@*46lq7Y33j ldLV\Fl@AR	JJ
q	)+( 蝙QuޞBAdy˷Bg4+yM䕐$Ig )i#+9ks|`T>y=џܡa<kSlA )zP@hI->'ٺm4Q(Z2s}ѥǺ7$f`FǨɗsɼ76* I2Z[
#ϝ1 '[/ʪiT3H
Y/(@I7u1d`t ]bz' 
F*h;/Se&c2__z%>`ɚ4Z	`4[7d3gOcpl.o"$ZH=BIae[%ŋ$K&h38`>$~-!+z׏?Ø+ybJmi=Ng$֋O	7wvF '`v R0hxas:nn
IV03y.vΊUkSXG$hcߠ1>
#%-)($+Xҙ{Ir.?z;UBZf.CFM`Ɍ6S}[#
H z8y5~C
C)X_H:.qBqohzHLRb 5q.EK"{݅%xA2Z%33mD>J*0BQT@1I͈#蟓>]J HH|\$Q2=`Hc<\RJOd\päMclsVP8@"1%̜5sǌwjlJ5.$ٙX}t1ť0i6%$CLMFp}dEŠȌ5w4p-iz3 9.ds%WDM^H$"Fbm!:Ko,X)J	#U`2~̞LJ/6'bGd9O=/ūhhtD5ZF15]H\XM@%K~lʗb㿺6cF&>F#?F+mQ h%A-5+o\GT@ҠbL?t[=Th7Nؔ\nXe"15dj7vDlOaM5tK?P(Z-fe=;N7GlR&韓|ӆdHOn8DnhFjjw&"CRR2iɤ$'B{J\Yksßþv P_GEY5F"F%&6t3Ұ'mi:G!cFw7S]]CUu7hYk )5R'	8T8RIJ@jVoV˱-F?KvFɝH$JSc# qY$ح'u
0HLN#g#.c^ɝ&㎤F]TUT؂5.TR6aG=ՕT5 4
k.	a'pC]m-EEE8]n$Id!1%TRSQU%4SIN K*558NIهF]hM&azZ8Z\q!!)6|rjUP$22HNL4Q"'#3%Fp6,cKH!#-	"QQTJ O$>Ύ8'Px.*K)+C+)악լG"QY#YQ]NSS3QL8X馛n=-8TVVLHI 'AfF:dvD[r*˩mp{Fq%q{|ǉ^M;H,Y.>K>+lR4i.ǎcaኪͤ\F8sf=%ymKʤMEubk4xG#IBIIlpBʌkmx;n^`0d(S<3VG  bIDATށᢖꚒʕLcMrԵj%EQH4շuze3ieL]vvj)f([^`4d&􋁃i:Vuhew58F<֖rs]z:=DRT_Wį]R먮4 EbXyυ`/;iHNON`IK=naXX$tꌇm=٫j<]{҆,Ӯ-:\Ǖ)RP6ițj{.7b>i<7W8UkO
e$*ZE9:m`<ZPjI4jLf'T.fέM)3nHVC/FYJJ4u'G
Ê
%Y1y~t5STZĳLa_vj]lҲ6im?wnL!X~yX-{q6DVdr*-YVZKm5zB[V78j4;Q(?Bh?m:÷á[}{.    
z^ʛ\yK+[j    WBXݝ(4kя`G
;MEu     MXV5MG\LAw?X76y    W	.u%]lF'/uλz͛+    A!X\̛sz࡚펼2n޸`    x      '     \&      >M      |       4     Ah          	     B      &      >~oB$c2C    IENDB`